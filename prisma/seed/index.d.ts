
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model Objective
 * 
 */
export type Objective = $Result.DefaultSelection<Prisma.$ObjectivePayload>
/**
 * Model ModuleAssignment
 * 
 */
export type ModuleAssignment = $Result.DefaultSelection<Prisma.$ModuleAssignmentPayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model ExamExercise
 * 
 */
export type ExamExercise = $Result.DefaultSelection<Prisma.$ExamExercisePayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model Holiday
 * 
 */
export type Holiday = $Result.DefaultSelection<Prisma.$HolidayPayload>
/**
 * Model LessonSchedule
 * 
 */
export type LessonSchedule = $Result.DefaultSelection<Prisma.$LessonSchedulePayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ShopItemForSale
 * 
 */
export type ShopItemForSale = $Result.DefaultSelection<Prisma.$ShopItemForSalePayload>
/**
 * Model ShopItemForRent
 * 
 */
export type ShopItemForRent = $Result.DefaultSelection<Prisma.$ShopItemForRentPayload>
/**
 * Model PurchasedItem
 * 
 */
export type PurchasedItem = $Result.DefaultSelection<Prisma.$PurchasedItemPayload>
/**
 * Model RentalPeriod
 * 
 */
export type RentalPeriod = $Result.DefaultSelection<Prisma.$RentalPeriodPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CourseStatusEnum: {
  DRAFT: 'DRAFT',
  COMPLETED: 'COMPLETED',
  ARCHIVED: 'ARCHIVED'
};

export type CourseStatusEnum = (typeof CourseStatusEnum)[keyof typeof CourseStatusEnum]


export const ExerciseTypeEnum: {
  MULTIPLE_CHOICE: 'MULTIPLE_CHOICE',
  TRUE_FALSE: 'TRUE_FALSE',
  SHORT_ANSWER: 'SHORT_ANSWER',
  LONG_ANSWER: 'LONG_ANSWER',
  CODE: 'CODE',
  FILE_UPLOAD: 'FILE_UPLOAD'
};

export type ExerciseTypeEnum = (typeof ExerciseTypeEnum)[keyof typeof ExerciseTypeEnum]


export const DifficultyLevelEnum: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
  EXPERT: 'EXPERT'
};

export type DifficultyLevelEnum = (typeof DifficultyLevelEnum)[keyof typeof DifficultyLevelEnum]


export const ExamTypeEnum: {
  QUIZ: 'QUIZ',
  MIDTERM: 'MIDTERM',
  FINAL: 'FINAL',
  PRACTICE: 'PRACTICE'
};

export type ExamTypeEnum = (typeof ExamTypeEnum)[keyof typeof ExamTypeEnum]


export const MaterialType: {
  DOCUMENT: 'DOCUMENT',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  LINK: 'LINK',
  OTHER: 'OTHER'
};

export type MaterialType = (typeof MaterialType)[keyof typeof MaterialType]


export const EnrollmentStatusEnum: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type EnrollmentStatusEnum = (typeof EnrollmentStatusEnum)[keyof typeof EnrollmentStatusEnum]


export const EventTypeEnum: {
  MEETING: 'MEETING',
  PROJECT: 'PROJECT',
  OTHER: 'OTHER'
};

export type EventTypeEnum = (typeof EventTypeEnum)[keyof typeof EventTypeEnum]


export const NotificationTypeEnum: {
  CREATED: 'CREATED',
  UPDATED: 'UPDATED',
  DELETED: 'DELETED',
  CLASS_STARTED: 'CLASS_STARTED',
  CLASS_ENDED: 'CLASS_ENDED',
  ENROLLMENT: 'ENROLLMENT',
  OTHER: 'OTHER'
};

export type NotificationTypeEnum = (typeof NotificationTypeEnum)[keyof typeof NotificationTypeEnum]


export const CurrencyTypeEnum: {
  USD: 'USD',
  EUR: 'EUR',
  GBP: 'GBP'
};

export type CurrencyTypeEnum = (typeof CurrencyTypeEnum)[keyof typeof CurrencyTypeEnum]


export const PublishStatusEnum: {
  PRIVATE: 'PRIVATE',
  PUBLISHED_FOR_SALE: 'PUBLISHED_FOR_SALE',
  PUBLISHED_FOR_RENT: 'PUBLISHED_FOR_RENT',
  PUBLISHED_FOR_BOTH: 'PUBLISHED_FOR_BOTH'
};

export type PublishStatusEnum = (typeof PublishStatusEnum)[keyof typeof PublishStatusEnum]


export const ShopItemTypeEnum: {
  COURSE: 'COURSE',
  MODULE: 'MODULE',
  EXERCISE: 'EXERCISE',
  EXAM: 'EXAM',
  MATERIAL: 'MATERIAL'
};

export type ShopItemTypeEnum = (typeof ShopItemTypeEnum)[keyof typeof ShopItemTypeEnum]

}

export type CourseStatusEnum = $Enums.CourseStatusEnum

export const CourseStatusEnum: typeof $Enums.CourseStatusEnum

export type ExerciseTypeEnum = $Enums.ExerciseTypeEnum

export const ExerciseTypeEnum: typeof $Enums.ExerciseTypeEnum

export type DifficultyLevelEnum = $Enums.DifficultyLevelEnum

export const DifficultyLevelEnum: typeof $Enums.DifficultyLevelEnum

export type ExamTypeEnum = $Enums.ExamTypeEnum

export const ExamTypeEnum: typeof $Enums.ExamTypeEnum

export type MaterialType = $Enums.MaterialType

export const MaterialType: typeof $Enums.MaterialType

export type EnrollmentStatusEnum = $Enums.EnrollmentStatusEnum

export const EnrollmentStatusEnum: typeof $Enums.EnrollmentStatusEnum

export type EventTypeEnum = $Enums.EventTypeEnum

export const EventTypeEnum: typeof $Enums.EventTypeEnum

export type NotificationTypeEnum = $Enums.NotificationTypeEnum

export const NotificationTypeEnum: typeof $Enums.NotificationTypeEnum

export type CurrencyTypeEnum = $Enums.CurrencyTypeEnum

export const CurrencyTypeEnum: typeof $Enums.CurrencyTypeEnum

export type PublishStatusEnum = $Enums.PublishStatusEnum

export const PublishStatusEnum: typeof $Enums.PublishStatusEnum

export type ShopItemTypeEnum = $Enums.ShopItemTypeEnum

export const ShopItemTypeEnum: typeof $Enums.ShopItemTypeEnum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.objective`: Exposes CRUD operations for the **Objective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Objectives
    * const objectives = await prisma.objective.findMany()
    * ```
    */
  get objective(): Prisma.ObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleAssignment`: Exposes CRUD operations for the **ModuleAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleAssignments
    * const moduleAssignments = await prisma.moduleAssignment.findMany()
    * ```
    */
  get moduleAssignment(): Prisma.ModuleAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examExercise`: Exposes CRUD operations for the **ExamExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamExercises
    * const examExercises = await prisma.examExercise.findMany()
    * ```
    */
  get examExercise(): Prisma.ExamExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.holiday`: Exposes CRUD operations for the **Holiday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holidays
    * const holidays = await prisma.holiday.findMany()
    * ```
    */
  get holiday(): Prisma.HolidayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonSchedule`: Exposes CRUD operations for the **LessonSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonSchedules
    * const lessonSchedules = await prisma.lessonSchedule.findMany()
    * ```
    */
  get lessonSchedule(): Prisma.LessonScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopItemForSale`: Exposes CRUD operations for the **ShopItemForSale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopItemForSales
    * const shopItemForSales = await prisma.shopItemForSale.findMany()
    * ```
    */
  get shopItemForSale(): Prisma.ShopItemForSaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopItemForRent`: Exposes CRUD operations for the **ShopItemForRent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopItemForRents
    * const shopItemForRents = await prisma.shopItemForRent.findMany()
    * ```
    */
  get shopItemForRent(): Prisma.ShopItemForRentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchasedItem`: Exposes CRUD operations for the **PurchasedItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasedItems
    * const purchasedItems = await prisma.purchasedItem.findMany()
    * ```
    */
  get purchasedItem(): Prisma.PurchasedItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rentalPeriod`: Exposes CRUD operations for the **RentalPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RentalPeriods
    * const rentalPeriods = await prisma.rentalPeriod.findMany()
    * ```
    */
  get rentalPeriod(): Prisma.RentalPeriodDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.0
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Admin: 'Admin',
    Profile: 'Profile',
    Role: 'Role',
    UserRole: 'UserRole',
    Account: 'Account',
    Session: 'Session',
    Teacher: 'Teacher',
    Student: 'Student',
    Course: 'Course',
    Module: 'Module',
    Lesson: 'Lesson',
    Topic: 'Topic',
    Objective: 'Objective',
    ModuleAssignment: 'ModuleAssignment',
    Exercise: 'Exercise',
    Exam: 'Exam',
    ExamExercise: 'ExamExercise',
    Material: 'Material',
    Comment: 'Comment',
    Enrollment: 'Enrollment',
    Class: 'Class',
    Holiday: 'Holiday',
    LessonSchedule: 'LessonSchedule',
    Event: 'Event',
    Team: 'Team',
    Client: 'Client',
    Notification: 'Notification',
    ShopItemForSale: 'ShopItemForSale',
    ShopItemForRent: 'ShopItemForRent',
    PurchasedItem: 'PurchasedItem',
    RentalPeriod: 'RentalPeriod'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "admin" | "profile" | "role" | "userRole" | "account" | "session" | "teacher" | "student" | "course" | "module" | "lesson" | "topic" | "objective" | "moduleAssignment" | "exercise" | "exam" | "examExercise" | "material" | "comment" | "enrollment" | "class" | "holiday" | "lessonSchedule" | "event" | "team" | "client" | "notification" | "shopItemForSale" | "shopItemForRent" | "purchasedItem" | "rentalPeriod"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      Objective: {
        payload: Prisma.$ObjectivePayload<ExtArgs>
        fields: Prisma.ObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          findFirst: {
            args: Prisma.ObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          findMany: {
            args: Prisma.ObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>[]
          }
          create: {
            args: Prisma.ObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          createMany: {
            args: Prisma.ObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObjectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>[]
          }
          delete: {
            args: Prisma.ObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          update: {
            args: Prisma.ObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          deleteMany: {
            args: Prisma.ObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ObjectiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>[]
          }
          upsert: {
            args: Prisma.ObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePayload>
          }
          aggregate: {
            args: Prisma.ObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObjective>
          }
          groupBy: {
            args: Prisma.ObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<ObjectiveCountAggregateOutputType> | number
          }
        }
      }
      ModuleAssignment: {
        payload: Prisma.$ModuleAssignmentPayload<ExtArgs>
        fields: Prisma.ModuleAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ModuleAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          findMany: {
            args: Prisma.ModuleAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>[]
          }
          create: {
            args: Prisma.ModuleAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          createMany: {
            args: Prisma.ModuleAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ModuleAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          update: {
            args: Prisma.ModuleAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ModuleAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.ModuleAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ModuleAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleAssignment>
          }
          groupBy: {
            args: Prisma.ModuleAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      ExamExercise: {
        payload: Prisma.$ExamExercisePayload<ExtArgs>
        fields: Prisma.ExamExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload>
          }
          findFirst: {
            args: Prisma.ExamExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload>
          }
          findMany: {
            args: Prisma.ExamExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload>[]
          }
          create: {
            args: Prisma.ExamExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload>
          }
          createMany: {
            args: Prisma.ExamExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload>[]
          }
          delete: {
            args: Prisma.ExamExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload>
          }
          update: {
            args: Prisma.ExamExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExamExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload>[]
          }
          upsert: {
            args: Prisma.ExamExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamExercisePayload>
          }
          aggregate: {
            args: Prisma.ExamExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamExercise>
          }
          groupBy: {
            args: Prisma.ExamExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExamExerciseCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      Holiday: {
        payload: Prisma.$HolidayPayload<ExtArgs>
        fields: Prisma.HolidayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HolidayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HolidayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findFirst: {
            args: Prisma.HolidayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HolidayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findMany: {
            args: Prisma.HolidayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          create: {
            args: Prisma.HolidayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          createMany: {
            args: Prisma.HolidayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HolidayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          delete: {
            args: Prisma.HolidayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          update: {
            args: Prisma.HolidayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          deleteMany: {
            args: Prisma.HolidayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HolidayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HolidayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          upsert: {
            args: Prisma.HolidayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          aggregate: {
            args: Prisma.HolidayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoliday>
          }
          groupBy: {
            args: Prisma.HolidayGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolidayGroupByOutputType>[]
          }
          count: {
            args: Prisma.HolidayCountArgs<ExtArgs>
            result: $Utils.Optional<HolidayCountAggregateOutputType> | number
          }
        }
      }
      LessonSchedule: {
        payload: Prisma.$LessonSchedulePayload<ExtArgs>
        fields: Prisma.LessonScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload>
          }
          findFirst: {
            args: Prisma.LessonScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload>
          }
          findMany: {
            args: Prisma.LessonScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload>[]
          }
          create: {
            args: Prisma.LessonScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload>
          }
          createMany: {
            args: Prisma.LessonScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload>[]
          }
          delete: {
            args: Prisma.LessonScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload>
          }
          update: {
            args: Prisma.LessonScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload>
          }
          deleteMany: {
            args: Prisma.LessonScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload>[]
          }
          upsert: {
            args: Prisma.LessonScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSchedulePayload>
          }
          aggregate: {
            args: Prisma.LessonScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonSchedule>
          }
          groupBy: {
            args: Prisma.LessonScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<LessonScheduleCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ShopItemForSale: {
        payload: Prisma.$ShopItemForSalePayload<ExtArgs>
        fields: Prisma.ShopItemForSaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopItemForSaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopItemForSaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload>
          }
          findFirst: {
            args: Prisma.ShopItemForSaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopItemForSaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload>
          }
          findMany: {
            args: Prisma.ShopItemForSaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload>[]
          }
          create: {
            args: Prisma.ShopItemForSaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload>
          }
          createMany: {
            args: Prisma.ShopItemForSaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopItemForSaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload>[]
          }
          delete: {
            args: Prisma.ShopItemForSaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload>
          }
          update: {
            args: Prisma.ShopItemForSaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload>
          }
          deleteMany: {
            args: Prisma.ShopItemForSaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopItemForSaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopItemForSaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload>[]
          }
          upsert: {
            args: Prisma.ShopItemForSaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForSalePayload>
          }
          aggregate: {
            args: Prisma.ShopItemForSaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopItemForSale>
          }
          groupBy: {
            args: Prisma.ShopItemForSaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopItemForSaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopItemForSaleCountArgs<ExtArgs>
            result: $Utils.Optional<ShopItemForSaleCountAggregateOutputType> | number
          }
        }
      }
      ShopItemForRent: {
        payload: Prisma.$ShopItemForRentPayload<ExtArgs>
        fields: Prisma.ShopItemForRentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopItemForRentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopItemForRentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload>
          }
          findFirst: {
            args: Prisma.ShopItemForRentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopItemForRentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload>
          }
          findMany: {
            args: Prisma.ShopItemForRentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload>[]
          }
          create: {
            args: Prisma.ShopItemForRentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload>
          }
          createMany: {
            args: Prisma.ShopItemForRentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopItemForRentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload>[]
          }
          delete: {
            args: Prisma.ShopItemForRentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload>
          }
          update: {
            args: Prisma.ShopItemForRentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload>
          }
          deleteMany: {
            args: Prisma.ShopItemForRentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopItemForRentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopItemForRentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload>[]
          }
          upsert: {
            args: Prisma.ShopItemForRentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemForRentPayload>
          }
          aggregate: {
            args: Prisma.ShopItemForRentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopItemForRent>
          }
          groupBy: {
            args: Prisma.ShopItemForRentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopItemForRentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopItemForRentCountArgs<ExtArgs>
            result: $Utils.Optional<ShopItemForRentCountAggregateOutputType> | number
          }
        }
      }
      PurchasedItem: {
        payload: Prisma.$PurchasedItemPayload<ExtArgs>
        fields: Prisma.PurchasedItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasedItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasedItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload>
          }
          findFirst: {
            args: Prisma.PurchasedItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasedItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload>
          }
          findMany: {
            args: Prisma.PurchasedItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload>[]
          }
          create: {
            args: Prisma.PurchasedItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload>
          }
          createMany: {
            args: Prisma.PurchasedItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasedItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload>[]
          }
          delete: {
            args: Prisma.PurchasedItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload>
          }
          update: {
            args: Prisma.PurchasedItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchasedItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasedItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasedItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchasedItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasedItemPayload>
          }
          aggregate: {
            args: Prisma.PurchasedItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasedItem>
          }
          groupBy: {
            args: Prisma.PurchasedItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasedItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasedItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasedItemCountAggregateOutputType> | number
          }
        }
      }
      RentalPeriod: {
        payload: Prisma.$RentalPeriodPayload<ExtArgs>
        fields: Prisma.RentalPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RentalPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RentalPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload>
          }
          findFirst: {
            args: Prisma.RentalPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RentalPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload>
          }
          findMany: {
            args: Prisma.RentalPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload>[]
          }
          create: {
            args: Prisma.RentalPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload>
          }
          createMany: {
            args: Prisma.RentalPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RentalPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload>[]
          }
          delete: {
            args: Prisma.RentalPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload>
          }
          update: {
            args: Prisma.RentalPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload>
          }
          deleteMany: {
            args: Prisma.RentalPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RentalPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RentalPeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload>[]
          }
          upsert: {
            args: Prisma.RentalPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPeriodPayload>
          }
          aggregate: {
            args: Prisma.RentalPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRentalPeriod>
          }
          groupBy: {
            args: Prisma.RentalPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<RentalPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.RentalPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<RentalPeriodCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    admin?: AdminOmit
    profile?: ProfileOmit
    role?: RoleOmit
    userRole?: UserRoleOmit
    account?: AccountOmit
    session?: SessionOmit
    teacher?: TeacherOmit
    student?: StudentOmit
    course?: CourseOmit
    module?: ModuleOmit
    lesson?: LessonOmit
    topic?: TopicOmit
    objective?: ObjectiveOmit
    moduleAssignment?: ModuleAssignmentOmit
    exercise?: ExerciseOmit
    exam?: ExamOmit
    examExercise?: ExamExerciseOmit
    material?: MaterialOmit
    comment?: CommentOmit
    enrollment?: EnrollmentOmit
    class?: ClassOmit
    holiday?: HolidayOmit
    lessonSchedule?: LessonScheduleOmit
    event?: EventOmit
    team?: TeamOmit
    client?: ClientOmit
    notification?: NotificationOmit
    shopItemForSale?: ShopItemForSaleOmit
    shopItemForRent?: ShopItemForRentOmit
    purchasedItem?: PurchasedItemOmit
    rentalPeriod?: RentalPeriodOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    roles: number
    comments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    moduleAssignments: number
    createdCourses: number
    ownedCourses: number
    createdModules: number
    ownedModules: number
    createdExercises: number
    ownedExercises: number
    createdExams: number
    ownedExams: number
    createdClients: number
    events: number
    notifications: number
    purchases: number
    rentalPeriods: number
    createdMaterial: number
    ownedMaterial: number
    addedStudents: number
    classes: number
    lessonsSchedule: number
    enrollments: number
    teams: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moduleAssignments?: boolean | TeacherCountOutputTypeCountModuleAssignmentsArgs
    createdCourses?: boolean | TeacherCountOutputTypeCountCreatedCoursesArgs
    ownedCourses?: boolean | TeacherCountOutputTypeCountOwnedCoursesArgs
    createdModules?: boolean | TeacherCountOutputTypeCountCreatedModulesArgs
    ownedModules?: boolean | TeacherCountOutputTypeCountOwnedModulesArgs
    createdExercises?: boolean | TeacherCountOutputTypeCountCreatedExercisesArgs
    ownedExercises?: boolean | TeacherCountOutputTypeCountOwnedExercisesArgs
    createdExams?: boolean | TeacherCountOutputTypeCountCreatedExamsArgs
    ownedExams?: boolean | TeacherCountOutputTypeCountOwnedExamsArgs
    createdClients?: boolean | TeacherCountOutputTypeCountCreatedClientsArgs
    events?: boolean | TeacherCountOutputTypeCountEventsArgs
    notifications?: boolean | TeacherCountOutputTypeCountNotificationsArgs
    purchases?: boolean | TeacherCountOutputTypeCountPurchasesArgs
    rentalPeriods?: boolean | TeacherCountOutputTypeCountRentalPeriodsArgs
    createdMaterial?: boolean | TeacherCountOutputTypeCountCreatedMaterialArgs
    ownedMaterial?: boolean | TeacherCountOutputTypeCountOwnedMaterialArgs
    addedStudents?: boolean | TeacherCountOutputTypeCountAddedStudentsArgs
    classes?: boolean | TeacherCountOutputTypeCountClassesArgs
    lessonsSchedule?: boolean | TeacherCountOutputTypeCountLessonsScheduleArgs
    enrollments?: boolean | TeacherCountOutputTypeCountEnrollmentsArgs
    teams?: boolean | TeacherCountOutputTypeCountTeamsArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountModuleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleAssignmentWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountCreatedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountOwnedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountCreatedModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountOwnedModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountCreatedExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountOwnedExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountCreatedExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountOwnedExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountCreatedClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasedItemWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountRentalPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalPeriodWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountCreatedMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountOwnedMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountAddedStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountLessonsScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonScheduleWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    classes: number
    teams: number
    notifications: number
    comments: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | StudentCountOutputTypeCountClassesArgs
    teams?: boolean | StudentCountOutputTypeCountTeamsArgs
    notifications?: boolean | StudentCountOutputTypeCountNotificationsArgs
    comments?: boolean | StudentCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    modules: number
    materials: number
    enrollments: number
    events: number
    classes: number
    comments: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | CourseCountOutputTypeCountModulesArgs
    materials?: boolean | CourseCountOutputTypeCountMaterialsArgs
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
    events?: boolean | CourseCountOutputTypeCountEventsArgs
    classes?: boolean | CourseCountOutputTypeCountClassesArgs
    comments?: boolean | CourseCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    topics: number
    materials: number
    assignments: number
    exams: number
    lessons: number
    events: number
    comments: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | ModuleCountOutputTypeCountTopicsArgs
    materials?: boolean | ModuleCountOutputTypeCountMaterialsArgs
    assignments?: boolean | ModuleCountOutputTypeCountAssignmentsArgs
    exams?: boolean | ModuleCountOutputTypeCountExamsArgs
    lessons?: boolean | ModuleCountOutputTypeCountLessonsArgs
    events?: boolean | ModuleCountOutputTypeCountEventsArgs
    comments?: boolean | ModuleCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleAssignmentWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    schedules: number
    comments: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | LessonCountOutputTypeCountSchedulesArgs
    comments?: boolean | LessonCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonScheduleWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    materials: number
    exercises: number
    objectives: number
    comments: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | TopicCountOutputTypeCountMaterialsArgs
    exercises?: boolean | TopicCountOutputTypeCountExercisesArgs
    objectives?: boolean | TopicCountOutputTypeCountObjectivesArgs
    comments?: boolean | TopicCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectiveWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ExerciseCountOutputType
   */

  export type ExerciseCountOutputType = {
    examExercises: number
    teams: number
    comments: number
  }

  export type ExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examExercises?: boolean | ExerciseCountOutputTypeCountExamExercisesArgs
    teams?: boolean | ExerciseCountOutputTypeCountTeamsArgs
    comments?: boolean | ExerciseCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     */
    select?: ExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountExamExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamExerciseWhereInput
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ExamCountOutputType
   */

  export type ExamCountOutputType = {
    exercises: number
    comments: number
  }

  export type ExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | ExamCountOutputTypeCountExercisesArgs
    comments?: boolean | ExamCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     */
    select?: ExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamExerciseWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    comments: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | MaterialCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type EnrollmentCountOutputType
   */

  export type EnrollmentCountOutputType = {
    holidays: number
    comments: number
  }

  export type EnrollmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holidays?: boolean | EnrollmentCountOutputTypeCountHolidaysArgs
    comments?: boolean | EnrollmentCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * EnrollmentCountOutputType without action
   */
  export type EnrollmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnrollmentCountOutputType
     */
    select?: EnrollmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnrollmentCountOutputType without action
   */
  export type EnrollmentCountOutputTypeCountHolidaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolidayWhereInput
  }

  /**
   * EnrollmentCountOutputType without action
   */
  export type EnrollmentCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    students: number
    teams: number
    enrollments: number
    comments: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | ClassCountOutputTypeCountStudentsArgs
    teams?: boolean | ClassCountOutputTypeCountTeamsArgs
    enrollments?: boolean | ClassCountOutputTypeCountEnrollmentsArgs
    comments?: boolean | ClassCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    comments: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | EventCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    students: number
    exercises: number
    comments: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | TeamCountOutputTypeCountStudentsArgs
    exercises?: boolean | TeamCountOutputTypeCountExercisesArgs
    comments?: boolean | TeamCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    exercises: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | ClientCountOutputTypeCountExercisesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }


  /**
   * Count Type ShopItemForSaleCountOutputType
   */

  export type ShopItemForSaleCountOutputType = {
    purchases: number
  }

  export type ShopItemForSaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | ShopItemForSaleCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * ShopItemForSaleCountOutputType without action
   */
  export type ShopItemForSaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSaleCountOutputType
     */
    select?: ShopItemForSaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopItemForSaleCountOutputType without action
   */
  export type ShopItemForSaleCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasedItemWhereInput
  }


  /**
   * Count Type ShopItemForRentCountOutputType
   */

  export type ShopItemForRentCountOutputType = {
    rentalPeriods: number
  }

  export type ShopItemForRentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rentalPeriods?: boolean | ShopItemForRentCountOutputTypeCountRentalPeriodsArgs
  }

  // Custom InputTypes
  /**
   * ShopItemForRentCountOutputType without action
   */
  export type ShopItemForRentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRentCountOutputType
     */
    select?: ShopItemForRentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopItemForRentCountOutputType without action
   */
  export type ShopItemForRentCountOutputTypeCountRentalPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalPeriodWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    userApiToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastAccessedAt: Date | null
    isActive: boolean | null
    isDeleted: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    userApiToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastAccessedAt: Date | null
    isActive: boolean | null
    isDeleted: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    userApiToken: number
    createdAt: number
    updatedAt: number
    lastAccessedAt: number
    isActive: number
    isDeleted: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    userApiToken?: true
    createdAt?: true
    updatedAt?: true
    lastAccessedAt?: true
    isActive?: true
    isDeleted?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    userApiToken?: true
    createdAt?: true
    updatedAt?: true
    lastAccessedAt?: true
    isActive?: true
    isDeleted?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    userApiToken?: true
    createdAt?: true
    updatedAt?: true
    lastAccessedAt?: true
    isActive?: true
    isDeleted?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerified: Date | null
    userApiToken: string
    createdAt: Date
    updatedAt: Date
    lastAccessedAt: Date | null
    isActive: boolean
    isDeleted: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    userApiToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessedAt?: boolean
    isActive?: boolean
    isDeleted?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    userApiToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessedAt?: boolean
    isActive?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    userApiToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessedAt?: boolean
    isActive?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    userApiToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessedAt?: boolean
    isActive?: boolean
    isDeleted?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "emailVerified" | "userApiToken" | "createdAt" | "updatedAt" | "lastAccessedAt" | "isActive" | "isDeleted", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerified: Date | null
      userApiToken: string
      createdAt: Date
      updatedAt: Date
      lastAccessedAt: Date | null
      isActive: boolean
      isDeleted: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    teacher<T extends User$teacherArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly userApiToken: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastAccessedAt: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.teacher
   */
  export type User$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    displayName: string | null
    bio: string | null
    birthDate: Date | null
    phoneNumber: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    displayName: string | null
    bio: string | null
    birthDate: Date | null
    phoneNumber: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    displayName: number
    bio: number
    birthDate: number
    phoneNumber: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    displayName?: true
    bio?: true
    birthDate?: true
    phoneNumber?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    displayName?: true
    bio?: true
    birthDate?: true
    phoneNumber?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    displayName?: true
    bio?: true
    birthDate?: true
    phoneNumber?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    firstName: string | null
    lastName: string | null
    displayName: string | null
    bio: string | null
    birthDate: Date | null
    phoneNumber: string | null
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    displayName?: boolean
    bio?: boolean
    birthDate?: boolean
    phoneNumber?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    displayName?: boolean
    bio?: boolean
    birthDate?: boolean
    phoneNumber?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    displayName?: boolean
    bio?: boolean
    birthDate?: boolean
    phoneNumber?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    displayName?: boolean
    bio?: boolean
    birthDate?: boolean
    phoneNumber?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "displayName" | "bio" | "birthDate" | "phoneNumber", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string | null
      lastName: string | null
      displayName: string | null
      bio: string | null
      birthDate: Date | null
      phoneNumber: string | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly firstName: FieldRef<"Profile", 'String'>
    readonly lastName: FieldRef<"Profile", 'String'>
    readonly displayName: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly birthDate: FieldRef<"Profile", 'DateTime'>
    readonly phoneNumber: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: string | null
    roleId: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null
    roleId: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: string
    roleId: string
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: string
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    oauth_token_secret: number
    oauth_token: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    oauth_token_secret?: boolean
    oauth_token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    oauth_token_secret?: boolean
    oauth_token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    oauth_token_secret?: boolean
    oauth_token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    oauth_token_secret?: boolean
    oauth_token?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "oauth_token_secret" | "oauth_token", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      oauth_token_secret: string | null
      oauth_token: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly oauth_token_secret: FieldRef<"Account", 'String'>
    readonly oauth_token: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    userId: string | null
    specialization: string | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    specialization: string | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    userId: number
    specialization: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    userId: string
    specialization: string | null
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    specialization?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    moduleAssignments?: boolean | Teacher$moduleAssignmentsArgs<ExtArgs>
    createdCourses?: boolean | Teacher$createdCoursesArgs<ExtArgs>
    ownedCourses?: boolean | Teacher$ownedCoursesArgs<ExtArgs>
    createdModules?: boolean | Teacher$createdModulesArgs<ExtArgs>
    ownedModules?: boolean | Teacher$ownedModulesArgs<ExtArgs>
    createdExercises?: boolean | Teacher$createdExercisesArgs<ExtArgs>
    ownedExercises?: boolean | Teacher$ownedExercisesArgs<ExtArgs>
    createdExams?: boolean | Teacher$createdExamsArgs<ExtArgs>
    ownedExams?: boolean | Teacher$ownedExamsArgs<ExtArgs>
    createdClients?: boolean | Teacher$createdClientsArgs<ExtArgs>
    events?: boolean | Teacher$eventsArgs<ExtArgs>
    notifications?: boolean | Teacher$notificationsArgs<ExtArgs>
    purchases?: boolean | Teacher$purchasesArgs<ExtArgs>
    rentalPeriods?: boolean | Teacher$rentalPeriodsArgs<ExtArgs>
    createdMaterial?: boolean | Teacher$createdMaterialArgs<ExtArgs>
    ownedMaterial?: boolean | Teacher$ownedMaterialArgs<ExtArgs>
    addedStudents?: boolean | Teacher$addedStudentsArgs<ExtArgs>
    classes?: boolean | Teacher$classesArgs<ExtArgs>
    lessonsSchedule?: boolean | Teacher$lessonsScheduleArgs<ExtArgs>
    enrollments?: boolean | Teacher$enrollmentsArgs<ExtArgs>
    teams?: boolean | Teacher$teamsArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    specialization?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    specialization?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectScalar = {
    id?: boolean
    userId?: boolean
    specialization?: boolean
  }

  export type TeacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "specialization", ExtArgs["result"]["teacher"]>
  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    moduleAssignments?: boolean | Teacher$moduleAssignmentsArgs<ExtArgs>
    createdCourses?: boolean | Teacher$createdCoursesArgs<ExtArgs>
    ownedCourses?: boolean | Teacher$ownedCoursesArgs<ExtArgs>
    createdModules?: boolean | Teacher$createdModulesArgs<ExtArgs>
    ownedModules?: boolean | Teacher$ownedModulesArgs<ExtArgs>
    createdExercises?: boolean | Teacher$createdExercisesArgs<ExtArgs>
    ownedExercises?: boolean | Teacher$ownedExercisesArgs<ExtArgs>
    createdExams?: boolean | Teacher$createdExamsArgs<ExtArgs>
    ownedExams?: boolean | Teacher$ownedExamsArgs<ExtArgs>
    createdClients?: boolean | Teacher$createdClientsArgs<ExtArgs>
    events?: boolean | Teacher$eventsArgs<ExtArgs>
    notifications?: boolean | Teacher$notificationsArgs<ExtArgs>
    purchases?: boolean | Teacher$purchasesArgs<ExtArgs>
    rentalPeriods?: boolean | Teacher$rentalPeriodsArgs<ExtArgs>
    createdMaterial?: boolean | Teacher$createdMaterialArgs<ExtArgs>
    ownedMaterial?: boolean | Teacher$ownedMaterialArgs<ExtArgs>
    addedStudents?: boolean | Teacher$addedStudentsArgs<ExtArgs>
    classes?: boolean | Teacher$classesArgs<ExtArgs>
    lessonsSchedule?: boolean | Teacher$lessonsScheduleArgs<ExtArgs>
    enrollments?: boolean | Teacher$enrollmentsArgs<ExtArgs>
    teams?: boolean | Teacher$teamsArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      moduleAssignments: Prisma.$ModuleAssignmentPayload<ExtArgs>[]
      createdCourses: Prisma.$CoursePayload<ExtArgs>[]
      ownedCourses: Prisma.$CoursePayload<ExtArgs>[]
      createdModules: Prisma.$ModulePayload<ExtArgs>[]
      ownedModules: Prisma.$ModulePayload<ExtArgs>[]
      createdExercises: Prisma.$ExercisePayload<ExtArgs>[]
      ownedExercises: Prisma.$ExercisePayload<ExtArgs>[]
      createdExams: Prisma.$ExamPayload<ExtArgs>[]
      ownedExams: Prisma.$ExamPayload<ExtArgs>[]
      createdClients: Prisma.$ClientPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      purchases: Prisma.$PurchasedItemPayload<ExtArgs>[]
      rentalPeriods: Prisma.$RentalPeriodPayload<ExtArgs>[]
      createdMaterial: Prisma.$MaterialPayload<ExtArgs>[]
      ownedMaterial: Prisma.$MaterialPayload<ExtArgs>[]
      addedStudents: Prisma.$StudentPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      lessonsSchedule: Prisma.$LessonSchedulePayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      specialization: string | null
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {TeacherUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    moduleAssignments<T extends Teacher$moduleAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$moduleAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    createdCourses<T extends Teacher$createdCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$createdCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ownedCourses<T extends Teacher$ownedCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$ownedCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    createdModules<T extends Teacher$createdModulesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$createdModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ownedModules<T extends Teacher$ownedModulesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$ownedModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    createdExercises<T extends Teacher$createdExercisesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$createdExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ownedExercises<T extends Teacher$ownedExercisesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$ownedExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    createdExams<T extends Teacher$createdExamsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$createdExamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ownedExams<T extends Teacher$ownedExamsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$ownedExamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    createdClients<T extends Teacher$createdClientsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$createdClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    events<T extends Teacher$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    notifications<T extends Teacher$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    purchases<T extends Teacher$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    rentalPeriods<T extends Teacher$rentalPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$rentalPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    createdMaterial<T extends Teacher$createdMaterialArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$createdMaterialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ownedMaterial<T extends Teacher$ownedMaterialArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$ownedMaterialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    addedStudents<T extends Teacher$addedStudentsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$addedStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    classes<T extends Teacher$classesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    lessonsSchedule<T extends Teacher$lessonsScheduleArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$lessonsScheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    enrollments<T extends Teacher$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    teams<T extends Teacher$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */ 
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly userId: FieldRef<"Teacher", 'String'>
    readonly specialization: FieldRef<"Teacher", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher createManyAndReturn
   */
  export type TeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teacher updateManyAndReturn
   */
  export type TeacherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teacher.moduleAssignments
   */
  export type Teacher$moduleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    where?: ModuleAssignmentWhereInput
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    cursor?: ModuleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * Teacher.createdCourses
   */
  export type Teacher$createdCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Teacher.ownedCourses
   */
  export type Teacher$ownedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Teacher.createdModules
   */
  export type Teacher$createdModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Teacher.ownedModules
   */
  export type Teacher$ownedModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Teacher.createdExercises
   */
  export type Teacher$createdExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Teacher.ownedExercises
   */
  export type Teacher$ownedExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Teacher.createdExams
   */
  export type Teacher$createdExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Teacher.ownedExams
   */
  export type Teacher$ownedExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Teacher.createdClients
   */
  export type Teacher$createdClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Teacher.events
   */
  export type Teacher$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Teacher.notifications
   */
  export type Teacher$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Teacher.purchases
   */
  export type Teacher$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    where?: PurchasedItemWhereInput
    orderBy?: PurchasedItemOrderByWithRelationInput | PurchasedItemOrderByWithRelationInput[]
    cursor?: PurchasedItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasedItemScalarFieldEnum | PurchasedItemScalarFieldEnum[]
  }

  /**
   * Teacher.rentalPeriods
   */
  export type Teacher$rentalPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    where?: RentalPeriodWhereInput
    orderBy?: RentalPeriodOrderByWithRelationInput | RentalPeriodOrderByWithRelationInput[]
    cursor?: RentalPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalPeriodScalarFieldEnum | RentalPeriodScalarFieldEnum[]
  }

  /**
   * Teacher.createdMaterial
   */
  export type Teacher$createdMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Teacher.ownedMaterial
   */
  export type Teacher$ownedMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Teacher.addedStudents
   */
  export type Teacher$addedStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Teacher.classes
   */
  export type Teacher$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Teacher.lessonsSchedule
   */
  export type Teacher$lessonsScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    where?: LessonScheduleWhereInput
    orderBy?: LessonScheduleOrderByWithRelationInput | LessonScheduleOrderByWithRelationInput[]
    cursor?: LessonScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScheduleScalarFieldEnum | LessonScheduleScalarFieldEnum[]
  }

  /**
   * Teacher.enrollments
   */
  export type Teacher$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Teacher.teams
   */
  export type Teacher$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    enrollYear: number | null
  }

  export type StudentSumAggregateOutputType = {
    enrollYear: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    studentId: string | null
    enrollYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
    addedById: string | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    studentId: string | null
    enrollYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
    addedById: string | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    studentId: number
    enrollYear: number
    createdAt: number
    updatedAt: number
    addedById: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    enrollYear?: true
  }

  export type StudentSumAggregateInputType = {
    enrollYear?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    enrollYear?: true
    createdAt?: true
    updatedAt?: true
    addedById?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    enrollYear?: true
    createdAt?: true
    updatedAt?: true
    addedById?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    enrollYear?: true
    createdAt?: true
    updatedAt?: true
    addedById?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    studentId: string
    enrollYear: number
    createdAt: Date
    updatedAt: Date
    addedById: string
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    enrollYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addedById?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    classes?: boolean | Student$classesArgs<ExtArgs>
    teams?: boolean | Student$teamsArgs<ExtArgs>
    notifications?: boolean | Student$notificationsArgs<ExtArgs>
    comments?: boolean | Student$commentsArgs<ExtArgs>
    addedBy?: boolean | TeacherDefaultArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    enrollYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addedById?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    enrollYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addedById?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    studentId?: boolean
    enrollYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addedById?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "studentId" | "enrollYear" | "createdAt" | "updatedAt" | "addedById", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    classes?: boolean | Student$classesArgs<ExtArgs>
    teams?: boolean | Student$teamsArgs<ExtArgs>
    notifications?: boolean | Student$notificationsArgs<ExtArgs>
    comments?: boolean | Student$commentsArgs<ExtArgs>
    addedBy?: boolean | TeacherDefaultArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      classes: Prisma.$ClassPayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      addedBy: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      studentId: string
      enrollYear: number
      createdAt: Date
      updatedAt: Date
      addedById: string
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    classes<T extends Student$classesArgs<ExtArgs> = {}>(args?: Subset<T, Student$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    teams<T extends Student$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Student$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    notifications<T extends Student$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends Student$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    addedBy<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly studentId: FieldRef<"Student", 'String'>
    readonly enrollYear: FieldRef<"Student", 'Int'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
    readonly addedById: FieldRef<"Student", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.classes
   */
  export type Student$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Student.teams
   */
  export type Student$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Student.notifications
   */
  export type Student$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Student.comments
   */
  export type Student$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    category: string | null
    status: $Enums.CourseStatusEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    ownerId: string | null
    publishStatus: $Enums.PublishStatusEnum | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    category: string | null
    status: $Enums.CourseStatusEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    ownerId: string | null
    publishStatus: $Enums.PublishStatusEnum | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    category: number
    status: number
    createdAt: number
    updatedAt: number
    creatorId: number
    ownerId: number
    publishStatus: number
    _all: number
  }


  export type CourseMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    ownerId?: true
    publishStatus?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    ownerId?: true
    publishStatus?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    category?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    ownerId?: true
    publishStatus?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    slug: string
    name: string
    description: string | null
    category: string
    status: $Enums.CourseStatusEnum
    createdAt: Date
    updatedAt: Date
    creatorId: string
    ownerId: string
    publishStatus: $Enums.PublishStatusEnum
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    publishStatus?: boolean
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    modules?: boolean | Course$modulesArgs<ExtArgs>
    materials?: boolean | Course$materialsArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    events?: boolean | Course$eventsArgs<ExtArgs>
    classes?: boolean | Course$classesArgs<ExtArgs>
    comments?: boolean | Course$commentsArgs<ExtArgs>
    forSale?: boolean | Course$forSaleArgs<ExtArgs>
    forRent?: boolean | Course$forRentArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    publishStatus?: boolean
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    publishStatus?: boolean
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    publishStatus?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "description" | "category" | "status" | "createdAt" | "updatedAt" | "creatorId" | "ownerId" | "publishStatus", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    modules?: boolean | Course$modulesArgs<ExtArgs>
    materials?: boolean | Course$materialsArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    events?: boolean | Course$eventsArgs<ExtArgs>
    classes?: boolean | Course$classesArgs<ExtArgs>
    comments?: boolean | Course$commentsArgs<ExtArgs>
    forSale?: boolean | Course$forSaleArgs<ExtArgs>
    forRent?: boolean | Course$forRentArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      creator: Prisma.$TeacherPayload<ExtArgs>
      owner: Prisma.$TeacherPayload<ExtArgs>
      modules: Prisma.$ModulePayload<ExtArgs>[]
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      forSale: Prisma.$ShopItemForSalePayload<ExtArgs> | null
      forRent: Prisma.$ShopItemForRentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      description: string | null
      category: string
      status: $Enums.CourseStatusEnum
      createdAt: Date
      updatedAt: Date
      creatorId: string
      ownerId: string
      publishStatus: $Enums.PublishStatusEnum
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    owner<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    modules<T extends Course$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Course$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    materials<T extends Course$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Course$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    events<T extends Course$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Course$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    classes<T extends Course$classesArgs<ExtArgs> = {}>(args?: Subset<T, Course$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends Course$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    forSale<T extends Course$forSaleArgs<ExtArgs> = {}>(args?: Subset<T, Course$forSaleArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    forRent<T extends Course$forRentArgs<ExtArgs> = {}>(args?: Subset<T, Course$forRentArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly slug: FieldRef<"Course", 'String'>
    readonly name: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly category: FieldRef<"Course", 'String'>
    readonly status: FieldRef<"Course", 'CourseStatusEnum'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
    readonly creatorId: FieldRef<"Course", 'String'>
    readonly ownerId: FieldRef<"Course", 'String'>
    readonly publishStatus: FieldRef<"Course", 'PublishStatusEnum'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.modules
   */
  export type Course$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Course.materials
   */
  export type Course$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Course.events
   */
  export type Course$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Course.classes
   */
  export type Course$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Course.comments
   */
  export type Course$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Course.forSale
   */
  export type Course$forSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    where?: ShopItemForSaleWhereInput
  }

  /**
   * Course.forRent
   */
  export type Course$forRentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    where?: ShopItemForRentWhereInput
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    totalHours: number | null
    averageHoursPerLesson: number | null
  }

  export type ModuleSumAggregateOutputType = {
    totalHours: number | null
    averageHoursPerLesson: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    category: string | null
    totalHours: number | null
    averageHoursPerLesson: number | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    ownerId: string | null
    courseId: string | null
    publishStatus: $Enums.PublishStatusEnum | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    category: string | null
    totalHours: number | null
    averageHoursPerLesson: number | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    ownerId: string | null
    courseId: string | null
    publishStatus: $Enums.PublishStatusEnum | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    category: number
    totalHours: number
    averageHoursPerLesson: number
    createdAt: number
    updatedAt: number
    creatorId: number
    ownerId: number
    courseId: number
    publishStatus: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    totalHours?: true
    averageHoursPerLesson?: true
  }

  export type ModuleSumAggregateInputType = {
    totalHours?: true
    averageHoursPerLesson?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    category?: true
    totalHours?: true
    averageHoursPerLesson?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    ownerId?: true
    courseId?: true
    publishStatus?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    category?: true
    totalHours?: true
    averageHoursPerLesson?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    ownerId?: true
    courseId?: true
    publishStatus?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    category?: true
    totalHours?: true
    averageHoursPerLesson?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    ownerId?: true
    courseId?: true
    publishStatus?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: string
    slug: string
    name: string
    description: string | null
    category: string
    totalHours: number
    averageHoursPerLesson: number
    createdAt: Date
    updatedAt: Date
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus: $Enums.PublishStatusEnum
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    totalHours?: boolean
    averageHoursPerLesson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    courseId?: boolean
    publishStatus?: boolean
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    topics?: boolean | Module$topicsArgs<ExtArgs>
    materials?: boolean | Module$materialsArgs<ExtArgs>
    assignments?: boolean | Module$assignmentsArgs<ExtArgs>
    exams?: boolean | Module$examsArgs<ExtArgs>
    lessons?: boolean | Module$lessonsArgs<ExtArgs>
    events?: boolean | Module$eventsArgs<ExtArgs>
    comments?: boolean | Module$commentsArgs<ExtArgs>
    forSale?: boolean | Module$forSaleArgs<ExtArgs>
    forRent?: boolean | Module$forRentArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    totalHours?: boolean
    averageHoursPerLesson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    courseId?: boolean
    publishStatus?: boolean
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    totalHours?: boolean
    averageHoursPerLesson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    courseId?: boolean
    publishStatus?: boolean
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    totalHours?: boolean
    averageHoursPerLesson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    courseId?: boolean
    publishStatus?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "description" | "category" | "totalHours" | "averageHoursPerLesson" | "createdAt" | "updatedAt" | "creatorId" | "ownerId" | "courseId" | "publishStatus", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    topics?: boolean | Module$topicsArgs<ExtArgs>
    materials?: boolean | Module$materialsArgs<ExtArgs>
    assignments?: boolean | Module$assignmentsArgs<ExtArgs>
    exams?: boolean | Module$examsArgs<ExtArgs>
    lessons?: boolean | Module$lessonsArgs<ExtArgs>
    events?: boolean | Module$eventsArgs<ExtArgs>
    comments?: boolean | Module$commentsArgs<ExtArgs>
    forSale?: boolean | Module$forSaleArgs<ExtArgs>
    forRent?: boolean | Module$forRentArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      creator: Prisma.$TeacherPayload<ExtArgs>
      owner: Prisma.$TeacherPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      topics: Prisma.$TopicPayload<ExtArgs>[]
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      assignments: Prisma.$ModuleAssignmentPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      forSale: Prisma.$ShopItemForSalePayload<ExtArgs> | null
      forRent: Prisma.$ShopItemForRentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      description: string | null
      category: string
      totalHours: number
      averageHoursPerLesson: number
      createdAt: Date
      updatedAt: Date
      creatorId: string
      ownerId: string
      courseId: string
      publishStatus: $Enums.PublishStatusEnum
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules and returns the data updated in the database.
     * @param {ModuleUpdateManyAndReturnArgs} args - Arguments to update many Modules.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    owner<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    topics<T extends Module$topicsArgs<ExtArgs> = {}>(args?: Subset<T, Module$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    materials<T extends Module$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Module$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    assignments<T extends Module$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Module$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    exams<T extends Module$examsArgs<ExtArgs> = {}>(args?: Subset<T, Module$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    lessons<T extends Module$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Module$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    events<T extends Module$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Module$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends Module$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Module$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    forSale<T extends Module$forSaleArgs<ExtArgs> = {}>(args?: Subset<T, Module$forSaleArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    forRent<T extends Module$forRentArgs<ExtArgs> = {}>(args?: Subset<T, Module$forRentArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */ 
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly slug: FieldRef<"Module", 'String'>
    readonly name: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly category: FieldRef<"Module", 'String'>
    readonly totalHours: FieldRef<"Module", 'Int'>
    readonly averageHoursPerLesson: FieldRef<"Module", 'Float'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
    readonly creatorId: FieldRef<"Module", 'String'>
    readonly ownerId: FieldRef<"Module", 'String'>
    readonly courseId: FieldRef<"Module", 'String'>
    readonly publishStatus: FieldRef<"Module", 'PublishStatusEnum'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module updateManyAndReturn
   */
  export type ModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.topics
   */
  export type Module$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Module.materials
   */
  export type Module$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Module.assignments
   */
  export type Module$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    where?: ModuleAssignmentWhereInput
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    cursor?: ModuleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * Module.exams
   */
  export type Module$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Module.lessons
   */
  export type Module$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Module.events
   */
  export type Module$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Module.comments
   */
  export type Module$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Module.forSale
   */
  export type Module$forSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    where?: ShopItemForSaleWhereInput
  }

  /**
   * Module.forRent
   */
  export type Module$forRentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    where?: ShopItemForRentWhereInput
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type LessonSumAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    duration: number | null
    order: number | null
    moduleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    duration: number | null
    order: number | null
    moduleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    name: number
    description: number
    duration: number
    order: number
    moduleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    duration?: true
    order?: true
  }

  export type LessonSumAggregateInputType = {
    duration?: true
    order?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    order?: true
    moduleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    order?: true
    moduleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    order?: true
    moduleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    name: string
    description: string | null
    duration: number
    order: number
    moduleId: string
    createdAt: Date
    updatedAt: Date
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    order?: boolean
    moduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    schedules?: boolean | Lesson$schedulesArgs<ExtArgs>
    comments?: boolean | Lesson$commentsArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    order?: boolean
    moduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    order?: boolean
    moduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    order?: boolean
    moduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "duration" | "order" | "moduleId" | "createdAt" | "updatedAt", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    schedules?: boolean | Lesson$schedulesArgs<ExtArgs>
    comments?: boolean | Lesson$commentsArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      schedules: Prisma.$LessonSchedulePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      duration: number
      order: number
      moduleId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    schedules<T extends Lesson$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends Lesson$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */ 
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly name: FieldRef<"Lesson", 'String'>
    readonly description: FieldRef<"Lesson", 'String'>
    readonly duration: FieldRef<"Lesson", 'Float'>
    readonly order: FieldRef<"Lesson", 'Int'>
    readonly moduleId: FieldRef<"Lesson", 'String'>
    readonly createdAt: FieldRef<"Lesson", 'DateTime'>
    readonly updatedAt: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson.schedules
   */
  export type Lesson$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    where?: LessonScheduleWhereInput
    orderBy?: LessonScheduleOrderByWithRelationInput | LessonScheduleOrderByWithRelationInput[]
    cursor?: LessonScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScheduleScalarFieldEnum | LessonScheduleScalarFieldEnum[]
  }

  /**
   * Lesson.comments
   */
  export type Lesson$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicAvgAggregateOutputType = {
    order: number | null
  }

  export type TopicSumAggregateOutputType = {
    order: number | null
  }

  export type TopicMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    moduleId: string | null
  }

  export type TopicMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    moduleId: string | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    name: number
    description: number
    order: number
    moduleId: number
    _all: number
  }


  export type TopicAvgAggregateInputType = {
    order?: true
  }

  export type TopicSumAggregateInputType = {
    order?: true
  }

  export type TopicMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    moduleId?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    moduleId?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    moduleId?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _avg?: TopicAvgAggregateInputType
    _sum?: TopicSumAggregateInputType
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: string
    name: string
    description: string | null
    order: number
    moduleId: string
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    moduleId?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    materials?: boolean | Topic$materialsArgs<ExtArgs>
    exercises?: boolean | Topic$exercisesArgs<ExtArgs>
    objectives?: boolean | Topic$objectivesArgs<ExtArgs>
    comments?: boolean | Topic$commentsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    moduleId?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    moduleId?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    moduleId?: boolean
  }

  export type TopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "order" | "moduleId", ExtArgs["result"]["topic"]>
  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    materials?: boolean | Topic$materialsArgs<ExtArgs>
    exercises?: boolean | Topic$exercisesArgs<ExtArgs>
    objectives?: boolean | Topic$objectivesArgs<ExtArgs>
    comments?: boolean | Topic$commentsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type TopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
      objectives: Prisma.$ObjectivePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      order: number
      moduleId: string
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics and returns the data updated in the database.
     * @param {TopicUpdateManyAndReturnArgs} args - Arguments to update many Topics.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    materials<T extends Topic$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    exercises<T extends Topic$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, Topic$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    objectives<T extends Topic$objectivesArgs<ExtArgs> = {}>(args?: Subset<T, Topic$objectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends Topic$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */ 
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'String'>
    readonly name: FieldRef<"Topic", 'String'>
    readonly description: FieldRef<"Topic", 'String'>
    readonly order: FieldRef<"Topic", 'Int'>
    readonly moduleId: FieldRef<"Topic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topic updateManyAndReturn
   */
  export type TopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to delete.
     */
    limit?: number
  }

  /**
   * Topic.materials
   */
  export type Topic$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Topic.exercises
   */
  export type Topic$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Topic.objectives
   */
  export type Topic$objectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    where?: ObjectiveWhereInput
    orderBy?: ObjectiveOrderByWithRelationInput | ObjectiveOrderByWithRelationInput[]
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectiveScalarFieldEnum | ObjectiveScalarFieldEnum[]
  }

  /**
   * Topic.comments
   */
  export type Topic$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model Objective
   */

  export type AggregateObjective = {
    _count: ObjectiveCountAggregateOutputType | null
    _min: ObjectiveMinAggregateOutputType | null
    _max: ObjectiveMaxAggregateOutputType | null
  }

  export type ObjectiveMinAggregateOutputType = {
    id: string | null
    description: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ObjectiveMaxAggregateOutputType = {
    id: string | null
    description: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ObjectiveCountAggregateOutputType = {
    id: number
    description: number
    topicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ObjectiveMinAggregateInputType = {
    id?: true
    description?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ObjectiveMaxAggregateInputType = {
    id?: true
    description?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ObjectiveCountAggregateInputType = {
    id?: true
    description?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Objective to aggregate.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: ObjectiveOrderByWithRelationInput | ObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Objectives
    **/
    _count?: true | ObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectiveMaxAggregateInputType
  }

  export type GetObjectiveAggregateType<T extends ObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjective[P]>
      : GetScalarType<T[P], AggregateObjective[P]>
  }




  export type ObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectiveWhereInput
    orderBy?: ObjectiveOrderByWithAggregationInput | ObjectiveOrderByWithAggregationInput[]
    by: ObjectiveScalarFieldEnum[] | ObjectiveScalarFieldEnum
    having?: ObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectiveCountAggregateInputType | true
    _min?: ObjectiveMinAggregateInputType
    _max?: ObjectiveMaxAggregateInputType
  }

  export type ObjectiveGroupByOutputType = {
    id: string
    description: string
    topicId: string
    createdAt: Date
    updatedAt: Date
    _count: ObjectiveCountAggregateOutputType | null
    _min: ObjectiveMinAggregateOutputType | null
    _max: ObjectiveMaxAggregateOutputType | null
  }

  type GetObjectiveGroupByPayload<T extends ObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type ObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objective"]>

  export type ObjectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objective"]>

  export type ObjectiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objective"]>

  export type ObjectiveSelectScalar = {
    id?: boolean
    description?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ObjectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "topicId" | "createdAt" | "updatedAt", ExtArgs["result"]["objective"]>
  export type ObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type ObjectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type ObjectiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $ObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Objective"
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      topicId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["objective"]>
    composites: {}
  }

  type ObjectiveGetPayload<S extends boolean | null | undefined | ObjectiveDefaultArgs> = $Result.GetResult<Prisma.$ObjectivePayload, S>

  type ObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ObjectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ObjectiveCountAggregateInputType | true
    }

  export interface ObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Objective'], meta: { name: 'Objective' } }
    /**
     * Find zero or one Objective that matches the filter.
     * @param {ObjectiveFindUniqueArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObjectiveFindUniqueArgs>(args: SelectSubset<T, ObjectiveFindUniqueArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Objective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ObjectiveFindUniqueOrThrowArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, ObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Objective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindFirstArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObjectiveFindFirstArgs>(args?: SelectSubset<T, ObjectiveFindFirstArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Objective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindFirstOrThrowArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, ObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Objectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Objectives
     * const objectives = await prisma.objective.findMany()
     * 
     * // Get first 10 Objectives
     * const objectives = await prisma.objective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectiveWithIdOnly = await prisma.objective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObjectiveFindManyArgs>(args?: SelectSubset<T, ObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Objective.
     * @param {ObjectiveCreateArgs} args - Arguments to create a Objective.
     * @example
     * // Create one Objective
     * const Objective = await prisma.objective.create({
     *   data: {
     *     // ... data to create a Objective
     *   }
     * })
     * 
     */
    create<T extends ObjectiveCreateArgs>(args: SelectSubset<T, ObjectiveCreateArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Objectives.
     * @param {ObjectiveCreateManyArgs} args - Arguments to create many Objectives.
     * @example
     * // Create many Objectives
     * const objective = await prisma.objective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObjectiveCreateManyArgs>(args?: SelectSubset<T, ObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Objectives and returns the data saved in the database.
     * @param {ObjectiveCreateManyAndReturnArgs} args - Arguments to create many Objectives.
     * @example
     * // Create many Objectives
     * const objective = await prisma.objective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Objectives and only return the `id`
     * const objectiveWithIdOnly = await prisma.objective.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObjectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, ObjectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Objective.
     * @param {ObjectiveDeleteArgs} args - Arguments to delete one Objective.
     * @example
     * // Delete one Objective
     * const Objective = await prisma.objective.delete({
     *   where: {
     *     // ... filter to delete one Objective
     *   }
     * })
     * 
     */
    delete<T extends ObjectiveDeleteArgs>(args: SelectSubset<T, ObjectiveDeleteArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Objective.
     * @param {ObjectiveUpdateArgs} args - Arguments to update one Objective.
     * @example
     * // Update one Objective
     * const objective = await prisma.objective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObjectiveUpdateArgs>(args: SelectSubset<T, ObjectiveUpdateArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Objectives.
     * @param {ObjectiveDeleteManyArgs} args - Arguments to filter Objectives to delete.
     * @example
     * // Delete a few Objectives
     * const { count } = await prisma.objective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObjectiveDeleteManyArgs>(args?: SelectSubset<T, ObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Objectives
     * const objective = await prisma.objective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObjectiveUpdateManyArgs>(args: SelectSubset<T, ObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objectives and returns the data updated in the database.
     * @param {ObjectiveUpdateManyAndReturnArgs} args - Arguments to update many Objectives.
     * @example
     * // Update many Objectives
     * const objective = await prisma.objective.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Objectives and only return the `id`
     * const objectiveWithIdOnly = await prisma.objective.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ObjectiveUpdateManyAndReturnArgs>(args: SelectSubset<T, ObjectiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Objective.
     * @param {ObjectiveUpsertArgs} args - Arguments to update or create a Objective.
     * @example
     * // Update or create a Objective
     * const objective = await prisma.objective.upsert({
     *   create: {
     *     // ... data to create a Objective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Objective we want to update
     *   }
     * })
     */
    upsert<T extends ObjectiveUpsertArgs>(args: SelectSubset<T, ObjectiveUpsertArgs<ExtArgs>>): Prisma__ObjectiveClient<$Result.GetResult<Prisma.$ObjectivePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Objectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveCountArgs} args - Arguments to filter Objectives to count.
     * @example
     * // Count the number of Objectives
     * const count = await prisma.objective.count({
     *   where: {
     *     // ... the filter for the Objectives we want to count
     *   }
     * })
    **/
    count<T extends ObjectiveCountArgs>(
      args?: Subset<T, ObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Objective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectiveAggregateArgs>(args: Subset<T, ObjectiveAggregateArgs>): Prisma.PrismaPromise<GetObjectiveAggregateType<T>>

    /**
     * Group by Objective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: ObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Objective model
   */
  readonly fields: ObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Objective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Objective model
   */ 
  interface ObjectiveFieldRefs {
    readonly id: FieldRef<"Objective", 'String'>
    readonly description: FieldRef<"Objective", 'String'>
    readonly topicId: FieldRef<"Objective", 'String'>
    readonly createdAt: FieldRef<"Objective", 'DateTime'>
    readonly updatedAt: FieldRef<"Objective", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Objective findUnique
   */
  export type ObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which Objective to fetch.
     */
    where: ObjectiveWhereUniqueInput
  }

  /**
   * Objective findUniqueOrThrow
   */
  export type ObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which Objective to fetch.
     */
    where: ObjectiveWhereUniqueInput
  }

  /**
   * Objective findFirst
   */
  export type ObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which Objective to fetch.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: ObjectiveOrderByWithRelationInput | ObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objectives.
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objectives.
     */
    distinct?: ObjectiveScalarFieldEnum | ObjectiveScalarFieldEnum[]
  }

  /**
   * Objective findFirstOrThrow
   */
  export type ObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which Objective to fetch.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: ObjectiveOrderByWithRelationInput | ObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objectives.
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objectives.
     */
    distinct?: ObjectiveScalarFieldEnum | ObjectiveScalarFieldEnum[]
  }

  /**
   * Objective findMany
   */
  export type ObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which Objectives to fetch.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: ObjectiveOrderByWithRelationInput | ObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Objectives.
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    distinct?: ObjectiveScalarFieldEnum | ObjectiveScalarFieldEnum[]
  }

  /**
   * Objective create
   */
  export type ObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a Objective.
     */
    data: XOR<ObjectiveCreateInput, ObjectiveUncheckedCreateInput>
  }

  /**
   * Objective createMany
   */
  export type ObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Objectives.
     */
    data: ObjectiveCreateManyInput | ObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Objective createManyAndReturn
   */
  export type ObjectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * The data used to create many Objectives.
     */
    data: ObjectiveCreateManyInput | ObjectiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Objective update
   */
  export type ObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a Objective.
     */
    data: XOR<ObjectiveUpdateInput, ObjectiveUncheckedUpdateInput>
    /**
     * Choose, which Objective to update.
     */
    where: ObjectiveWhereUniqueInput
  }

  /**
   * Objective updateMany
   */
  export type ObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Objectives.
     */
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which Objectives to update
     */
    where?: ObjectiveWhereInput
    /**
     * Limit how many Objectives to update.
     */
    limit?: number
  }

  /**
   * Objective updateManyAndReturn
   */
  export type ObjectiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * The data used to update Objectives.
     */
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which Objectives to update
     */
    where?: ObjectiveWhereInput
    /**
     * Limit how many Objectives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Objective upsert
   */
  export type ObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the Objective to update in case it exists.
     */
    where: ObjectiveWhereUniqueInput
    /**
     * In case the Objective found by the `where` argument doesn't exist, create a new Objective with this data.
     */
    create: XOR<ObjectiveCreateInput, ObjectiveUncheckedCreateInput>
    /**
     * In case the Objective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectiveUpdateInput, ObjectiveUncheckedUpdateInput>
  }

  /**
   * Objective delete
   */
  export type ObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
    /**
     * Filter which Objective to delete.
     */
    where: ObjectiveWhereUniqueInput
  }

  /**
   * Objective deleteMany
   */
  export type ObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Objectives to delete
     */
    where?: ObjectiveWhereInput
    /**
     * Limit how many Objectives to delete.
     */
    limit?: number
  }

  /**
   * Objective without action
   */
  export type ObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Objective
     */
    omit?: ObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model ModuleAssignment
   */

  export type AggregateModuleAssignment = {
    _count: ModuleAssignmentCountAggregateOutputType | null
    _avg: ModuleAssignmentAvgAggregateOutputType | null
    _sum: ModuleAssignmentSumAggregateOutputType | null
    _min: ModuleAssignmentMinAggregateOutputType | null
    _max: ModuleAssignmentMaxAggregateOutputType | null
  }

  export type ModuleAssignmentAvgAggregateOutputType = {
    hourlyRate: number | null
  }

  export type ModuleAssignmentSumAggregateOutputType = {
    hourlyRate: number | null
  }

  export type ModuleAssignmentMinAggregateOutputType = {
    id: string | null
    moduleId: string | null
    teacherId: string | null
    courseId: string | null
    hourlyRate: number | null
    currency: $Enums.CurrencyTypeEnum | null
    startDate: Date | null
    endDate: Date | null
  }

  export type ModuleAssignmentMaxAggregateOutputType = {
    id: string | null
    moduleId: string | null
    teacherId: string | null
    courseId: string | null
    hourlyRate: number | null
    currency: $Enums.CurrencyTypeEnum | null
    startDate: Date | null
    endDate: Date | null
  }

  export type ModuleAssignmentCountAggregateOutputType = {
    id: number
    moduleId: number
    teacherId: number
    courseId: number
    hourlyRate: number
    currency: number
    startDate: number
    endDate: number
    _all: number
  }


  export type ModuleAssignmentAvgAggregateInputType = {
    hourlyRate?: true
  }

  export type ModuleAssignmentSumAggregateInputType = {
    hourlyRate?: true
  }

  export type ModuleAssignmentMinAggregateInputType = {
    id?: true
    moduleId?: true
    teacherId?: true
    courseId?: true
    hourlyRate?: true
    currency?: true
    startDate?: true
    endDate?: true
  }

  export type ModuleAssignmentMaxAggregateInputType = {
    id?: true
    moduleId?: true
    teacherId?: true
    courseId?: true
    hourlyRate?: true
    currency?: true
    startDate?: true
    endDate?: true
  }

  export type ModuleAssignmentCountAggregateInputType = {
    id?: true
    moduleId?: true
    teacherId?: true
    courseId?: true
    hourlyRate?: true
    currency?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type ModuleAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleAssignment to aggregate.
     */
    where?: ModuleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleAssignments to fetch.
     */
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleAssignments
    **/
    _count?: true | ModuleAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleAssignmentMaxAggregateInputType
  }

  export type GetModuleAssignmentAggregateType<T extends ModuleAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleAssignment[P]>
      : GetScalarType<T[P], AggregateModuleAssignment[P]>
  }




  export type ModuleAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleAssignmentWhereInput
    orderBy?: ModuleAssignmentOrderByWithAggregationInput | ModuleAssignmentOrderByWithAggregationInput[]
    by: ModuleAssignmentScalarFieldEnum[] | ModuleAssignmentScalarFieldEnum
    having?: ModuleAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleAssignmentCountAggregateInputType | true
    _avg?: ModuleAssignmentAvgAggregateInputType
    _sum?: ModuleAssignmentSumAggregateInputType
    _min?: ModuleAssignmentMinAggregateInputType
    _max?: ModuleAssignmentMaxAggregateInputType
  }

  export type ModuleAssignmentGroupByOutputType = {
    id: string
    moduleId: string
    teacherId: string
    courseId: string
    hourlyRate: number
    currency: $Enums.CurrencyTypeEnum
    startDate: Date
    endDate: Date
    _count: ModuleAssignmentCountAggregateOutputType | null
    _avg: ModuleAssignmentAvgAggregateOutputType | null
    _sum: ModuleAssignmentSumAggregateOutputType | null
    _min: ModuleAssignmentMinAggregateOutputType | null
    _max: ModuleAssignmentMaxAggregateOutputType | null
  }

  type GetModuleAssignmentGroupByPayload<T extends ModuleAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ModuleAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    teacherId?: boolean
    courseId?: boolean
    hourlyRate?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleAssignment"]>

  export type ModuleAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    teacherId?: boolean
    courseId?: boolean
    hourlyRate?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleAssignment"]>

  export type ModuleAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    teacherId?: boolean
    courseId?: boolean
    hourlyRate?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleAssignment"]>

  export type ModuleAssignmentSelectScalar = {
    id?: boolean
    moduleId?: boolean
    teacherId?: boolean
    courseId?: boolean
    hourlyRate?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type ModuleAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "moduleId" | "teacherId" | "courseId" | "hourlyRate" | "currency" | "startDate" | "endDate", ExtArgs["result"]["moduleAssignment"]>
  export type ModuleAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type ModuleAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type ModuleAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $ModuleAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleAssignment"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduleId: string
      teacherId: string
      courseId: string
      hourlyRate: number
      currency: $Enums.CurrencyTypeEnum
      startDate: Date
      endDate: Date
    }, ExtArgs["result"]["moduleAssignment"]>
    composites: {}
  }

  type ModuleAssignmentGetPayload<S extends boolean | null | undefined | ModuleAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ModuleAssignmentPayload, S>

  type ModuleAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleAssignmentCountAggregateInputType | true
    }

  export interface ModuleAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleAssignment'], meta: { name: 'ModuleAssignment' } }
    /**
     * Find zero or one ModuleAssignment that matches the filter.
     * @param {ModuleAssignmentFindUniqueArgs} args - Arguments to find a ModuleAssignment
     * @example
     * // Get one ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleAssignmentFindUniqueArgs>(args: SelectSubset<T, ModuleAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ModuleAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ModuleAssignment
     * @example
     * // Get one ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ModuleAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentFindFirstArgs} args - Arguments to find a ModuleAssignment
     * @example
     * // Get one ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleAssignmentFindFirstArgs>(args?: SelectSubset<T, ModuleAssignmentFindFirstArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ModuleAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentFindFirstOrThrowArgs} args - Arguments to find a ModuleAssignment
     * @example
     * // Get one ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ModuleAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleAssignments
     * const moduleAssignments = await prisma.moduleAssignment.findMany()
     * 
     * // Get first 10 ModuleAssignments
     * const moduleAssignments = await prisma.moduleAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleAssignmentWithIdOnly = await prisma.moduleAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleAssignmentFindManyArgs>(args?: SelectSubset<T, ModuleAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ModuleAssignment.
     * @param {ModuleAssignmentCreateArgs} args - Arguments to create a ModuleAssignment.
     * @example
     * // Create one ModuleAssignment
     * const ModuleAssignment = await prisma.moduleAssignment.create({
     *   data: {
     *     // ... data to create a ModuleAssignment
     *   }
     * })
     * 
     */
    create<T extends ModuleAssignmentCreateArgs>(args: SelectSubset<T, ModuleAssignmentCreateArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ModuleAssignments.
     * @param {ModuleAssignmentCreateManyArgs} args - Arguments to create many ModuleAssignments.
     * @example
     * // Create many ModuleAssignments
     * const moduleAssignment = await prisma.moduleAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleAssignmentCreateManyArgs>(args?: SelectSubset<T, ModuleAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleAssignments and returns the data saved in the database.
     * @param {ModuleAssignmentCreateManyAndReturnArgs} args - Arguments to create many ModuleAssignments.
     * @example
     * // Create many ModuleAssignments
     * const moduleAssignment = await prisma.moduleAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleAssignments and only return the `id`
     * const moduleAssignmentWithIdOnly = await prisma.moduleAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ModuleAssignment.
     * @param {ModuleAssignmentDeleteArgs} args - Arguments to delete one ModuleAssignment.
     * @example
     * // Delete one ModuleAssignment
     * const ModuleAssignment = await prisma.moduleAssignment.delete({
     *   where: {
     *     // ... filter to delete one ModuleAssignment
     *   }
     * })
     * 
     */
    delete<T extends ModuleAssignmentDeleteArgs>(args: SelectSubset<T, ModuleAssignmentDeleteArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ModuleAssignment.
     * @param {ModuleAssignmentUpdateArgs} args - Arguments to update one ModuleAssignment.
     * @example
     * // Update one ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleAssignmentUpdateArgs>(args: SelectSubset<T, ModuleAssignmentUpdateArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ModuleAssignments.
     * @param {ModuleAssignmentDeleteManyArgs} args - Arguments to filter ModuleAssignments to delete.
     * @example
     * // Delete a few ModuleAssignments
     * const { count } = await prisma.moduleAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleAssignmentDeleteManyArgs>(args?: SelectSubset<T, ModuleAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleAssignments
     * const moduleAssignment = await prisma.moduleAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleAssignmentUpdateManyArgs>(args: SelectSubset<T, ModuleAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleAssignments and returns the data updated in the database.
     * @param {ModuleAssignmentUpdateManyAndReturnArgs} args - Arguments to update many ModuleAssignments.
     * @example
     * // Update many ModuleAssignments
     * const moduleAssignment = await prisma.moduleAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleAssignments and only return the `id`
     * const moduleAssignmentWithIdOnly = await prisma.moduleAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ModuleAssignment.
     * @param {ModuleAssignmentUpsertArgs} args - Arguments to update or create a ModuleAssignment.
     * @example
     * // Update or create a ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.upsert({
     *   create: {
     *     // ... data to create a ModuleAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ModuleAssignmentUpsertArgs>(args: SelectSubset<T, ModuleAssignmentUpsertArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ModuleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentCountArgs} args - Arguments to filter ModuleAssignments to count.
     * @example
     * // Count the number of ModuleAssignments
     * const count = await prisma.moduleAssignment.count({
     *   where: {
     *     // ... the filter for the ModuleAssignments we want to count
     *   }
     * })
    **/
    count<T extends ModuleAssignmentCountArgs>(
      args?: Subset<T, ModuleAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAssignmentAggregateArgs>(args: Subset<T, ModuleAssignmentAggregateArgs>): Prisma.PrismaPromise<GetModuleAssignmentAggregateType<T>>

    /**
     * Group by ModuleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ModuleAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleAssignment model
   */
  readonly fields: ModuleAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleAssignment model
   */ 
  interface ModuleAssignmentFieldRefs {
    readonly id: FieldRef<"ModuleAssignment", 'String'>
    readonly moduleId: FieldRef<"ModuleAssignment", 'String'>
    readonly teacherId: FieldRef<"ModuleAssignment", 'String'>
    readonly courseId: FieldRef<"ModuleAssignment", 'String'>
    readonly hourlyRate: FieldRef<"ModuleAssignment", 'Int'>
    readonly currency: FieldRef<"ModuleAssignment", 'CurrencyTypeEnum'>
    readonly startDate: FieldRef<"ModuleAssignment", 'DateTime'>
    readonly endDate: FieldRef<"ModuleAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModuleAssignment findUnique
   */
  export type ModuleAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleAssignment to fetch.
     */
    where: ModuleAssignmentWhereUniqueInput
  }

  /**
   * ModuleAssignment findUniqueOrThrow
   */
  export type ModuleAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleAssignment to fetch.
     */
    where: ModuleAssignmentWhereUniqueInput
  }

  /**
   * ModuleAssignment findFirst
   */
  export type ModuleAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleAssignment to fetch.
     */
    where?: ModuleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleAssignments to fetch.
     */
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleAssignments.
     */
    cursor?: ModuleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleAssignments.
     */
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * ModuleAssignment findFirstOrThrow
   */
  export type ModuleAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleAssignment to fetch.
     */
    where?: ModuleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleAssignments to fetch.
     */
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleAssignments.
     */
    cursor?: ModuleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleAssignments.
     */
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * ModuleAssignment findMany
   */
  export type ModuleAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleAssignments to fetch.
     */
    where?: ModuleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleAssignments to fetch.
     */
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleAssignments.
     */
    cursor?: ModuleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleAssignments.
     */
    skip?: number
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * ModuleAssignment create
   */
  export type ModuleAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleAssignment.
     */
    data: XOR<ModuleAssignmentCreateInput, ModuleAssignmentUncheckedCreateInput>
  }

  /**
   * ModuleAssignment createMany
   */
  export type ModuleAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleAssignments.
     */
    data: ModuleAssignmentCreateManyInput | ModuleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleAssignment createManyAndReturn
   */
  export type ModuleAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleAssignments.
     */
    data: ModuleAssignmentCreateManyInput | ModuleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleAssignment update
   */
  export type ModuleAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleAssignment.
     */
    data: XOR<ModuleAssignmentUpdateInput, ModuleAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ModuleAssignment to update.
     */
    where: ModuleAssignmentWhereUniqueInput
  }

  /**
   * ModuleAssignment updateMany
   */
  export type ModuleAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleAssignments.
     */
    data: XOR<ModuleAssignmentUpdateManyMutationInput, ModuleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ModuleAssignments to update
     */
    where?: ModuleAssignmentWhereInput
    /**
     * Limit how many ModuleAssignments to update.
     */
    limit?: number
  }

  /**
   * ModuleAssignment updateManyAndReturn
   */
  export type ModuleAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update ModuleAssignments.
     */
    data: XOR<ModuleAssignmentUpdateManyMutationInput, ModuleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ModuleAssignments to update
     */
    where?: ModuleAssignmentWhereInput
    /**
     * Limit how many ModuleAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleAssignment upsert
   */
  export type ModuleAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleAssignment to update in case it exists.
     */
    where: ModuleAssignmentWhereUniqueInput
    /**
     * In case the ModuleAssignment found by the `where` argument doesn't exist, create a new ModuleAssignment with this data.
     */
    create: XOR<ModuleAssignmentCreateInput, ModuleAssignmentUncheckedCreateInput>
    /**
     * In case the ModuleAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleAssignmentUpdateInput, ModuleAssignmentUncheckedUpdateInput>
  }

  /**
   * ModuleAssignment delete
   */
  export type ModuleAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ModuleAssignment to delete.
     */
    where: ModuleAssignmentWhereUniqueInput
  }

  /**
   * ModuleAssignment deleteMany
   */
  export type ModuleAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleAssignments to delete
     */
    where?: ModuleAssignmentWhereInput
    /**
     * Limit how many ModuleAssignments to delete.
     */
    limit?: number
  }

  /**
   * ModuleAssignment without action
   */
  export type ModuleAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleAssignment
     */
    omit?: ModuleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    points: number | null
    timeLimit: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    points: number | null
    timeLimit: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    type: $Enums.ExerciseTypeEnum | null
    difficulty: $Enums.DifficultyLevelEnum | null
    points: number | null
    timeLimit: number | null
    topicId: string | null
    isTeamExercise: boolean | null
    creatorId: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    publishStatus: $Enums.PublishStatusEnum | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    type: $Enums.ExerciseTypeEnum | null
    difficulty: $Enums.DifficultyLevelEnum | null
    points: number | null
    timeLimit: number | null
    topicId: string | null
    isTeamExercise: boolean | null
    creatorId: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    publishStatus: $Enums.PublishStatusEnum | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    type: number
    difficulty: number
    points: number
    timeLimit: number
    topicId: number
    isTeamExercise: number
    creatorId: number
    ownerId: number
    createdAt: number
    updatedAt: number
    clientId: number
    publishStatus: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    points?: true
    timeLimit?: true
  }

  export type ExerciseSumAggregateInputType = {
    points?: true
    timeLimit?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    type?: true
    difficulty?: true
    points?: true
    timeLimit?: true
    topicId?: true
    isTeamExercise?: true
    creatorId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    publishStatus?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    type?: true
    difficulty?: true
    points?: true
    timeLimit?: true
    topicId?: true
    isTeamExercise?: true
    creatorId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    publishStatus?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    type?: true
    difficulty?: true
    points?: true
    timeLimit?: true
    topicId?: true
    isTeamExercise?: true
    creatorId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    publishStatus?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: string
    title: string
    description: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit: number | null
    topicId: string | null
    isTeamExercise: boolean
    creatorId: string
    ownerId: string
    createdAt: Date
    updatedAt: Date
    clientId: string | null
    publishStatus: $Enums.PublishStatusEnum
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    difficulty?: boolean
    points?: boolean
    timeLimit?: boolean
    topicId?: boolean
    isTeamExercise?: boolean
    creatorId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    publishStatus?: boolean
    topic?: boolean | Exercise$topicArgs<ExtArgs>
    examExercises?: boolean | Exercise$examExercisesArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    teams?: boolean | Exercise$teamsArgs<ExtArgs>
    client?: boolean | Exercise$clientArgs<ExtArgs>
    comments?: boolean | Exercise$commentsArgs<ExtArgs>
    forSale?: boolean | Exercise$forSaleArgs<ExtArgs>
    forRent?: boolean | Exercise$forRentArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    difficulty?: boolean
    points?: boolean
    timeLimit?: boolean
    topicId?: boolean
    isTeamExercise?: boolean
    creatorId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    publishStatus?: boolean
    topic?: boolean | Exercise$topicArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    client?: boolean | Exercise$clientArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    difficulty?: boolean
    points?: boolean
    timeLimit?: boolean
    topicId?: boolean
    isTeamExercise?: boolean
    creatorId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    publishStatus?: boolean
    topic?: boolean | Exercise$topicArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    client?: boolean | Exercise$clientArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    difficulty?: boolean
    points?: boolean
    timeLimit?: boolean
    topicId?: boolean
    isTeamExercise?: boolean
    creatorId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    publishStatus?: boolean
  }

  export type ExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "content" | "type" | "difficulty" | "points" | "timeLimit" | "topicId" | "isTeamExercise" | "creatorId" | "ownerId" | "createdAt" | "updatedAt" | "clientId" | "publishStatus", ExtArgs["result"]["exercise"]>
  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | Exercise$topicArgs<ExtArgs>
    examExercises?: boolean | Exercise$examExercisesArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    teams?: boolean | Exercise$teamsArgs<ExtArgs>
    client?: boolean | Exercise$clientArgs<ExtArgs>
    comments?: boolean | Exercise$commentsArgs<ExtArgs>
    forSale?: boolean | Exercise$forSaleArgs<ExtArgs>
    forRent?: boolean | Exercise$forRentArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | Exercise$topicArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    client?: boolean | Exercise$clientArgs<ExtArgs>
  }
  export type ExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | Exercise$topicArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    client?: boolean | Exercise$clientArgs<ExtArgs>
  }

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs> | null
      examExercises: Prisma.$ExamExercisePayload<ExtArgs>[]
      creator: Prisma.$TeacherPayload<ExtArgs>
      owner: Prisma.$TeacherPayload<ExtArgs>
      teams: Prisma.$TeamPayload<ExtArgs>[]
      client: Prisma.$ClientPayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      forSale: Prisma.$ShopItemForSalePayload<ExtArgs> | null
      forRent: Prisma.$ShopItemForRentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      content: string
      type: $Enums.ExerciseTypeEnum
      difficulty: $Enums.DifficultyLevelEnum
      points: number
      timeLimit: number | null
      topicId: string | null
      isTeamExercise: boolean
      creatorId: string
      ownerId: string
      createdAt: Date
      updatedAt: Date
      clientId: string | null
      publishStatus: $Enums.PublishStatusEnum
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises and returns the data updated in the database.
     * @param {ExerciseUpdateManyAndReturnArgs} args - Arguments to update many Exercises.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends Exercise$topicArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$topicArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    examExercises<T extends Exercise$examExercisesArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$examExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creator<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    owner<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    teams<T extends Exercise$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    client<T extends Exercise$clientArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    comments<T extends Exercise$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    forSale<T extends Exercise$forSaleArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$forSaleArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    forRent<T extends Exercise$forRentArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$forRentArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */ 
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'String'>
    readonly title: FieldRef<"Exercise", 'String'>
    readonly description: FieldRef<"Exercise", 'String'>
    readonly content: FieldRef<"Exercise", 'String'>
    readonly type: FieldRef<"Exercise", 'ExerciseTypeEnum'>
    readonly difficulty: FieldRef<"Exercise", 'DifficultyLevelEnum'>
    readonly points: FieldRef<"Exercise", 'Int'>
    readonly timeLimit: FieldRef<"Exercise", 'Int'>
    readonly topicId: FieldRef<"Exercise", 'String'>
    readonly isTeamExercise: FieldRef<"Exercise", 'Boolean'>
    readonly creatorId: FieldRef<"Exercise", 'String'>
    readonly ownerId: FieldRef<"Exercise", 'String'>
    readonly createdAt: FieldRef<"Exercise", 'DateTime'>
    readonly updatedAt: FieldRef<"Exercise", 'DateTime'>
    readonly clientId: FieldRef<"Exercise", 'String'>
    readonly publishStatus: FieldRef<"Exercise", 'PublishStatusEnum'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
  }

  /**
   * Exercise updateManyAndReturn
   */
  export type ExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to delete.
     */
    limit?: number
  }

  /**
   * Exercise.topic
   */
  export type Exercise$topicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
  }

  /**
   * Exercise.examExercises
   */
  export type Exercise$examExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    where?: ExamExerciseWhereInput
    orderBy?: ExamExerciseOrderByWithRelationInput | ExamExerciseOrderByWithRelationInput[]
    cursor?: ExamExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamExerciseScalarFieldEnum | ExamExerciseScalarFieldEnum[]
  }

  /**
   * Exercise.teams
   */
  export type Exercise$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Exercise.client
   */
  export type Exercise$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Exercise.comments
   */
  export type Exercise$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Exercise.forSale
   */
  export type Exercise$forSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    where?: ShopItemForSaleWhereInput
  }

  /**
   * Exercise.forRent
   */
  export type Exercise$forRentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    where?: ShopItemForRentWhereInput
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    duration: number | null
    maxScore: number | null
  }

  export type ExamSumAggregateOutputType = {
    duration: number | null
    maxScore: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.ExamTypeEnum | null
    moduleId: string | null
    date: Date | null
    duration: number | null
    maxScore: number | null
    creatorId: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishStatus: $Enums.PublishStatusEnum | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.ExamTypeEnum | null
    moduleId: string | null
    date: Date | null
    duration: number | null
    maxScore: number | null
    creatorId: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishStatus: $Enums.PublishStatusEnum | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    moduleId: number
    date: number
    duration: number
    maxScore: number
    creatorId: number
    ownerId: number
    createdAt: number
    updatedAt: number
    publishStatus: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    duration?: true
    maxScore?: true
  }

  export type ExamSumAggregateInputType = {
    duration?: true
    maxScore?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    moduleId?: true
    date?: true
    duration?: true
    maxScore?: true
    creatorId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    publishStatus?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    moduleId?: true
    date?: true
    duration?: true
    maxScore?: true
    creatorId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    publishStatus?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    moduleId?: true
    date?: true
    duration?: true
    maxScore?: true
    creatorId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    publishStatus?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date
    duration: number
    maxScore: number
    creatorId: string
    ownerId: string
    createdAt: Date
    updatedAt: Date
    publishStatus: $Enums.PublishStatusEnum
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    moduleId?: boolean
    date?: boolean
    duration?: boolean
    maxScore?: boolean
    creatorId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishStatus?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    exercises?: boolean | Exam$exercisesArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    comments?: boolean | Exam$commentsArgs<ExtArgs>
    forSale?: boolean | Exam$forSaleArgs<ExtArgs>
    forRent?: boolean | Exam$forRentArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    moduleId?: boolean
    date?: boolean
    duration?: boolean
    maxScore?: boolean
    creatorId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishStatus?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    moduleId?: boolean
    date?: boolean
    duration?: boolean
    maxScore?: boolean
    creatorId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishStatus?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    moduleId?: boolean
    date?: boolean
    duration?: boolean
    maxScore?: boolean
    creatorId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishStatus?: boolean
  }

  export type ExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "moduleId" | "date" | "duration" | "maxScore" | "creatorId" | "ownerId" | "createdAt" | "updatedAt" | "publishStatus", ExtArgs["result"]["exam"]>
  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    exercises?: boolean | Exam$exercisesArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    comments?: boolean | Exam$commentsArgs<ExtArgs>
    forSale?: boolean | Exam$forSaleArgs<ExtArgs>
    forRent?: boolean | Exam$forRentArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type ExamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      exercises: Prisma.$ExamExercisePayload<ExtArgs>[]
      creator: Prisma.$TeacherPayload<ExtArgs>
      owner: Prisma.$TeacherPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      forSale: Prisma.$ShopItemForSalePayload<ExtArgs> | null
      forRent: Prisma.$ShopItemForRentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.ExamTypeEnum
      moduleId: string
      date: Date
      duration: number
      maxScore: number
      creatorId: string
      ownerId: string
      createdAt: Date
      updatedAt: Date
      publishStatus: $Enums.PublishStatusEnum
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {ExamUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    exercises<T extends Exam$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, Exam$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creator<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    owner<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    comments<T extends Exam$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    forSale<T extends Exam$forSaleArgs<ExtArgs> = {}>(args?: Subset<T, Exam$forSaleArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    forRent<T extends Exam$forRentArgs<ExtArgs> = {}>(args?: Subset<T, Exam$forRentArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */ 
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly name: FieldRef<"Exam", 'String'>
    readonly description: FieldRef<"Exam", 'String'>
    readonly type: FieldRef<"Exam", 'ExamTypeEnum'>
    readonly moduleId: FieldRef<"Exam", 'String'>
    readonly date: FieldRef<"Exam", 'DateTime'>
    readonly duration: FieldRef<"Exam", 'Int'>
    readonly maxScore: FieldRef<"Exam", 'Float'>
    readonly creatorId: FieldRef<"Exam", 'String'>
    readonly ownerId: FieldRef<"Exam", 'String'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
    readonly publishStatus: FieldRef<"Exam", 'PublishStatusEnum'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam updateManyAndReturn
   */
  export type ExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to delete.
     */
    limit?: number
  }

  /**
   * Exam.exercises
   */
  export type Exam$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    where?: ExamExerciseWhereInput
    orderBy?: ExamExerciseOrderByWithRelationInput | ExamExerciseOrderByWithRelationInput[]
    cursor?: ExamExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamExerciseScalarFieldEnum | ExamExerciseScalarFieldEnum[]
  }

  /**
   * Exam.comments
   */
  export type Exam$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Exam.forSale
   */
  export type Exam$forSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    where?: ShopItemForSaleWhereInput
  }

  /**
   * Exam.forRent
   */
  export type Exam$forRentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    where?: ShopItemForRentWhereInput
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model ExamExercise
   */

  export type AggregateExamExercise = {
    _count: ExamExerciseCountAggregateOutputType | null
    _avg: ExamExerciseAvgAggregateOutputType | null
    _sum: ExamExerciseSumAggregateOutputType | null
    _min: ExamExerciseMinAggregateOutputType | null
    _max: ExamExerciseMaxAggregateOutputType | null
  }

  export type ExamExerciseAvgAggregateOutputType = {
    order: number | null
  }

  export type ExamExerciseSumAggregateOutputType = {
    order: number | null
  }

  export type ExamExerciseMinAggregateOutputType = {
    examId: string | null
    exerciseId: string | null
    order: number | null
  }

  export type ExamExerciseMaxAggregateOutputType = {
    examId: string | null
    exerciseId: string | null
    order: number | null
  }

  export type ExamExerciseCountAggregateOutputType = {
    examId: number
    exerciseId: number
    order: number
    _all: number
  }


  export type ExamExerciseAvgAggregateInputType = {
    order?: true
  }

  export type ExamExerciseSumAggregateInputType = {
    order?: true
  }

  export type ExamExerciseMinAggregateInputType = {
    examId?: true
    exerciseId?: true
    order?: true
  }

  export type ExamExerciseMaxAggregateInputType = {
    examId?: true
    exerciseId?: true
    order?: true
  }

  export type ExamExerciseCountAggregateInputType = {
    examId?: true
    exerciseId?: true
    order?: true
    _all?: true
  }

  export type ExamExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamExercise to aggregate.
     */
    where?: ExamExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamExercises to fetch.
     */
    orderBy?: ExamExerciseOrderByWithRelationInput | ExamExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamExercises
    **/
    _count?: true | ExamExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamExerciseMaxAggregateInputType
  }

  export type GetExamExerciseAggregateType<T extends ExamExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExamExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamExercise[P]>
      : GetScalarType<T[P], AggregateExamExercise[P]>
  }




  export type ExamExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamExerciseWhereInput
    orderBy?: ExamExerciseOrderByWithAggregationInput | ExamExerciseOrderByWithAggregationInput[]
    by: ExamExerciseScalarFieldEnum[] | ExamExerciseScalarFieldEnum
    having?: ExamExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamExerciseCountAggregateInputType | true
    _avg?: ExamExerciseAvgAggregateInputType
    _sum?: ExamExerciseSumAggregateInputType
    _min?: ExamExerciseMinAggregateInputType
    _max?: ExamExerciseMaxAggregateInputType
  }

  export type ExamExerciseGroupByOutputType = {
    examId: string
    exerciseId: string
    order: number
    _count: ExamExerciseCountAggregateOutputType | null
    _avg: ExamExerciseAvgAggregateOutputType | null
    _sum: ExamExerciseSumAggregateOutputType | null
    _min: ExamExerciseMinAggregateOutputType | null
    _max: ExamExerciseMaxAggregateOutputType | null
  }

  type GetExamExerciseGroupByPayload<T extends ExamExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExamExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExamExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    examId?: boolean
    exerciseId?: boolean
    order?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examExercise"]>

  export type ExamExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    examId?: boolean
    exerciseId?: boolean
    order?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examExercise"]>

  export type ExamExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    examId?: boolean
    exerciseId?: boolean
    order?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examExercise"]>

  export type ExamExerciseSelectScalar = {
    examId?: boolean
    exerciseId?: boolean
    order?: boolean
  }

  export type ExamExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"examId" | "exerciseId" | "order", ExtArgs["result"]["examExercise"]>
  export type ExamExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type ExamExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type ExamExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $ExamExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamExercise"
    objects: {
      exam: Prisma.$ExamPayload<ExtArgs>
      exercise: Prisma.$ExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      examId: string
      exerciseId: string
      order: number
    }, ExtArgs["result"]["examExercise"]>
    composites: {}
  }

  type ExamExerciseGetPayload<S extends boolean | null | undefined | ExamExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExamExercisePayload, S>

  type ExamExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamExerciseCountAggregateInputType | true
    }

  export interface ExamExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamExercise'], meta: { name: 'ExamExercise' } }
    /**
     * Find zero or one ExamExercise that matches the filter.
     * @param {ExamExerciseFindUniqueArgs} args - Arguments to find a ExamExercise
     * @example
     * // Get one ExamExercise
     * const examExercise = await prisma.examExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamExerciseFindUniqueArgs>(args: SelectSubset<T, ExamExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExamExerciseClient<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ExamExercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamExerciseFindUniqueOrThrowArgs} args - Arguments to find a ExamExercise
     * @example
     * // Get one ExamExercise
     * const examExercise = await prisma.examExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamExerciseClient<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ExamExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamExerciseFindFirstArgs} args - Arguments to find a ExamExercise
     * @example
     * // Get one ExamExercise
     * const examExercise = await prisma.examExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamExerciseFindFirstArgs>(args?: SelectSubset<T, ExamExerciseFindFirstArgs<ExtArgs>>): Prisma__ExamExerciseClient<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ExamExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamExerciseFindFirstOrThrowArgs} args - Arguments to find a ExamExercise
     * @example
     * // Get one ExamExercise
     * const examExercise = await prisma.examExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamExerciseClient<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ExamExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamExercises
     * const examExercises = await prisma.examExercise.findMany()
     * 
     * // Get first 10 ExamExercises
     * const examExercises = await prisma.examExercise.findMany({ take: 10 })
     * 
     * // Only select the `examId`
     * const examExerciseWithExamIdOnly = await prisma.examExercise.findMany({ select: { examId: true } })
     * 
     */
    findMany<T extends ExamExerciseFindManyArgs>(args?: SelectSubset<T, ExamExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ExamExercise.
     * @param {ExamExerciseCreateArgs} args - Arguments to create a ExamExercise.
     * @example
     * // Create one ExamExercise
     * const ExamExercise = await prisma.examExercise.create({
     *   data: {
     *     // ... data to create a ExamExercise
     *   }
     * })
     * 
     */
    create<T extends ExamExerciseCreateArgs>(args: SelectSubset<T, ExamExerciseCreateArgs<ExtArgs>>): Prisma__ExamExerciseClient<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ExamExercises.
     * @param {ExamExerciseCreateManyArgs} args - Arguments to create many ExamExercises.
     * @example
     * // Create many ExamExercises
     * const examExercise = await prisma.examExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamExerciseCreateManyArgs>(args?: SelectSubset<T, ExamExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamExercises and returns the data saved in the database.
     * @param {ExamExerciseCreateManyAndReturnArgs} args - Arguments to create many ExamExercises.
     * @example
     * // Create many ExamExercises
     * const examExercise = await prisma.examExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamExercises and only return the `examId`
     * const examExerciseWithExamIdOnly = await prisma.examExercise.createManyAndReturn({
     *   select: { examId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ExamExercise.
     * @param {ExamExerciseDeleteArgs} args - Arguments to delete one ExamExercise.
     * @example
     * // Delete one ExamExercise
     * const ExamExercise = await prisma.examExercise.delete({
     *   where: {
     *     // ... filter to delete one ExamExercise
     *   }
     * })
     * 
     */
    delete<T extends ExamExerciseDeleteArgs>(args: SelectSubset<T, ExamExerciseDeleteArgs<ExtArgs>>): Prisma__ExamExerciseClient<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ExamExercise.
     * @param {ExamExerciseUpdateArgs} args - Arguments to update one ExamExercise.
     * @example
     * // Update one ExamExercise
     * const examExercise = await prisma.examExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamExerciseUpdateArgs>(args: SelectSubset<T, ExamExerciseUpdateArgs<ExtArgs>>): Prisma__ExamExerciseClient<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ExamExercises.
     * @param {ExamExerciseDeleteManyArgs} args - Arguments to filter ExamExercises to delete.
     * @example
     * // Delete a few ExamExercises
     * const { count } = await prisma.examExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamExerciseDeleteManyArgs>(args?: SelectSubset<T, ExamExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamExercises
     * const examExercise = await prisma.examExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamExerciseUpdateManyArgs>(args: SelectSubset<T, ExamExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamExercises and returns the data updated in the database.
     * @param {ExamExerciseUpdateManyAndReturnArgs} args - Arguments to update many ExamExercises.
     * @example
     * // Update many ExamExercises
     * const examExercise = await prisma.examExercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamExercises and only return the `examId`
     * const examExerciseWithExamIdOnly = await prisma.examExercise.updateManyAndReturn({
     *   select: { examId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ExamExercise.
     * @param {ExamExerciseUpsertArgs} args - Arguments to update or create a ExamExercise.
     * @example
     * // Update or create a ExamExercise
     * const examExercise = await prisma.examExercise.upsert({
     *   create: {
     *     // ... data to create a ExamExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamExercise we want to update
     *   }
     * })
     */
    upsert<T extends ExamExerciseUpsertArgs>(args: SelectSubset<T, ExamExerciseUpsertArgs<ExtArgs>>): Prisma__ExamExerciseClient<$Result.GetResult<Prisma.$ExamExercisePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ExamExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamExerciseCountArgs} args - Arguments to filter ExamExercises to count.
     * @example
     * // Count the number of ExamExercises
     * const count = await prisma.examExercise.count({
     *   where: {
     *     // ... the filter for the ExamExercises we want to count
     *   }
     * })
    **/
    count<T extends ExamExerciseCountArgs>(
      args?: Subset<T, ExamExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamExerciseAggregateArgs>(args: Subset<T, ExamExerciseAggregateArgs>): Prisma.PrismaPromise<GetExamExerciseAggregateType<T>>

    /**
     * Group by ExamExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExamExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamExercise model
   */
  readonly fields: ExamExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamExercise model
   */ 
  interface ExamExerciseFieldRefs {
    readonly examId: FieldRef<"ExamExercise", 'String'>
    readonly exerciseId: FieldRef<"ExamExercise", 'String'>
    readonly order: FieldRef<"ExamExercise", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ExamExercise findUnique
   */
  export type ExamExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    /**
     * Filter, which ExamExercise to fetch.
     */
    where: ExamExerciseWhereUniqueInput
  }

  /**
   * ExamExercise findUniqueOrThrow
   */
  export type ExamExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    /**
     * Filter, which ExamExercise to fetch.
     */
    where: ExamExerciseWhereUniqueInput
  }

  /**
   * ExamExercise findFirst
   */
  export type ExamExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    /**
     * Filter, which ExamExercise to fetch.
     */
    where?: ExamExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamExercises to fetch.
     */
    orderBy?: ExamExerciseOrderByWithRelationInput | ExamExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamExercises.
     */
    cursor?: ExamExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamExercises.
     */
    distinct?: ExamExerciseScalarFieldEnum | ExamExerciseScalarFieldEnum[]
  }

  /**
   * ExamExercise findFirstOrThrow
   */
  export type ExamExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    /**
     * Filter, which ExamExercise to fetch.
     */
    where?: ExamExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamExercises to fetch.
     */
    orderBy?: ExamExerciseOrderByWithRelationInput | ExamExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamExercises.
     */
    cursor?: ExamExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamExercises.
     */
    distinct?: ExamExerciseScalarFieldEnum | ExamExerciseScalarFieldEnum[]
  }

  /**
   * ExamExercise findMany
   */
  export type ExamExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    /**
     * Filter, which ExamExercises to fetch.
     */
    where?: ExamExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamExercises to fetch.
     */
    orderBy?: ExamExerciseOrderByWithRelationInput | ExamExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamExercises.
     */
    cursor?: ExamExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamExercises.
     */
    skip?: number
    distinct?: ExamExerciseScalarFieldEnum | ExamExerciseScalarFieldEnum[]
  }

  /**
   * ExamExercise create
   */
  export type ExamExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamExercise.
     */
    data: XOR<ExamExerciseCreateInput, ExamExerciseUncheckedCreateInput>
  }

  /**
   * ExamExercise createMany
   */
  export type ExamExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamExercises.
     */
    data: ExamExerciseCreateManyInput | ExamExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamExercise createManyAndReturn
   */
  export type ExamExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many ExamExercises.
     */
    data: ExamExerciseCreateManyInput | ExamExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamExercise update
   */
  export type ExamExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamExercise.
     */
    data: XOR<ExamExerciseUpdateInput, ExamExerciseUncheckedUpdateInput>
    /**
     * Choose, which ExamExercise to update.
     */
    where: ExamExerciseWhereUniqueInput
  }

  /**
   * ExamExercise updateMany
   */
  export type ExamExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamExercises.
     */
    data: XOR<ExamExerciseUpdateManyMutationInput, ExamExerciseUncheckedUpdateManyInput>
    /**
     * Filter which ExamExercises to update
     */
    where?: ExamExerciseWhereInput
    /**
     * Limit how many ExamExercises to update.
     */
    limit?: number
  }

  /**
   * ExamExercise updateManyAndReturn
   */
  export type ExamExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * The data used to update ExamExercises.
     */
    data: XOR<ExamExerciseUpdateManyMutationInput, ExamExerciseUncheckedUpdateManyInput>
    /**
     * Filter which ExamExercises to update
     */
    where?: ExamExerciseWhereInput
    /**
     * Limit how many ExamExercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamExercise upsert
   */
  export type ExamExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamExercise to update in case it exists.
     */
    where: ExamExerciseWhereUniqueInput
    /**
     * In case the ExamExercise found by the `where` argument doesn't exist, create a new ExamExercise with this data.
     */
    create: XOR<ExamExerciseCreateInput, ExamExerciseUncheckedCreateInput>
    /**
     * In case the ExamExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamExerciseUpdateInput, ExamExerciseUncheckedUpdateInput>
  }

  /**
   * ExamExercise delete
   */
  export type ExamExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
    /**
     * Filter which ExamExercise to delete.
     */
    where: ExamExerciseWhereUniqueInput
  }

  /**
   * ExamExercise deleteMany
   */
  export type ExamExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamExercises to delete
     */
    where?: ExamExerciseWhereInput
    /**
     * Limit how many ExamExercises to delete.
     */
    limit?: number
  }

  /**
   * ExamExercise without action
   */
  export type ExamExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamExercise
     */
    select?: ExamExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamExercise
     */
    omit?: ExamExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamExerciseInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    url: string | null
    type: $Enums.MaterialType | null
    courseId: string | null
    moduleId: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    ownerId: string | null
    publishStatus: $Enums.PublishStatusEnum | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    url: string | null
    type: $Enums.MaterialType | null
    courseId: string | null
    moduleId: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    ownerId: string | null
    publishStatus: $Enums.PublishStatusEnum | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    name: number
    description: number
    url: number
    type: number
    courseId: number
    moduleId: number
    topicId: number
    createdAt: number
    updatedAt: number
    creatorId: number
    ownerId: number
    publishStatus: number
    _all: number
  }


  export type MaterialMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    type?: true
    courseId?: true
    moduleId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    ownerId?: true
    publishStatus?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    type?: true
    courseId?: true
    moduleId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    ownerId?: true
    publishStatus?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    type?: true
    courseId?: true
    moduleId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    ownerId?: true
    publishStatus?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: string
    name: string
    description: string | null
    url: string | null
    type: $Enums.MaterialType
    courseId: string | null
    moduleId: string | null
    topicId: string | null
    createdAt: Date
    updatedAt: Date
    creatorId: string
    ownerId: string
    publishStatus: $Enums.PublishStatusEnum
    _count: MaterialCountAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    courseId?: boolean
    moduleId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    publishStatus?: boolean
    course?: boolean | Material$courseArgs<ExtArgs>
    module?: boolean | Material$moduleArgs<ExtArgs>
    topic?: boolean | Material$topicArgs<ExtArgs>
    comments?: boolean | Material$commentsArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    forSale?: boolean | Material$forSaleArgs<ExtArgs>
    forRent?: boolean | Material$forRentArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    courseId?: boolean
    moduleId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    publishStatus?: boolean
    course?: boolean | Material$courseArgs<ExtArgs>
    module?: boolean | Material$moduleArgs<ExtArgs>
    topic?: boolean | Material$topicArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    courseId?: boolean
    moduleId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    publishStatus?: boolean
    course?: boolean | Material$courseArgs<ExtArgs>
    module?: boolean | Material$moduleArgs<ExtArgs>
    topic?: boolean | Material$topicArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    courseId?: boolean
    moduleId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    ownerId?: boolean
    publishStatus?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "url" | "type" | "courseId" | "moduleId" | "topicId" | "createdAt" | "updatedAt" | "creatorId" | "ownerId" | "publishStatus", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Material$courseArgs<ExtArgs>
    module?: boolean | Material$moduleArgs<ExtArgs>
    topic?: boolean | Material$topicArgs<ExtArgs>
    comments?: boolean | Material$commentsArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
    forSale?: boolean | Material$forSaleArgs<ExtArgs>
    forRent?: boolean | Material$forRentArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Material$courseArgs<ExtArgs>
    module?: boolean | Material$moduleArgs<ExtArgs>
    topic?: boolean | Material$topicArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Material$courseArgs<ExtArgs>
    module?: boolean | Material$moduleArgs<ExtArgs>
    topic?: boolean | Material$topicArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    owner?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      module: Prisma.$ModulePayload<ExtArgs> | null
      topic: Prisma.$TopicPayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      creator: Prisma.$TeacherPayload<ExtArgs>
      owner: Prisma.$TeacherPayload<ExtArgs>
      forSale: Prisma.$ShopItemForSalePayload<ExtArgs> | null
      forRent: Prisma.$ShopItemForRentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      url: string | null
      type: $Enums.MaterialType
      courseId: string | null
      moduleId: string | null
      topicId: string | null
      createdAt: Date
      updatedAt: Date
      creatorId: string
      ownerId: string
      publishStatus: $Enums.PublishStatusEnum
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends Material$courseArgs<ExtArgs> = {}>(args?: Subset<T, Material$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    module<T extends Material$moduleArgs<ExtArgs> = {}>(args?: Subset<T, Material$moduleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    topic<T extends Material$topicArgs<ExtArgs> = {}>(args?: Subset<T, Material$topicArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    comments<T extends Material$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Material$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creator<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    owner<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    forSale<T extends Material$forSaleArgs<ExtArgs> = {}>(args?: Subset<T, Material$forSaleArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    forRent<T extends Material$forRentArgs<ExtArgs> = {}>(args?: Subset<T, Material$forRentArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */ 
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'String'>
    readonly name: FieldRef<"Material", 'String'>
    readonly description: FieldRef<"Material", 'String'>
    readonly url: FieldRef<"Material", 'String'>
    readonly type: FieldRef<"Material", 'MaterialType'>
    readonly courseId: FieldRef<"Material", 'String'>
    readonly moduleId: FieldRef<"Material", 'String'>
    readonly topicId: FieldRef<"Material", 'String'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
    readonly updatedAt: FieldRef<"Material", 'DateTime'>
    readonly creatorId: FieldRef<"Material", 'String'>
    readonly ownerId: FieldRef<"Material", 'String'>
    readonly publishStatus: FieldRef<"Material", 'PublishStatusEnum'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material.course
   */
  export type Material$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Material.module
   */
  export type Material$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * Material.topic
   */
  export type Material$topicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
  }

  /**
   * Material.comments
   */
  export type Material$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Material.forSale
   */
  export type Material$forSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    where?: ShopItemForSaleWhereInput
  }

  /**
   * Material.forRent
   */
  export type Material$forRentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    where?: ShopItemForRentWhereInput
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    userId: string | null
    courseId: string | null
    moduleId: string | null
    topicId: string | null
    materialId: string | null
    enrollmentId: string | null
    classId: string | null
    teamId: string | null
    eventId: string | null
    lessonId: string | null
    examId: string | null
    exerciseId: string | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    userId: string | null
    courseId: string | null
    moduleId: string | null
    topicId: string | null
    materialId: string | null
    enrollmentId: string | null
    classId: string | null
    teamId: string | null
    eventId: string | null
    lessonId: string | null
    examId: string | null
    exerciseId: string | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    userId: number
    courseId: number
    moduleId: number
    topicId: number
    materialId: number
    enrollmentId: number
    classId: number
    teamId: number
    eventId: number
    lessonId: number
    examId: number
    exerciseId: number
    studentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    courseId?: true
    moduleId?: true
    topicId?: true
    materialId?: true
    enrollmentId?: true
    classId?: true
    teamId?: true
    eventId?: true
    lessonId?: true
    examId?: true
    exerciseId?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    courseId?: true
    moduleId?: true
    topicId?: true
    materialId?: true
    enrollmentId?: true
    classId?: true
    teamId?: true
    eventId?: true
    lessonId?: true
    examId?: true
    exerciseId?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    courseId?: true
    moduleId?: true
    topicId?: true
    materialId?: true
    enrollmentId?: true
    classId?: true
    teamId?: true
    eventId?: true
    lessonId?: true
    examId?: true
    exerciseId?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    userId: string
    courseId: string | null
    moduleId: string | null
    topicId: string | null
    materialId: string | null
    enrollmentId: string | null
    classId: string | null
    teamId: string | null
    eventId: string | null
    lessonId: string | null
    examId: string | null
    exerciseId: string | null
    studentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    courseId?: boolean
    moduleId?: boolean
    topicId?: boolean
    materialId?: boolean
    enrollmentId?: boolean
    classId?: boolean
    teamId?: boolean
    eventId?: boolean
    lessonId?: boolean
    examId?: boolean
    exerciseId?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Comment$courseArgs<ExtArgs>
    module?: boolean | Comment$moduleArgs<ExtArgs>
    topic?: boolean | Comment$topicArgs<ExtArgs>
    material?: boolean | Comment$materialArgs<ExtArgs>
    enrollment?: boolean | Comment$enrollmentArgs<ExtArgs>
    class?: boolean | Comment$classArgs<ExtArgs>
    team?: boolean | Comment$teamArgs<ExtArgs>
    event?: boolean | Comment$eventArgs<ExtArgs>
    lesson?: boolean | Comment$lessonArgs<ExtArgs>
    exam?: boolean | Comment$examArgs<ExtArgs>
    exercise?: boolean | Comment$exerciseArgs<ExtArgs>
    student?: boolean | Comment$studentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    courseId?: boolean
    moduleId?: boolean
    topicId?: boolean
    materialId?: boolean
    enrollmentId?: boolean
    classId?: boolean
    teamId?: boolean
    eventId?: boolean
    lessonId?: boolean
    examId?: boolean
    exerciseId?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Comment$courseArgs<ExtArgs>
    module?: boolean | Comment$moduleArgs<ExtArgs>
    topic?: boolean | Comment$topicArgs<ExtArgs>
    material?: boolean | Comment$materialArgs<ExtArgs>
    enrollment?: boolean | Comment$enrollmentArgs<ExtArgs>
    class?: boolean | Comment$classArgs<ExtArgs>
    team?: boolean | Comment$teamArgs<ExtArgs>
    event?: boolean | Comment$eventArgs<ExtArgs>
    lesson?: boolean | Comment$lessonArgs<ExtArgs>
    exam?: boolean | Comment$examArgs<ExtArgs>
    exercise?: boolean | Comment$exerciseArgs<ExtArgs>
    student?: boolean | Comment$studentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    courseId?: boolean
    moduleId?: boolean
    topicId?: boolean
    materialId?: boolean
    enrollmentId?: boolean
    classId?: boolean
    teamId?: boolean
    eventId?: boolean
    lessonId?: boolean
    examId?: boolean
    exerciseId?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Comment$courseArgs<ExtArgs>
    module?: boolean | Comment$moduleArgs<ExtArgs>
    topic?: boolean | Comment$topicArgs<ExtArgs>
    material?: boolean | Comment$materialArgs<ExtArgs>
    enrollment?: boolean | Comment$enrollmentArgs<ExtArgs>
    class?: boolean | Comment$classArgs<ExtArgs>
    team?: boolean | Comment$teamArgs<ExtArgs>
    event?: boolean | Comment$eventArgs<ExtArgs>
    lesson?: boolean | Comment$lessonArgs<ExtArgs>
    exam?: boolean | Comment$examArgs<ExtArgs>
    exercise?: boolean | Comment$exerciseArgs<ExtArgs>
    student?: boolean | Comment$studentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    userId?: boolean
    courseId?: boolean
    moduleId?: boolean
    topicId?: boolean
    materialId?: boolean
    enrollmentId?: boolean
    classId?: boolean
    teamId?: boolean
    eventId?: boolean
    lessonId?: boolean
    examId?: boolean
    exerciseId?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "userId" | "courseId" | "moduleId" | "topicId" | "materialId" | "enrollmentId" | "classId" | "teamId" | "eventId" | "lessonId" | "examId" | "exerciseId" | "studentId" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Comment$courseArgs<ExtArgs>
    module?: boolean | Comment$moduleArgs<ExtArgs>
    topic?: boolean | Comment$topicArgs<ExtArgs>
    material?: boolean | Comment$materialArgs<ExtArgs>
    enrollment?: boolean | Comment$enrollmentArgs<ExtArgs>
    class?: boolean | Comment$classArgs<ExtArgs>
    team?: boolean | Comment$teamArgs<ExtArgs>
    event?: boolean | Comment$eventArgs<ExtArgs>
    lesson?: boolean | Comment$lessonArgs<ExtArgs>
    exam?: boolean | Comment$examArgs<ExtArgs>
    exercise?: boolean | Comment$exerciseArgs<ExtArgs>
    student?: boolean | Comment$studentArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Comment$courseArgs<ExtArgs>
    module?: boolean | Comment$moduleArgs<ExtArgs>
    topic?: boolean | Comment$topicArgs<ExtArgs>
    material?: boolean | Comment$materialArgs<ExtArgs>
    enrollment?: boolean | Comment$enrollmentArgs<ExtArgs>
    class?: boolean | Comment$classArgs<ExtArgs>
    team?: boolean | Comment$teamArgs<ExtArgs>
    event?: boolean | Comment$eventArgs<ExtArgs>
    lesson?: boolean | Comment$lessonArgs<ExtArgs>
    exam?: boolean | Comment$examArgs<ExtArgs>
    exercise?: boolean | Comment$exerciseArgs<ExtArgs>
    student?: boolean | Comment$studentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | Comment$courseArgs<ExtArgs>
    module?: boolean | Comment$moduleArgs<ExtArgs>
    topic?: boolean | Comment$topicArgs<ExtArgs>
    material?: boolean | Comment$materialArgs<ExtArgs>
    enrollment?: boolean | Comment$enrollmentArgs<ExtArgs>
    class?: boolean | Comment$classArgs<ExtArgs>
    team?: boolean | Comment$teamArgs<ExtArgs>
    event?: boolean | Comment$eventArgs<ExtArgs>
    lesson?: boolean | Comment$lessonArgs<ExtArgs>
    exam?: boolean | Comment$examArgs<ExtArgs>
    exercise?: boolean | Comment$exerciseArgs<ExtArgs>
    student?: boolean | Comment$studentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
      module: Prisma.$ModulePayload<ExtArgs> | null
      topic: Prisma.$TopicPayload<ExtArgs> | null
      material: Prisma.$MaterialPayload<ExtArgs> | null
      enrollment: Prisma.$EnrollmentPayload<ExtArgs> | null
      class: Prisma.$ClassPayload<ExtArgs> | null
      team: Prisma.$TeamPayload<ExtArgs> | null
      event: Prisma.$EventPayload<ExtArgs> | null
      lesson: Prisma.$LessonPayload<ExtArgs> | null
      exam: Prisma.$ExamPayload<ExtArgs> | null
      exercise: Prisma.$ExercisePayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      userId: string
      courseId: string | null
      moduleId: string | null
      topicId: string | null
      materialId: string | null
      enrollmentId: string | null
      classId: string | null
      teamId: string | null
      eventId: string | null
      lessonId: string | null
      examId: string | null
      exerciseId: string | null
      studentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    course<T extends Comment$courseArgs<ExtArgs> = {}>(args?: Subset<T, Comment$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    module<T extends Comment$moduleArgs<ExtArgs> = {}>(args?: Subset<T, Comment$moduleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    topic<T extends Comment$topicArgs<ExtArgs> = {}>(args?: Subset<T, Comment$topicArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    material<T extends Comment$materialArgs<ExtArgs> = {}>(args?: Subset<T, Comment$materialArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    enrollment<T extends Comment$enrollmentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$enrollmentArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    class<T extends Comment$classArgs<ExtArgs> = {}>(args?: Subset<T, Comment$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    team<T extends Comment$teamArgs<ExtArgs> = {}>(args?: Subset<T, Comment$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    event<T extends Comment$eventArgs<ExtArgs> = {}>(args?: Subset<T, Comment$eventArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    lesson<T extends Comment$lessonArgs<ExtArgs> = {}>(args?: Subset<T, Comment$lessonArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    exam<T extends Comment$examArgs<ExtArgs> = {}>(args?: Subset<T, Comment$examArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    exercise<T extends Comment$exerciseArgs<ExtArgs> = {}>(args?: Subset<T, Comment$exerciseArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    student<T extends Comment$studentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly courseId: FieldRef<"Comment", 'String'>
    readonly moduleId: FieldRef<"Comment", 'String'>
    readonly topicId: FieldRef<"Comment", 'String'>
    readonly materialId: FieldRef<"Comment", 'String'>
    readonly enrollmentId: FieldRef<"Comment", 'String'>
    readonly classId: FieldRef<"Comment", 'String'>
    readonly teamId: FieldRef<"Comment", 'String'>
    readonly eventId: FieldRef<"Comment", 'String'>
    readonly lessonId: FieldRef<"Comment", 'String'>
    readonly examId: FieldRef<"Comment", 'String'>
    readonly exerciseId: FieldRef<"Comment", 'String'>
    readonly studentId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.course
   */
  export type Comment$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Comment.module
   */
  export type Comment$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * Comment.topic
   */
  export type Comment$topicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
  }

  /**
   * Comment.material
   */
  export type Comment$materialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
  }

  /**
   * Comment.enrollment
   */
  export type Comment$enrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
  }

  /**
   * Comment.class
   */
  export type Comment$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Comment.team
   */
  export type Comment$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Comment.event
   */
  export type Comment$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
  }

  /**
   * Comment.lesson
   */
  export type Comment$lessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
  }

  /**
   * Comment.exam
   */
  export type Comment$examArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
  }

  /**
   * Comment.exercise
   */
  export type Comment$exerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
  }

  /**
   * Comment.student
   */
  export type Comment$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentAvgAggregateOutputType = {
    totalPrice: number | null
  }

  export type EnrollmentSumAggregateOutputType = {
    totalPrice: number | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    classId: string | null
    status: $Enums.EnrollmentStatusEnum | null
    startDate: Date | null
    endDate: Date | null
    totalPrice: number | null
    currency: $Enums.CurrencyTypeEnum | null
    teacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    classId: string | null
    status: $Enums.EnrollmentStatusEnum | null
    startDate: Date | null
    endDate: Date | null
    totalPrice: number | null
    currency: $Enums.CurrencyTypeEnum | null
    teacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    courseId: number
    classId: number
    status: number
    startDate: number
    endDate: number
    totalPrice: number
    currency: number
    teacherId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EnrollmentAvgAggregateInputType = {
    totalPrice?: true
  }

  export type EnrollmentSumAggregateInputType = {
    totalPrice?: true
  }

  export type EnrollmentMinAggregateInputType = {
    id?: true
    courseId?: true
    classId?: true
    status?: true
    startDate?: true
    endDate?: true
    totalPrice?: true
    currency?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    courseId?: true
    classId?: true
    status?: true
    startDate?: true
    endDate?: true
    totalPrice?: true
    currency?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    courseId?: true
    classId?: true
    status?: true
    startDate?: true
    endDate?: true
    totalPrice?: true
    currency?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _avg?: EnrollmentAvgAggregateInputType
    _sum?: EnrollmentSumAggregateInputType
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: string
    courseId: string
    classId: string
    status: $Enums.EnrollmentStatusEnum
    startDate: Date
    endDate: Date
    totalPrice: number | null
    currency: $Enums.CurrencyTypeEnum
    teacherId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    classId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    totalPrice?: boolean
    currency?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | Enrollment$teacherArgs<ExtArgs>
    holidays?: boolean | Enrollment$holidaysArgs<ExtArgs>
    comments?: boolean | Enrollment$commentsArgs<ExtArgs>
    _count?: boolean | EnrollmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    classId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    totalPrice?: boolean
    currency?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | Enrollment$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    classId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    totalPrice?: boolean
    currency?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | Enrollment$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectScalar = {
    id?: boolean
    courseId?: boolean
    classId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    totalPrice?: boolean
    currency?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "classId" | "status" | "startDate" | "endDate" | "totalPrice" | "currency" | "teacherId" | "createdAt" | "updatedAt", ExtArgs["result"]["enrollment"]>
  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | Enrollment$teacherArgs<ExtArgs>
    holidays?: boolean | Enrollment$holidaysArgs<ExtArgs>
    comments?: boolean | Enrollment$commentsArgs<ExtArgs>
    _count?: boolean | EnrollmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | Enrollment$teacherArgs<ExtArgs>
  }
  export type EnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | Enrollment$teacherArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      holidays: Prisma.$HolidayPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      classId: string
      status: $Enums.EnrollmentStatusEnum
      startDate: Date
      endDate: Date
      totalPrice: number | null
      currency: $Enums.CurrencyTypeEnum
      teacherId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {EnrollmentCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {EnrollmentUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    teacher<T extends Enrollment$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    holidays<T extends Enrollment$holidaysArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$holidaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends Enrollment$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */ 
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'String'>
    readonly courseId: FieldRef<"Enrollment", 'String'>
    readonly classId: FieldRef<"Enrollment", 'String'>
    readonly status: FieldRef<"Enrollment", 'EnrollmentStatusEnum'>
    readonly startDate: FieldRef<"Enrollment", 'DateTime'>
    readonly endDate: FieldRef<"Enrollment", 'DateTime'>
    readonly totalPrice: FieldRef<"Enrollment", 'Int'>
    readonly currency: FieldRef<"Enrollment", 'CurrencyTypeEnum'>
    readonly teacherId: FieldRef<"Enrollment", 'String'>
    readonly createdAt: FieldRef<"Enrollment", 'DateTime'>
    readonly updatedAt: FieldRef<"Enrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment createManyAndReturn
   */
  export type EnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
  }

  /**
   * Enrollment updateManyAndReturn
   */
  export type EnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to delete.
     */
    limit?: number
  }

  /**
   * Enrollment.teacher
   */
  export type Enrollment$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Enrollment.holidays
   */
  export type Enrollment$holidaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    where?: HolidayWhereInput
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    cursor?: HolidayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Enrollment.comments
   */
  export type Enrollment$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    courseId: string | null
    teacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    courseId: string | null
    teacherId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    description: number
    color: number
    courseId: number
    teacherId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    courseId?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    courseId?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    courseId?: true
    teacherId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    name: string
    description: string | null
    color: string | null
    courseId: string
    teacherId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    courseId?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    teams?: boolean | Class$teamsArgs<ExtArgs>
    enrollments?: boolean | Class$enrollmentsArgs<ExtArgs>
    comments?: boolean | Class$commentsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    courseId?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    courseId?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    courseId?: boolean
    teacherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "color" | "courseId" | "teacherId" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    teams?: boolean | Class$teamsArgs<ExtArgs>
    enrollments?: boolean | Class$enrollmentsArgs<ExtArgs>
    comments?: boolean | Class$commentsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
  }
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    teacher?: boolean | Class$teacherArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      students: Prisma.$StudentPayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      color: string | null
      courseId: string
      teacherId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    teacher<T extends Class$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Class$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    students<T extends Class$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    teams<T extends Class$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Class$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    enrollments<T extends Class$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends Class$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */ 
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly description: FieldRef<"Class", 'String'>
    readonly color: FieldRef<"Class", 'String'>
    readonly courseId: FieldRef<"Class", 'String'>
    readonly teacherId: FieldRef<"Class", 'String'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.teacher
   */
  export type Class$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Class.students
   */
  export type Class$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Class.teams
   */
  export type Class$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Class.enrollments
   */
  export type Class$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Class.comments
   */
  export type Class$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model Holiday
   */

  export type AggregateHoliday = {
    _count: HolidayCountAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  export type HolidayMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    enrollmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HolidayMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    enrollmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HolidayCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    enrollmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HolidayMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    enrollmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HolidayMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    enrollmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HolidayCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    enrollmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HolidayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holiday to aggregate.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Holidays
    **/
    _count?: true | HolidayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolidayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolidayMaxAggregateInputType
  }

  export type GetHolidayAggregateType<T extends HolidayAggregateArgs> = {
        [P in keyof T & keyof AggregateHoliday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoliday[P]>
      : GetScalarType<T[P], AggregateHoliday[P]>
  }




  export type HolidayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolidayWhereInput
    orderBy?: HolidayOrderByWithAggregationInput | HolidayOrderByWithAggregationInput[]
    by: HolidayScalarFieldEnum[] | HolidayScalarFieldEnum
    having?: HolidayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolidayCountAggregateInputType | true
    _min?: HolidayMinAggregateInputType
    _max?: HolidayMaxAggregateInputType
  }

  export type HolidayGroupByOutputType = {
    id: string
    name: string
    startDate: Date
    endDate: Date
    enrollmentId: string
    createdAt: Date
    updatedAt: Date
    _count: HolidayCountAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  type GetHolidayGroupByPayload<T extends HolidayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolidayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolidayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolidayGroupByOutputType[P]>
            : GetScalarType<T[P], HolidayGroupByOutputType[P]>
        }
      >
    >


  export type HolidaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    enrollmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    enrollmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    enrollmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    enrollmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HolidayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "endDate" | "enrollmentId" | "createdAt" | "updatedAt", ExtArgs["result"]["holiday"]>
  export type HolidayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }
  export type HolidayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }
  export type HolidayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | EnrollmentDefaultArgs<ExtArgs>
  }

  export type $HolidayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Holiday"
    objects: {
      enrollment: Prisma.$EnrollmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date
      endDate: Date
      enrollmentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["holiday"]>
    composites: {}
  }

  type HolidayGetPayload<S extends boolean | null | undefined | HolidayDefaultArgs> = $Result.GetResult<Prisma.$HolidayPayload, S>

  type HolidayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HolidayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HolidayCountAggregateInputType | true
    }

  export interface HolidayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Holiday'], meta: { name: 'Holiday' } }
    /**
     * Find zero or one Holiday that matches the filter.
     * @param {HolidayFindUniqueArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HolidayFindUniqueArgs>(args: SelectSubset<T, HolidayFindUniqueArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Holiday that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HolidayFindUniqueOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HolidayFindUniqueOrThrowArgs>(args: SelectSubset<T, HolidayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Holiday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HolidayFindFirstArgs>(args?: SelectSubset<T, HolidayFindFirstArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Holiday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HolidayFindFirstOrThrowArgs>(args?: SelectSubset<T, HolidayFindFirstOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Holidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holidays
     * const holidays = await prisma.holiday.findMany()
     * 
     * // Get first 10 Holidays
     * const holidays = await prisma.holiday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holidayWithIdOnly = await prisma.holiday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HolidayFindManyArgs>(args?: SelectSubset<T, HolidayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Holiday.
     * @param {HolidayCreateArgs} args - Arguments to create a Holiday.
     * @example
     * // Create one Holiday
     * const Holiday = await prisma.holiday.create({
     *   data: {
     *     // ... data to create a Holiday
     *   }
     * })
     * 
     */
    create<T extends HolidayCreateArgs>(args: SelectSubset<T, HolidayCreateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Holidays.
     * @param {HolidayCreateManyArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HolidayCreateManyArgs>(args?: SelectSubset<T, HolidayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Holidays and returns the data saved in the database.
     * @param {HolidayCreateManyAndReturnArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Holidays and only return the `id`
     * const holidayWithIdOnly = await prisma.holiday.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HolidayCreateManyAndReturnArgs>(args?: SelectSubset<T, HolidayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Holiday.
     * @param {HolidayDeleteArgs} args - Arguments to delete one Holiday.
     * @example
     * // Delete one Holiday
     * const Holiday = await prisma.holiday.delete({
     *   where: {
     *     // ... filter to delete one Holiday
     *   }
     * })
     * 
     */
    delete<T extends HolidayDeleteArgs>(args: SelectSubset<T, HolidayDeleteArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Holiday.
     * @param {HolidayUpdateArgs} args - Arguments to update one Holiday.
     * @example
     * // Update one Holiday
     * const holiday = await prisma.holiday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HolidayUpdateArgs>(args: SelectSubset<T, HolidayUpdateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Holidays.
     * @param {HolidayDeleteManyArgs} args - Arguments to filter Holidays to delete.
     * @example
     * // Delete a few Holidays
     * const { count } = await prisma.holiday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HolidayDeleteManyArgs>(args?: SelectSubset<T, HolidayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holidays
     * const holiday = await prisma.holiday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HolidayUpdateManyArgs>(args: SelectSubset<T, HolidayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays and returns the data updated in the database.
     * @param {HolidayUpdateManyAndReturnArgs} args - Arguments to update many Holidays.
     * @example
     * // Update many Holidays
     * const holiday = await prisma.holiday.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Holidays and only return the `id`
     * const holidayWithIdOnly = await prisma.holiday.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HolidayUpdateManyAndReturnArgs>(args: SelectSubset<T, HolidayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Holiday.
     * @param {HolidayUpsertArgs} args - Arguments to update or create a Holiday.
     * @example
     * // Update or create a Holiday
     * const holiday = await prisma.holiday.upsert({
     *   create: {
     *     // ... data to create a Holiday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holiday we want to update
     *   }
     * })
     */
    upsert<T extends HolidayUpsertArgs>(args: SelectSubset<T, HolidayUpsertArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayCountArgs} args - Arguments to filter Holidays to count.
     * @example
     * // Count the number of Holidays
     * const count = await prisma.holiday.count({
     *   where: {
     *     // ... the filter for the Holidays we want to count
     *   }
     * })
    **/
    count<T extends HolidayCountArgs>(
      args?: Subset<T, HolidayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolidayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolidayAggregateArgs>(args: Subset<T, HolidayAggregateArgs>): Prisma.PrismaPromise<GetHolidayAggregateType<T>>

    /**
     * Group by Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HolidayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HolidayGroupByArgs['orderBy'] }
        : { orderBy?: HolidayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HolidayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolidayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Holiday model
   */
  readonly fields: HolidayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Holiday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HolidayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollment<T extends EnrollmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnrollmentDefaultArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Holiday model
   */ 
  interface HolidayFieldRefs {
    readonly id: FieldRef<"Holiday", 'String'>
    readonly name: FieldRef<"Holiday", 'String'>
    readonly startDate: FieldRef<"Holiday", 'DateTime'>
    readonly endDate: FieldRef<"Holiday", 'DateTime'>
    readonly enrollmentId: FieldRef<"Holiday", 'String'>
    readonly createdAt: FieldRef<"Holiday", 'DateTime'>
    readonly updatedAt: FieldRef<"Holiday", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Holiday findUnique
   */
  export type HolidayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findUniqueOrThrow
   */
  export type HolidayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findFirst
   */
  export type HolidayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findFirstOrThrow
   */
  export type HolidayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findMany
   */
  export type HolidayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holidays to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday create
   */
  export type HolidayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * The data needed to create a Holiday.
     */
    data: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
  }

  /**
   * Holiday createMany
   */
  export type HolidayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Holiday createManyAndReturn
   */
  export type HolidayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Holiday update
   */
  export type HolidayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * The data needed to update a Holiday.
     */
    data: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
    /**
     * Choose, which Holiday to update.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday updateMany
   */
  export type HolidayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Holidays.
     */
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyInput>
    /**
     * Filter which Holidays to update
     */
    where?: HolidayWhereInput
    /**
     * Limit how many Holidays to update.
     */
    limit?: number
  }

  /**
   * Holiday updateManyAndReturn
   */
  export type HolidayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * The data used to update Holidays.
     */
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyInput>
    /**
     * Filter which Holidays to update
     */
    where?: HolidayWhereInput
    /**
     * Limit how many Holidays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Holiday upsert
   */
  export type HolidayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * The filter to search for the Holiday to update in case it exists.
     */
    where: HolidayWhereUniqueInput
    /**
     * In case the Holiday found by the `where` argument doesn't exist, create a new Holiday with this data.
     */
    create: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
    /**
     * In case the Holiday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
  }

  /**
   * Holiday delete
   */
  export type HolidayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter which Holiday to delete.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday deleteMany
   */
  export type HolidayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holidays to delete
     */
    where?: HolidayWhereInput
    /**
     * Limit how many Holidays to delete.
     */
    limit?: number
  }

  /**
   * Holiday without action
   */
  export type HolidayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
  }


  /**
   * Model LessonSchedule
   */

  export type AggregateLessonSchedule = {
    _count: LessonScheduleCountAggregateOutputType | null
    _avg: LessonScheduleAvgAggregateOutputType | null
    _sum: LessonScheduleSumAggregateOutputType | null
    _min: LessonScheduleMinAggregateOutputType | null
    _max: LessonScheduleMaxAggregateOutputType | null
  }

  export type LessonScheduleAvgAggregateOutputType = {
    duration: number | null
  }

  export type LessonScheduleSumAggregateOutputType = {
    duration: number | null
  }

  export type LessonScheduleMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    dateTime: Date | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    teacherId: string | null
  }

  export type LessonScheduleMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    dateTime: Date | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    teacherId: string | null
  }

  export type LessonScheduleCountAggregateOutputType = {
    id: number
    lessonId: number
    dateTime: number
    duration: number
    createdAt: number
    updatedAt: number
    teacherId: number
    _all: number
  }


  export type LessonScheduleAvgAggregateInputType = {
    duration?: true
  }

  export type LessonScheduleSumAggregateInputType = {
    duration?: true
  }

  export type LessonScheduleMinAggregateInputType = {
    id?: true
    lessonId?: true
    dateTime?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    teacherId?: true
  }

  export type LessonScheduleMaxAggregateInputType = {
    id?: true
    lessonId?: true
    dateTime?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    teacherId?: true
  }

  export type LessonScheduleCountAggregateInputType = {
    id?: true
    lessonId?: true
    dateTime?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    teacherId?: true
    _all?: true
  }

  export type LessonScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonSchedule to aggregate.
     */
    where?: LessonScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonSchedules to fetch.
     */
    orderBy?: LessonScheduleOrderByWithRelationInput | LessonScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonSchedules
    **/
    _count?: true | LessonScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonScheduleMaxAggregateInputType
  }

  export type GetLessonScheduleAggregateType<T extends LessonScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonSchedule[P]>
      : GetScalarType<T[P], AggregateLessonSchedule[P]>
  }




  export type LessonScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonScheduleWhereInput
    orderBy?: LessonScheduleOrderByWithAggregationInput | LessonScheduleOrderByWithAggregationInput[]
    by: LessonScheduleScalarFieldEnum[] | LessonScheduleScalarFieldEnum
    having?: LessonScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonScheduleCountAggregateInputType | true
    _avg?: LessonScheduleAvgAggregateInputType
    _sum?: LessonScheduleSumAggregateInputType
    _min?: LessonScheduleMinAggregateInputType
    _max?: LessonScheduleMaxAggregateInputType
  }

  export type LessonScheduleGroupByOutputType = {
    id: string
    lessonId: string
    dateTime: Date
    duration: number
    createdAt: Date
    updatedAt: Date
    teacherId: string | null
    _count: LessonScheduleCountAggregateOutputType | null
    _avg: LessonScheduleAvgAggregateOutputType | null
    _sum: LessonScheduleSumAggregateOutputType | null
    _min: LessonScheduleMinAggregateOutputType | null
    _max: LessonScheduleMaxAggregateOutputType | null
  }

  type GetLessonScheduleGroupByPayload<T extends LessonScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], LessonScheduleGroupByOutputType[P]>
        }
      >
    >


  export type LessonScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    dateTime?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacherId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    teacher?: boolean | LessonSchedule$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["lessonSchedule"]>

  export type LessonScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    dateTime?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacherId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    teacher?: boolean | LessonSchedule$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["lessonSchedule"]>

  export type LessonScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    dateTime?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacherId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    teacher?: boolean | LessonSchedule$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["lessonSchedule"]>

  export type LessonScheduleSelectScalar = {
    id?: boolean
    lessonId?: boolean
    dateTime?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacherId?: boolean
  }

  export type LessonScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "dateTime" | "duration" | "createdAt" | "updatedAt" | "teacherId", ExtArgs["result"]["lessonSchedule"]>
  export type LessonScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    teacher?: boolean | LessonSchedule$teacherArgs<ExtArgs>
  }
  export type LessonScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    teacher?: boolean | LessonSchedule$teacherArgs<ExtArgs>
  }
  export type LessonScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    teacher?: boolean | LessonSchedule$teacherArgs<ExtArgs>
  }

  export type $LessonSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonSchedule"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      dateTime: Date
      duration: number
      createdAt: Date
      updatedAt: Date
      teacherId: string | null
    }, ExtArgs["result"]["lessonSchedule"]>
    composites: {}
  }

  type LessonScheduleGetPayload<S extends boolean | null | undefined | LessonScheduleDefaultArgs> = $Result.GetResult<Prisma.$LessonSchedulePayload, S>

  type LessonScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonScheduleCountAggregateInputType | true
    }

  export interface LessonScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonSchedule'], meta: { name: 'LessonSchedule' } }
    /**
     * Find zero or one LessonSchedule that matches the filter.
     * @param {LessonScheduleFindUniqueArgs} args - Arguments to find a LessonSchedule
     * @example
     * // Get one LessonSchedule
     * const lessonSchedule = await prisma.lessonSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonScheduleFindUniqueArgs>(args: SelectSubset<T, LessonScheduleFindUniqueArgs<ExtArgs>>): Prisma__LessonScheduleClient<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LessonSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonScheduleFindUniqueOrThrowArgs} args - Arguments to find a LessonSchedule
     * @example
     * // Get one LessonSchedule
     * const lessonSchedule = await prisma.lessonSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonScheduleClient<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LessonSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonScheduleFindFirstArgs} args - Arguments to find a LessonSchedule
     * @example
     * // Get one LessonSchedule
     * const lessonSchedule = await prisma.lessonSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonScheduleFindFirstArgs>(args?: SelectSubset<T, LessonScheduleFindFirstArgs<ExtArgs>>): Prisma__LessonScheduleClient<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LessonSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonScheduleFindFirstOrThrowArgs} args - Arguments to find a LessonSchedule
     * @example
     * // Get one LessonSchedule
     * const lessonSchedule = await prisma.lessonSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonScheduleClient<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LessonSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonSchedules
     * const lessonSchedules = await prisma.lessonSchedule.findMany()
     * 
     * // Get first 10 LessonSchedules
     * const lessonSchedules = await prisma.lessonSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonScheduleWithIdOnly = await prisma.lessonSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonScheduleFindManyArgs>(args?: SelectSubset<T, LessonScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LessonSchedule.
     * @param {LessonScheduleCreateArgs} args - Arguments to create a LessonSchedule.
     * @example
     * // Create one LessonSchedule
     * const LessonSchedule = await prisma.lessonSchedule.create({
     *   data: {
     *     // ... data to create a LessonSchedule
     *   }
     * })
     * 
     */
    create<T extends LessonScheduleCreateArgs>(args: SelectSubset<T, LessonScheduleCreateArgs<ExtArgs>>): Prisma__LessonScheduleClient<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LessonSchedules.
     * @param {LessonScheduleCreateManyArgs} args - Arguments to create many LessonSchedules.
     * @example
     * // Create many LessonSchedules
     * const lessonSchedule = await prisma.lessonSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonScheduleCreateManyArgs>(args?: SelectSubset<T, LessonScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonSchedules and returns the data saved in the database.
     * @param {LessonScheduleCreateManyAndReturnArgs} args - Arguments to create many LessonSchedules.
     * @example
     * // Create many LessonSchedules
     * const lessonSchedule = await prisma.lessonSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonSchedules and only return the `id`
     * const lessonScheduleWithIdOnly = await prisma.lessonSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LessonSchedule.
     * @param {LessonScheduleDeleteArgs} args - Arguments to delete one LessonSchedule.
     * @example
     * // Delete one LessonSchedule
     * const LessonSchedule = await prisma.lessonSchedule.delete({
     *   where: {
     *     // ... filter to delete one LessonSchedule
     *   }
     * })
     * 
     */
    delete<T extends LessonScheduleDeleteArgs>(args: SelectSubset<T, LessonScheduleDeleteArgs<ExtArgs>>): Prisma__LessonScheduleClient<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LessonSchedule.
     * @param {LessonScheduleUpdateArgs} args - Arguments to update one LessonSchedule.
     * @example
     * // Update one LessonSchedule
     * const lessonSchedule = await prisma.lessonSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonScheduleUpdateArgs>(args: SelectSubset<T, LessonScheduleUpdateArgs<ExtArgs>>): Prisma__LessonScheduleClient<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LessonSchedules.
     * @param {LessonScheduleDeleteManyArgs} args - Arguments to filter LessonSchedules to delete.
     * @example
     * // Delete a few LessonSchedules
     * const { count } = await prisma.lessonSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonScheduleDeleteManyArgs>(args?: SelectSubset<T, LessonScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonSchedules
     * const lessonSchedule = await prisma.lessonSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonScheduleUpdateManyArgs>(args: SelectSubset<T, LessonScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonSchedules and returns the data updated in the database.
     * @param {LessonScheduleUpdateManyAndReturnArgs} args - Arguments to update many LessonSchedules.
     * @example
     * // Update many LessonSchedules
     * const lessonSchedule = await prisma.lessonSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonSchedules and only return the `id`
     * const lessonScheduleWithIdOnly = await prisma.lessonSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LessonSchedule.
     * @param {LessonScheduleUpsertArgs} args - Arguments to update or create a LessonSchedule.
     * @example
     * // Update or create a LessonSchedule
     * const lessonSchedule = await prisma.lessonSchedule.upsert({
     *   create: {
     *     // ... data to create a LessonSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonSchedule we want to update
     *   }
     * })
     */
    upsert<T extends LessonScheduleUpsertArgs>(args: SelectSubset<T, LessonScheduleUpsertArgs<ExtArgs>>): Prisma__LessonScheduleClient<$Result.GetResult<Prisma.$LessonSchedulePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LessonSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonScheduleCountArgs} args - Arguments to filter LessonSchedules to count.
     * @example
     * // Count the number of LessonSchedules
     * const count = await prisma.lessonSchedule.count({
     *   where: {
     *     // ... the filter for the LessonSchedules we want to count
     *   }
     * })
    **/
    count<T extends LessonScheduleCountArgs>(
      args?: Subset<T, LessonScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonScheduleAggregateArgs>(args: Subset<T, LessonScheduleAggregateArgs>): Prisma.PrismaPromise<GetLessonScheduleAggregateType<T>>

    /**
     * Group by LessonSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonScheduleGroupByArgs['orderBy'] }
        : { orderBy?: LessonScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonSchedule model
   */
  readonly fields: LessonScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    teacher<T extends LessonSchedule$teacherArgs<ExtArgs> = {}>(args?: Subset<T, LessonSchedule$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonSchedule model
   */ 
  interface LessonScheduleFieldRefs {
    readonly id: FieldRef<"LessonSchedule", 'String'>
    readonly lessonId: FieldRef<"LessonSchedule", 'String'>
    readonly dateTime: FieldRef<"LessonSchedule", 'DateTime'>
    readonly duration: FieldRef<"LessonSchedule", 'Int'>
    readonly createdAt: FieldRef<"LessonSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"LessonSchedule", 'DateTime'>
    readonly teacherId: FieldRef<"LessonSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LessonSchedule findUnique
   */
  export type LessonScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    /**
     * Filter, which LessonSchedule to fetch.
     */
    where: LessonScheduleWhereUniqueInput
  }

  /**
   * LessonSchedule findUniqueOrThrow
   */
  export type LessonScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    /**
     * Filter, which LessonSchedule to fetch.
     */
    where: LessonScheduleWhereUniqueInput
  }

  /**
   * LessonSchedule findFirst
   */
  export type LessonScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    /**
     * Filter, which LessonSchedule to fetch.
     */
    where?: LessonScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonSchedules to fetch.
     */
    orderBy?: LessonScheduleOrderByWithRelationInput | LessonScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonSchedules.
     */
    cursor?: LessonScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonSchedules.
     */
    distinct?: LessonScheduleScalarFieldEnum | LessonScheduleScalarFieldEnum[]
  }

  /**
   * LessonSchedule findFirstOrThrow
   */
  export type LessonScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    /**
     * Filter, which LessonSchedule to fetch.
     */
    where?: LessonScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonSchedules to fetch.
     */
    orderBy?: LessonScheduleOrderByWithRelationInput | LessonScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonSchedules.
     */
    cursor?: LessonScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonSchedules.
     */
    distinct?: LessonScheduleScalarFieldEnum | LessonScheduleScalarFieldEnum[]
  }

  /**
   * LessonSchedule findMany
   */
  export type LessonScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    /**
     * Filter, which LessonSchedules to fetch.
     */
    where?: LessonScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonSchedules to fetch.
     */
    orderBy?: LessonScheduleOrderByWithRelationInput | LessonScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonSchedules.
     */
    cursor?: LessonScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonSchedules.
     */
    skip?: number
    distinct?: LessonScheduleScalarFieldEnum | LessonScheduleScalarFieldEnum[]
  }

  /**
   * LessonSchedule create
   */
  export type LessonScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonSchedule.
     */
    data: XOR<LessonScheduleCreateInput, LessonScheduleUncheckedCreateInput>
  }

  /**
   * LessonSchedule createMany
   */
  export type LessonScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonSchedules.
     */
    data: LessonScheduleCreateManyInput | LessonScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonSchedule createManyAndReturn
   */
  export type LessonScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many LessonSchedules.
     */
    data: LessonScheduleCreateManyInput | LessonScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonSchedule update
   */
  export type LessonScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonSchedule.
     */
    data: XOR<LessonScheduleUpdateInput, LessonScheduleUncheckedUpdateInput>
    /**
     * Choose, which LessonSchedule to update.
     */
    where: LessonScheduleWhereUniqueInput
  }

  /**
   * LessonSchedule updateMany
   */
  export type LessonScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonSchedules.
     */
    data: XOR<LessonScheduleUpdateManyMutationInput, LessonScheduleUncheckedUpdateManyInput>
    /**
     * Filter which LessonSchedules to update
     */
    where?: LessonScheduleWhereInput
    /**
     * Limit how many LessonSchedules to update.
     */
    limit?: number
  }

  /**
   * LessonSchedule updateManyAndReturn
   */
  export type LessonScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * The data used to update LessonSchedules.
     */
    data: XOR<LessonScheduleUpdateManyMutationInput, LessonScheduleUncheckedUpdateManyInput>
    /**
     * Filter which LessonSchedules to update
     */
    where?: LessonScheduleWhereInput
    /**
     * Limit how many LessonSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonSchedule upsert
   */
  export type LessonScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonSchedule to update in case it exists.
     */
    where: LessonScheduleWhereUniqueInput
    /**
     * In case the LessonSchedule found by the `where` argument doesn't exist, create a new LessonSchedule with this data.
     */
    create: XOR<LessonScheduleCreateInput, LessonScheduleUncheckedCreateInput>
    /**
     * In case the LessonSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonScheduleUpdateInput, LessonScheduleUncheckedUpdateInput>
  }

  /**
   * LessonSchedule delete
   */
  export type LessonScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
    /**
     * Filter which LessonSchedule to delete.
     */
    where: LessonScheduleWhereUniqueInput
  }

  /**
   * LessonSchedule deleteMany
   */
  export type LessonScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonSchedules to delete
     */
    where?: LessonScheduleWhereInput
    /**
     * Limit how many LessonSchedules to delete.
     */
    limit?: number
  }

  /**
   * LessonSchedule.teacher
   */
  export type LessonSchedule$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * LessonSchedule without action
   */
  export type LessonScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSchedule
     */
    select?: LessonScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSchedule
     */
    omit?: LessonScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    type: $Enums.EventTypeEnum | null
    courseId: string | null
    moduleId: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    type: $Enums.EventTypeEnum | null
    courseId: string | null
    moduleId: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startTime: number
    endTime: number
    type: number
    courseId: number
    moduleId: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    type?: true
    courseId?: true
    moduleId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    type?: true
    courseId?: true
    moduleId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    type?: true
    courseId?: true
    moduleId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startTime: Date
    endTime: Date
    type: $Enums.EventTypeEnum
    courseId: string | null
    moduleId: string | null
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    courseId?: boolean
    moduleId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | Event$courseArgs<ExtArgs>
    module?: boolean | Event$moduleArgs<ExtArgs>
    comments?: boolean | Event$commentsArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    courseId?: boolean
    moduleId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | Event$courseArgs<ExtArgs>
    module?: boolean | Event$moduleArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    courseId?: boolean
    moduleId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | Event$courseArgs<ExtArgs>
    module?: boolean | Event$moduleArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    courseId?: boolean
    moduleId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startTime" | "endTime" | "type" | "courseId" | "moduleId" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Event$courseArgs<ExtArgs>
    module?: boolean | Event$moduleArgs<ExtArgs>
    comments?: boolean | Event$commentsArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Event$courseArgs<ExtArgs>
    module?: boolean | Event$moduleArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Event$courseArgs<ExtArgs>
    module?: boolean | Event$moduleArgs<ExtArgs>
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      module: Prisma.$ModulePayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      creator: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startTime: Date
      endTime: Date
      type: $Enums.EventTypeEnum
      courseId: string | null
      moduleId: string | null
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends Event$courseArgs<ExtArgs> = {}>(args?: Subset<T, Event$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    module<T extends Event$moduleArgs<ExtArgs> = {}>(args?: Subset<T, Event$moduleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    comments<T extends Event$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Event$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creator<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly startTime: FieldRef<"Event", 'DateTime'>
    readonly endTime: FieldRef<"Event", 'DateTime'>
    readonly type: FieldRef<"Event", 'EventTypeEnum'>
    readonly courseId: FieldRef<"Event", 'String'>
    readonly moduleId: FieldRef<"Event", 'String'>
    readonly creatorId: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.course
   */
  export type Event$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Event.module
   */
  export type Event$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * Event.comments
   */
  export type Event$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teacherId: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teacherId: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    classId: number
    createdAt: number
    updatedAt: number
    teacherId: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
    teacherId?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
    teacherId?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
    teacherId?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    description: string | null
    classId: string
    createdAt: Date
    updatedAt: Date
    teacherId: string | null
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacherId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    students?: boolean | Team$studentsArgs<ExtArgs>
    exercises?: boolean | Team$exercisesArgs<ExtArgs>
    comments?: boolean | Team$commentsArgs<ExtArgs>
    teacher?: boolean | Team$teacherArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacherId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | Team$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacherId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | Team$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacherId?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "classId" | "createdAt" | "updatedAt" | "teacherId", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    students?: boolean | Team$studentsArgs<ExtArgs>
    exercises?: boolean | Team$exercisesArgs<ExtArgs>
    comments?: boolean | Team$commentsArgs<ExtArgs>
    teacher?: boolean | Team$teacherArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | Team$teacherArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | Team$teacherArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      students: Prisma.$StudentPayload<ExtArgs>[]
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      classId: string
      createdAt: Date
      updatedAt: Date
      teacherId: string | null
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    students<T extends Team$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Team$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    exercises<T extends Team$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, Team$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends Team$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Team$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    teacher<T extends Team$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Team$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly classId: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
    readonly teacherId: FieldRef<"Team", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.students
   */
  export type Team$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Team.exercises
   */
  export type Team$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Team.comments
   */
  export type Team$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Team.teacher
   */
  export type Team$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    description: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string
    description: string | null
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    exercises?: boolean | Client$exercisesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
    exercises?: boolean | Client$exercisesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      creator: Prisma.$TeacherPayload<ExtArgs>
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    exercises<T extends Client$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, Client$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly description: FieldRef<"Client", 'String'>
    readonly creatorId: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.exercises
   */
  export type Client$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationTypeEnum | null
    teacherId: string | null
    studentId: string | null
    seen: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationTypeEnum | null
    teacherId: string | null
    studentId: string | null
    seen: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    type: number
    teacherId: number
    studentId: number
    seen: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    teacherId?: true
    studentId?: true
    seen?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    teacherId?: true
    studentId?: true
    seen?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    teacherId?: true
    studentId?: true
    seen?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string | null
    message: string | null
    type: $Enums.NotificationTypeEnum
    teacherId: string | null
    studentId: string | null
    seen: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    teacherId?: boolean
    studentId?: boolean
    seen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | Notification$teacherArgs<ExtArgs>
    student?: boolean | Notification$studentArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    teacherId?: boolean
    studentId?: boolean
    seen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | Notification$teacherArgs<ExtArgs>
    student?: boolean | Notification$studentArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    teacherId?: boolean
    studentId?: boolean
    seen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | Notification$teacherArgs<ExtArgs>
    student?: boolean | Notification$studentArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    teacherId?: boolean
    studentId?: boolean
    seen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "message" | "type" | "teacherId" | "studentId" | "seen" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Notification$teacherArgs<ExtArgs>
    student?: boolean | Notification$studentArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Notification$teacherArgs<ExtArgs>
    student?: boolean | Notification$studentArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Notification$teacherArgs<ExtArgs>
    student?: boolean | Notification$studentArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      message: string | null
      type: $Enums.NotificationTypeEnum
      teacherId: string | null
      studentId: string | null
      seen: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends Notification$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Notification$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    student<T extends Notification$studentArgs<ExtArgs> = {}>(args?: Subset<T, Notification$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationTypeEnum'>
    readonly teacherId: FieldRef<"Notification", 'String'>
    readonly studentId: FieldRef<"Notification", 'String'>
    readonly seen: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.teacher
   */
  export type Notification$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Notification.student
   */
  export type Notification$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ShopItemForSale
   */

  export type AggregateShopItemForSale = {
    _count: ShopItemForSaleCountAggregateOutputType | null
    _avg: ShopItemForSaleAvgAggregateOutputType | null
    _sum: ShopItemForSaleSumAggregateOutputType | null
    _min: ShopItemForSaleMinAggregateOutputType | null
    _max: ShopItemForSaleMaxAggregateOutputType | null
  }

  export type ShopItemForSaleAvgAggregateOutputType = {
    sellPrice: number | null
  }

  export type ShopItemForSaleSumAggregateOutputType = {
    sellPrice: number | null
  }

  export type ShopItemForSaleMinAggregateOutputType = {
    id: string | null
    itemType: $Enums.ShopItemTypeEnum | null
    itemId: string | null
    sellPrice: number | null
    currency: $Enums.CurrencyTypeEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopItemForSaleMaxAggregateOutputType = {
    id: string | null
    itemType: $Enums.ShopItemTypeEnum | null
    itemId: string | null
    sellPrice: number | null
    currency: $Enums.CurrencyTypeEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopItemForSaleCountAggregateOutputType = {
    id: number
    itemType: number
    itemId: number
    sellPrice: number
    currency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopItemForSaleAvgAggregateInputType = {
    sellPrice?: true
  }

  export type ShopItemForSaleSumAggregateInputType = {
    sellPrice?: true
  }

  export type ShopItemForSaleMinAggregateInputType = {
    id?: true
    itemType?: true
    itemId?: true
    sellPrice?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopItemForSaleMaxAggregateInputType = {
    id?: true
    itemType?: true
    itemId?: true
    sellPrice?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopItemForSaleCountAggregateInputType = {
    id?: true
    itemType?: true
    itemId?: true
    sellPrice?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopItemForSaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItemForSale to aggregate.
     */
    where?: ShopItemForSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItemForSales to fetch.
     */
    orderBy?: ShopItemForSaleOrderByWithRelationInput | ShopItemForSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopItemForSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItemForSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItemForSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopItemForSales
    **/
    _count?: true | ShopItemForSaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopItemForSaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopItemForSaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopItemForSaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopItemForSaleMaxAggregateInputType
  }

  export type GetShopItemForSaleAggregateType<T extends ShopItemForSaleAggregateArgs> = {
        [P in keyof T & keyof AggregateShopItemForSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopItemForSale[P]>
      : GetScalarType<T[P], AggregateShopItemForSale[P]>
  }




  export type ShopItemForSaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemForSaleWhereInput
    orderBy?: ShopItemForSaleOrderByWithAggregationInput | ShopItemForSaleOrderByWithAggregationInput[]
    by: ShopItemForSaleScalarFieldEnum[] | ShopItemForSaleScalarFieldEnum
    having?: ShopItemForSaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopItemForSaleCountAggregateInputType | true
    _avg?: ShopItemForSaleAvgAggregateInputType
    _sum?: ShopItemForSaleSumAggregateInputType
    _min?: ShopItemForSaleMinAggregateInputType
    _max?: ShopItemForSaleMaxAggregateInputType
  }

  export type ShopItemForSaleGroupByOutputType = {
    id: string
    itemType: $Enums.ShopItemTypeEnum
    itemId: string
    sellPrice: number
    currency: $Enums.CurrencyTypeEnum
    createdAt: Date
    updatedAt: Date
    _count: ShopItemForSaleCountAggregateOutputType | null
    _avg: ShopItemForSaleAvgAggregateOutputType | null
    _sum: ShopItemForSaleSumAggregateOutputType | null
    _min: ShopItemForSaleMinAggregateOutputType | null
    _max: ShopItemForSaleMaxAggregateOutputType | null
  }

  type GetShopItemForSaleGroupByPayload<T extends ShopItemForSaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopItemForSaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopItemForSaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopItemForSaleGroupByOutputType[P]>
            : GetScalarType<T[P], ShopItemForSaleGroupByOutputType[P]>
        }
      >
    >


  export type ShopItemForSaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemType?: boolean
    itemId?: boolean
    sellPrice?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | ShopItemForSale$courseArgs<ExtArgs>
    module?: boolean | ShopItemForSale$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForSale$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForSale$examArgs<ExtArgs>
    material?: boolean | ShopItemForSale$materialArgs<ExtArgs>
    purchases?: boolean | ShopItemForSale$purchasesArgs<ExtArgs>
    _count?: boolean | ShopItemForSaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopItemForSale"]>

  export type ShopItemForSaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemType?: boolean
    itemId?: boolean
    sellPrice?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | ShopItemForSale$courseArgs<ExtArgs>
    module?: boolean | ShopItemForSale$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForSale$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForSale$examArgs<ExtArgs>
    material?: boolean | ShopItemForSale$materialArgs<ExtArgs>
  }, ExtArgs["result"]["shopItemForSale"]>

  export type ShopItemForSaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemType?: boolean
    itemId?: boolean
    sellPrice?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | ShopItemForSale$courseArgs<ExtArgs>
    module?: boolean | ShopItemForSale$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForSale$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForSale$examArgs<ExtArgs>
    material?: boolean | ShopItemForSale$materialArgs<ExtArgs>
  }, ExtArgs["result"]["shopItemForSale"]>

  export type ShopItemForSaleSelectScalar = {
    id?: boolean
    itemType?: boolean
    itemId?: boolean
    sellPrice?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopItemForSaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemType" | "itemId" | "sellPrice" | "currency" | "createdAt" | "updatedAt", ExtArgs["result"]["shopItemForSale"]>
  export type ShopItemForSaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | ShopItemForSale$courseArgs<ExtArgs>
    module?: boolean | ShopItemForSale$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForSale$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForSale$examArgs<ExtArgs>
    material?: boolean | ShopItemForSale$materialArgs<ExtArgs>
    purchases?: boolean | ShopItemForSale$purchasesArgs<ExtArgs>
    _count?: boolean | ShopItemForSaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShopItemForSaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | ShopItemForSale$courseArgs<ExtArgs>
    module?: boolean | ShopItemForSale$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForSale$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForSale$examArgs<ExtArgs>
    material?: boolean | ShopItemForSale$materialArgs<ExtArgs>
  }
  export type ShopItemForSaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | ShopItemForSale$courseArgs<ExtArgs>
    module?: boolean | ShopItemForSale$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForSale$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForSale$examArgs<ExtArgs>
    material?: boolean | ShopItemForSale$materialArgs<ExtArgs>
  }

  export type $ShopItemForSalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopItemForSale"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      module: Prisma.$ModulePayload<ExtArgs> | null
      exercise: Prisma.$ExercisePayload<ExtArgs> | null
      exam: Prisma.$ExamPayload<ExtArgs> | null
      material: Prisma.$MaterialPayload<ExtArgs> | null
      purchases: Prisma.$PurchasedItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemType: $Enums.ShopItemTypeEnum
      itemId: string
      sellPrice: number
      currency: $Enums.CurrencyTypeEnum
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopItemForSale"]>
    composites: {}
  }

  type ShopItemForSaleGetPayload<S extends boolean | null | undefined | ShopItemForSaleDefaultArgs> = $Result.GetResult<Prisma.$ShopItemForSalePayload, S>

  type ShopItemForSaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopItemForSaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopItemForSaleCountAggregateInputType | true
    }

  export interface ShopItemForSaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopItemForSale'], meta: { name: 'ShopItemForSale' } }
    /**
     * Find zero or one ShopItemForSale that matches the filter.
     * @param {ShopItemForSaleFindUniqueArgs} args - Arguments to find a ShopItemForSale
     * @example
     * // Get one ShopItemForSale
     * const shopItemForSale = await prisma.shopItemForSale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopItemForSaleFindUniqueArgs>(args: SelectSubset<T, ShopItemForSaleFindUniqueArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ShopItemForSale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopItemForSaleFindUniqueOrThrowArgs} args - Arguments to find a ShopItemForSale
     * @example
     * // Get one ShopItemForSale
     * const shopItemForSale = await prisma.shopItemForSale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopItemForSaleFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopItemForSaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ShopItemForSale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForSaleFindFirstArgs} args - Arguments to find a ShopItemForSale
     * @example
     * // Get one ShopItemForSale
     * const shopItemForSale = await prisma.shopItemForSale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopItemForSaleFindFirstArgs>(args?: SelectSubset<T, ShopItemForSaleFindFirstArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ShopItemForSale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForSaleFindFirstOrThrowArgs} args - Arguments to find a ShopItemForSale
     * @example
     * // Get one ShopItemForSale
     * const shopItemForSale = await prisma.shopItemForSale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopItemForSaleFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopItemForSaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ShopItemForSales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForSaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopItemForSales
     * const shopItemForSales = await prisma.shopItemForSale.findMany()
     * 
     * // Get first 10 ShopItemForSales
     * const shopItemForSales = await prisma.shopItemForSale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopItemForSaleWithIdOnly = await prisma.shopItemForSale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopItemForSaleFindManyArgs>(args?: SelectSubset<T, ShopItemForSaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ShopItemForSale.
     * @param {ShopItemForSaleCreateArgs} args - Arguments to create a ShopItemForSale.
     * @example
     * // Create one ShopItemForSale
     * const ShopItemForSale = await prisma.shopItemForSale.create({
     *   data: {
     *     // ... data to create a ShopItemForSale
     *   }
     * })
     * 
     */
    create<T extends ShopItemForSaleCreateArgs>(args: SelectSubset<T, ShopItemForSaleCreateArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ShopItemForSales.
     * @param {ShopItemForSaleCreateManyArgs} args - Arguments to create many ShopItemForSales.
     * @example
     * // Create many ShopItemForSales
     * const shopItemForSale = await prisma.shopItemForSale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopItemForSaleCreateManyArgs>(args?: SelectSubset<T, ShopItemForSaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopItemForSales and returns the data saved in the database.
     * @param {ShopItemForSaleCreateManyAndReturnArgs} args - Arguments to create many ShopItemForSales.
     * @example
     * // Create many ShopItemForSales
     * const shopItemForSale = await prisma.shopItemForSale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopItemForSales and only return the `id`
     * const shopItemForSaleWithIdOnly = await prisma.shopItemForSale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopItemForSaleCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopItemForSaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ShopItemForSale.
     * @param {ShopItemForSaleDeleteArgs} args - Arguments to delete one ShopItemForSale.
     * @example
     * // Delete one ShopItemForSale
     * const ShopItemForSale = await prisma.shopItemForSale.delete({
     *   where: {
     *     // ... filter to delete one ShopItemForSale
     *   }
     * })
     * 
     */
    delete<T extends ShopItemForSaleDeleteArgs>(args: SelectSubset<T, ShopItemForSaleDeleteArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ShopItemForSale.
     * @param {ShopItemForSaleUpdateArgs} args - Arguments to update one ShopItemForSale.
     * @example
     * // Update one ShopItemForSale
     * const shopItemForSale = await prisma.shopItemForSale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopItemForSaleUpdateArgs>(args: SelectSubset<T, ShopItemForSaleUpdateArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ShopItemForSales.
     * @param {ShopItemForSaleDeleteManyArgs} args - Arguments to filter ShopItemForSales to delete.
     * @example
     * // Delete a few ShopItemForSales
     * const { count } = await prisma.shopItemForSale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopItemForSaleDeleteManyArgs>(args?: SelectSubset<T, ShopItemForSaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopItemForSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForSaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopItemForSales
     * const shopItemForSale = await prisma.shopItemForSale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopItemForSaleUpdateManyArgs>(args: SelectSubset<T, ShopItemForSaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopItemForSales and returns the data updated in the database.
     * @param {ShopItemForSaleUpdateManyAndReturnArgs} args - Arguments to update many ShopItemForSales.
     * @example
     * // Update many ShopItemForSales
     * const shopItemForSale = await prisma.shopItemForSale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShopItemForSales and only return the `id`
     * const shopItemForSaleWithIdOnly = await prisma.shopItemForSale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopItemForSaleUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopItemForSaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ShopItemForSale.
     * @param {ShopItemForSaleUpsertArgs} args - Arguments to update or create a ShopItemForSale.
     * @example
     * // Update or create a ShopItemForSale
     * const shopItemForSale = await prisma.shopItemForSale.upsert({
     *   create: {
     *     // ... data to create a ShopItemForSale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopItemForSale we want to update
     *   }
     * })
     */
    upsert<T extends ShopItemForSaleUpsertArgs>(args: SelectSubset<T, ShopItemForSaleUpsertArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ShopItemForSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForSaleCountArgs} args - Arguments to filter ShopItemForSales to count.
     * @example
     * // Count the number of ShopItemForSales
     * const count = await prisma.shopItemForSale.count({
     *   where: {
     *     // ... the filter for the ShopItemForSales we want to count
     *   }
     * })
    **/
    count<T extends ShopItemForSaleCountArgs>(
      args?: Subset<T, ShopItemForSaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopItemForSaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopItemForSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForSaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopItemForSaleAggregateArgs>(args: Subset<T, ShopItemForSaleAggregateArgs>): Prisma.PrismaPromise<GetShopItemForSaleAggregateType<T>>

    /**
     * Group by ShopItemForSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForSaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopItemForSaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopItemForSaleGroupByArgs['orderBy'] }
        : { orderBy?: ShopItemForSaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopItemForSaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopItemForSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopItemForSale model
   */
  readonly fields: ShopItemForSaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopItemForSale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopItemForSaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends ShopItemForSale$courseArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForSale$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    module<T extends ShopItemForSale$moduleArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForSale$moduleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    exercise<T extends ShopItemForSale$exerciseArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForSale$exerciseArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    exam<T extends ShopItemForSale$examArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForSale$examArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    material<T extends ShopItemForSale$materialArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForSale$materialArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    purchases<T extends ShopItemForSale$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForSale$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopItemForSale model
   */ 
  interface ShopItemForSaleFieldRefs {
    readonly id: FieldRef<"ShopItemForSale", 'String'>
    readonly itemType: FieldRef<"ShopItemForSale", 'ShopItemTypeEnum'>
    readonly itemId: FieldRef<"ShopItemForSale", 'String'>
    readonly sellPrice: FieldRef<"ShopItemForSale", 'Int'>
    readonly currency: FieldRef<"ShopItemForSale", 'CurrencyTypeEnum'>
    readonly createdAt: FieldRef<"ShopItemForSale", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopItemForSale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopItemForSale findUnique
   */
  export type ShopItemForSaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    /**
     * Filter, which ShopItemForSale to fetch.
     */
    where: ShopItemForSaleWhereUniqueInput
  }

  /**
   * ShopItemForSale findUniqueOrThrow
   */
  export type ShopItemForSaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    /**
     * Filter, which ShopItemForSale to fetch.
     */
    where: ShopItemForSaleWhereUniqueInput
  }

  /**
   * ShopItemForSale findFirst
   */
  export type ShopItemForSaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    /**
     * Filter, which ShopItemForSale to fetch.
     */
    where?: ShopItemForSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItemForSales to fetch.
     */
    orderBy?: ShopItemForSaleOrderByWithRelationInput | ShopItemForSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItemForSales.
     */
    cursor?: ShopItemForSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItemForSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItemForSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItemForSales.
     */
    distinct?: ShopItemForSaleScalarFieldEnum | ShopItemForSaleScalarFieldEnum[]
  }

  /**
   * ShopItemForSale findFirstOrThrow
   */
  export type ShopItemForSaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    /**
     * Filter, which ShopItemForSale to fetch.
     */
    where?: ShopItemForSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItemForSales to fetch.
     */
    orderBy?: ShopItemForSaleOrderByWithRelationInput | ShopItemForSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItemForSales.
     */
    cursor?: ShopItemForSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItemForSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItemForSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItemForSales.
     */
    distinct?: ShopItemForSaleScalarFieldEnum | ShopItemForSaleScalarFieldEnum[]
  }

  /**
   * ShopItemForSale findMany
   */
  export type ShopItemForSaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    /**
     * Filter, which ShopItemForSales to fetch.
     */
    where?: ShopItemForSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItemForSales to fetch.
     */
    orderBy?: ShopItemForSaleOrderByWithRelationInput | ShopItemForSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopItemForSales.
     */
    cursor?: ShopItemForSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItemForSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItemForSales.
     */
    skip?: number
    distinct?: ShopItemForSaleScalarFieldEnum | ShopItemForSaleScalarFieldEnum[]
  }

  /**
   * ShopItemForSale create
   */
  export type ShopItemForSaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopItemForSale.
     */
    data: XOR<ShopItemForSaleCreateInput, ShopItemForSaleUncheckedCreateInput>
  }

  /**
   * ShopItemForSale createMany
   */
  export type ShopItemForSaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopItemForSales.
     */
    data: ShopItemForSaleCreateManyInput | ShopItemForSaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopItemForSale createManyAndReturn
   */
  export type ShopItemForSaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * The data used to create many ShopItemForSales.
     */
    data: ShopItemForSaleCreateManyInput | ShopItemForSaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopItemForSale update
   */
  export type ShopItemForSaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopItemForSale.
     */
    data: XOR<ShopItemForSaleUpdateInput, ShopItemForSaleUncheckedUpdateInput>
    /**
     * Choose, which ShopItemForSale to update.
     */
    where: ShopItemForSaleWhereUniqueInput
  }

  /**
   * ShopItemForSale updateMany
   */
  export type ShopItemForSaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopItemForSales.
     */
    data: XOR<ShopItemForSaleUpdateManyMutationInput, ShopItemForSaleUncheckedUpdateManyInput>
    /**
     * Filter which ShopItemForSales to update
     */
    where?: ShopItemForSaleWhereInput
    /**
     * Limit how many ShopItemForSales to update.
     */
    limit?: number
  }

  /**
   * ShopItemForSale updateManyAndReturn
   */
  export type ShopItemForSaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * The data used to update ShopItemForSales.
     */
    data: XOR<ShopItemForSaleUpdateManyMutationInput, ShopItemForSaleUncheckedUpdateManyInput>
    /**
     * Filter which ShopItemForSales to update
     */
    where?: ShopItemForSaleWhereInput
    /**
     * Limit how many ShopItemForSales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopItemForSale upsert
   */
  export type ShopItemForSaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopItemForSale to update in case it exists.
     */
    where: ShopItemForSaleWhereUniqueInput
    /**
     * In case the ShopItemForSale found by the `where` argument doesn't exist, create a new ShopItemForSale with this data.
     */
    create: XOR<ShopItemForSaleCreateInput, ShopItemForSaleUncheckedCreateInput>
    /**
     * In case the ShopItemForSale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopItemForSaleUpdateInput, ShopItemForSaleUncheckedUpdateInput>
  }

  /**
   * ShopItemForSale delete
   */
  export type ShopItemForSaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
    /**
     * Filter which ShopItemForSale to delete.
     */
    where: ShopItemForSaleWhereUniqueInput
  }

  /**
   * ShopItemForSale deleteMany
   */
  export type ShopItemForSaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItemForSales to delete
     */
    where?: ShopItemForSaleWhereInput
    /**
     * Limit how many ShopItemForSales to delete.
     */
    limit?: number
  }

  /**
   * ShopItemForSale.course
   */
  export type ShopItemForSale$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * ShopItemForSale.module
   */
  export type ShopItemForSale$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * ShopItemForSale.exercise
   */
  export type ShopItemForSale$exerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
  }

  /**
   * ShopItemForSale.exam
   */
  export type ShopItemForSale$examArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
  }

  /**
   * ShopItemForSale.material
   */
  export type ShopItemForSale$materialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
  }

  /**
   * ShopItemForSale.purchases
   */
  export type ShopItemForSale$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    where?: PurchasedItemWhereInput
    orderBy?: PurchasedItemOrderByWithRelationInput | PurchasedItemOrderByWithRelationInput[]
    cursor?: PurchasedItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasedItemScalarFieldEnum | PurchasedItemScalarFieldEnum[]
  }

  /**
   * ShopItemForSale without action
   */
  export type ShopItemForSaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForSale
     */
    select?: ShopItemForSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForSale
     */
    omit?: ShopItemForSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForSaleInclude<ExtArgs> | null
  }


  /**
   * Model ShopItemForRent
   */

  export type AggregateShopItemForRent = {
    _count: ShopItemForRentCountAggregateOutputType | null
    _avg: ShopItemForRentAvgAggregateOutputType | null
    _sum: ShopItemForRentSumAggregateOutputType | null
    _min: ShopItemForRentMinAggregateOutputType | null
    _max: ShopItemForRentMaxAggregateOutputType | null
  }

  export type ShopItemForRentAvgAggregateOutputType = {
    rentPrice: number | null
    rentPeriod: number | null
  }

  export type ShopItemForRentSumAggregateOutputType = {
    rentPrice: number | null
    rentPeriod: number | null
  }

  export type ShopItemForRentMinAggregateOutputType = {
    id: string | null
    itemType: $Enums.ShopItemTypeEnum | null
    itemId: string | null
    rentPrice: number | null
    rentPeriod: number | null
    currency: $Enums.CurrencyTypeEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    isVisible: boolean | null
  }

  export type ShopItemForRentMaxAggregateOutputType = {
    id: string | null
    itemType: $Enums.ShopItemTypeEnum | null
    itemId: string | null
    rentPrice: number | null
    rentPeriod: number | null
    currency: $Enums.CurrencyTypeEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    isVisible: boolean | null
  }

  export type ShopItemForRentCountAggregateOutputType = {
    id: number
    itemType: number
    itemId: number
    rentPrice: number
    rentPeriod: number
    currency: number
    createdAt: number
    updatedAt: number
    isVisible: number
    _all: number
  }


  export type ShopItemForRentAvgAggregateInputType = {
    rentPrice?: true
    rentPeriod?: true
  }

  export type ShopItemForRentSumAggregateInputType = {
    rentPrice?: true
    rentPeriod?: true
  }

  export type ShopItemForRentMinAggregateInputType = {
    id?: true
    itemType?: true
    itemId?: true
    rentPrice?: true
    rentPeriod?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    isVisible?: true
  }

  export type ShopItemForRentMaxAggregateInputType = {
    id?: true
    itemType?: true
    itemId?: true
    rentPrice?: true
    rentPeriod?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    isVisible?: true
  }

  export type ShopItemForRentCountAggregateInputType = {
    id?: true
    itemType?: true
    itemId?: true
    rentPrice?: true
    rentPeriod?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    isVisible?: true
    _all?: true
  }

  export type ShopItemForRentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItemForRent to aggregate.
     */
    where?: ShopItemForRentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItemForRents to fetch.
     */
    orderBy?: ShopItemForRentOrderByWithRelationInput | ShopItemForRentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopItemForRentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItemForRents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItemForRents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopItemForRents
    **/
    _count?: true | ShopItemForRentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopItemForRentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopItemForRentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopItemForRentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopItemForRentMaxAggregateInputType
  }

  export type GetShopItemForRentAggregateType<T extends ShopItemForRentAggregateArgs> = {
        [P in keyof T & keyof AggregateShopItemForRent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopItemForRent[P]>
      : GetScalarType<T[P], AggregateShopItemForRent[P]>
  }




  export type ShopItemForRentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemForRentWhereInput
    orderBy?: ShopItemForRentOrderByWithAggregationInput | ShopItemForRentOrderByWithAggregationInput[]
    by: ShopItemForRentScalarFieldEnum[] | ShopItemForRentScalarFieldEnum
    having?: ShopItemForRentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopItemForRentCountAggregateInputType | true
    _avg?: ShopItemForRentAvgAggregateInputType
    _sum?: ShopItemForRentSumAggregateInputType
    _min?: ShopItemForRentMinAggregateInputType
    _max?: ShopItemForRentMaxAggregateInputType
  }

  export type ShopItemForRentGroupByOutputType = {
    id: string
    itemType: $Enums.ShopItemTypeEnum
    itemId: string
    rentPrice: number
    rentPeriod: number
    currency: $Enums.CurrencyTypeEnum
    createdAt: Date
    updatedAt: Date
    isVisible: boolean
    _count: ShopItemForRentCountAggregateOutputType | null
    _avg: ShopItemForRentAvgAggregateOutputType | null
    _sum: ShopItemForRentSumAggregateOutputType | null
    _min: ShopItemForRentMinAggregateOutputType | null
    _max: ShopItemForRentMaxAggregateOutputType | null
  }

  type GetShopItemForRentGroupByPayload<T extends ShopItemForRentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopItemForRentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopItemForRentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopItemForRentGroupByOutputType[P]>
            : GetScalarType<T[P], ShopItemForRentGroupByOutputType[P]>
        }
      >
    >


  export type ShopItemForRentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemType?: boolean
    itemId?: boolean
    rentPrice?: boolean
    rentPeriod?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isVisible?: boolean
    course?: boolean | ShopItemForRent$courseArgs<ExtArgs>
    module?: boolean | ShopItemForRent$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForRent$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForRent$examArgs<ExtArgs>
    material?: boolean | ShopItemForRent$materialArgs<ExtArgs>
    rentalPeriods?: boolean | ShopItemForRent$rentalPeriodsArgs<ExtArgs>
    _count?: boolean | ShopItemForRentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopItemForRent"]>

  export type ShopItemForRentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemType?: boolean
    itemId?: boolean
    rentPrice?: boolean
    rentPeriod?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isVisible?: boolean
    course?: boolean | ShopItemForRent$courseArgs<ExtArgs>
    module?: boolean | ShopItemForRent$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForRent$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForRent$examArgs<ExtArgs>
    material?: boolean | ShopItemForRent$materialArgs<ExtArgs>
  }, ExtArgs["result"]["shopItemForRent"]>

  export type ShopItemForRentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemType?: boolean
    itemId?: boolean
    rentPrice?: boolean
    rentPeriod?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isVisible?: boolean
    course?: boolean | ShopItemForRent$courseArgs<ExtArgs>
    module?: boolean | ShopItemForRent$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForRent$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForRent$examArgs<ExtArgs>
    material?: boolean | ShopItemForRent$materialArgs<ExtArgs>
  }, ExtArgs["result"]["shopItemForRent"]>

  export type ShopItemForRentSelectScalar = {
    id?: boolean
    itemType?: boolean
    itemId?: boolean
    rentPrice?: boolean
    rentPeriod?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isVisible?: boolean
  }

  export type ShopItemForRentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemType" | "itemId" | "rentPrice" | "rentPeriod" | "currency" | "createdAt" | "updatedAt" | "isVisible", ExtArgs["result"]["shopItemForRent"]>
  export type ShopItemForRentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | ShopItemForRent$courseArgs<ExtArgs>
    module?: boolean | ShopItemForRent$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForRent$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForRent$examArgs<ExtArgs>
    material?: boolean | ShopItemForRent$materialArgs<ExtArgs>
    rentalPeriods?: boolean | ShopItemForRent$rentalPeriodsArgs<ExtArgs>
    _count?: boolean | ShopItemForRentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShopItemForRentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | ShopItemForRent$courseArgs<ExtArgs>
    module?: boolean | ShopItemForRent$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForRent$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForRent$examArgs<ExtArgs>
    material?: boolean | ShopItemForRent$materialArgs<ExtArgs>
  }
  export type ShopItemForRentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | ShopItemForRent$courseArgs<ExtArgs>
    module?: boolean | ShopItemForRent$moduleArgs<ExtArgs>
    exercise?: boolean | ShopItemForRent$exerciseArgs<ExtArgs>
    exam?: boolean | ShopItemForRent$examArgs<ExtArgs>
    material?: boolean | ShopItemForRent$materialArgs<ExtArgs>
  }

  export type $ShopItemForRentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopItemForRent"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      module: Prisma.$ModulePayload<ExtArgs> | null
      exercise: Prisma.$ExercisePayload<ExtArgs> | null
      exam: Prisma.$ExamPayload<ExtArgs> | null
      material: Prisma.$MaterialPayload<ExtArgs> | null
      rentalPeriods: Prisma.$RentalPeriodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemType: $Enums.ShopItemTypeEnum
      itemId: string
      rentPrice: number
      rentPeriod: number
      currency: $Enums.CurrencyTypeEnum
      createdAt: Date
      updatedAt: Date
      isVisible: boolean
    }, ExtArgs["result"]["shopItemForRent"]>
    composites: {}
  }

  type ShopItemForRentGetPayload<S extends boolean | null | undefined | ShopItemForRentDefaultArgs> = $Result.GetResult<Prisma.$ShopItemForRentPayload, S>

  type ShopItemForRentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopItemForRentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopItemForRentCountAggregateInputType | true
    }

  export interface ShopItemForRentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopItemForRent'], meta: { name: 'ShopItemForRent' } }
    /**
     * Find zero or one ShopItemForRent that matches the filter.
     * @param {ShopItemForRentFindUniqueArgs} args - Arguments to find a ShopItemForRent
     * @example
     * // Get one ShopItemForRent
     * const shopItemForRent = await prisma.shopItemForRent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopItemForRentFindUniqueArgs>(args: SelectSubset<T, ShopItemForRentFindUniqueArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ShopItemForRent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopItemForRentFindUniqueOrThrowArgs} args - Arguments to find a ShopItemForRent
     * @example
     * // Get one ShopItemForRent
     * const shopItemForRent = await prisma.shopItemForRent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopItemForRentFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopItemForRentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ShopItemForRent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForRentFindFirstArgs} args - Arguments to find a ShopItemForRent
     * @example
     * // Get one ShopItemForRent
     * const shopItemForRent = await prisma.shopItemForRent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopItemForRentFindFirstArgs>(args?: SelectSubset<T, ShopItemForRentFindFirstArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ShopItemForRent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForRentFindFirstOrThrowArgs} args - Arguments to find a ShopItemForRent
     * @example
     * // Get one ShopItemForRent
     * const shopItemForRent = await prisma.shopItemForRent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopItemForRentFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopItemForRentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ShopItemForRents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForRentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopItemForRents
     * const shopItemForRents = await prisma.shopItemForRent.findMany()
     * 
     * // Get first 10 ShopItemForRents
     * const shopItemForRents = await prisma.shopItemForRent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopItemForRentWithIdOnly = await prisma.shopItemForRent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopItemForRentFindManyArgs>(args?: SelectSubset<T, ShopItemForRentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ShopItemForRent.
     * @param {ShopItemForRentCreateArgs} args - Arguments to create a ShopItemForRent.
     * @example
     * // Create one ShopItemForRent
     * const ShopItemForRent = await prisma.shopItemForRent.create({
     *   data: {
     *     // ... data to create a ShopItemForRent
     *   }
     * })
     * 
     */
    create<T extends ShopItemForRentCreateArgs>(args: SelectSubset<T, ShopItemForRentCreateArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ShopItemForRents.
     * @param {ShopItemForRentCreateManyArgs} args - Arguments to create many ShopItemForRents.
     * @example
     * // Create many ShopItemForRents
     * const shopItemForRent = await prisma.shopItemForRent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopItemForRentCreateManyArgs>(args?: SelectSubset<T, ShopItemForRentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopItemForRents and returns the data saved in the database.
     * @param {ShopItemForRentCreateManyAndReturnArgs} args - Arguments to create many ShopItemForRents.
     * @example
     * // Create many ShopItemForRents
     * const shopItemForRent = await prisma.shopItemForRent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopItemForRents and only return the `id`
     * const shopItemForRentWithIdOnly = await prisma.shopItemForRent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopItemForRentCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopItemForRentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ShopItemForRent.
     * @param {ShopItemForRentDeleteArgs} args - Arguments to delete one ShopItemForRent.
     * @example
     * // Delete one ShopItemForRent
     * const ShopItemForRent = await prisma.shopItemForRent.delete({
     *   where: {
     *     // ... filter to delete one ShopItemForRent
     *   }
     * })
     * 
     */
    delete<T extends ShopItemForRentDeleteArgs>(args: SelectSubset<T, ShopItemForRentDeleteArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ShopItemForRent.
     * @param {ShopItemForRentUpdateArgs} args - Arguments to update one ShopItemForRent.
     * @example
     * // Update one ShopItemForRent
     * const shopItemForRent = await prisma.shopItemForRent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopItemForRentUpdateArgs>(args: SelectSubset<T, ShopItemForRentUpdateArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ShopItemForRents.
     * @param {ShopItemForRentDeleteManyArgs} args - Arguments to filter ShopItemForRents to delete.
     * @example
     * // Delete a few ShopItemForRents
     * const { count } = await prisma.shopItemForRent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopItemForRentDeleteManyArgs>(args?: SelectSubset<T, ShopItemForRentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopItemForRents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForRentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopItemForRents
     * const shopItemForRent = await prisma.shopItemForRent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopItemForRentUpdateManyArgs>(args: SelectSubset<T, ShopItemForRentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopItemForRents and returns the data updated in the database.
     * @param {ShopItemForRentUpdateManyAndReturnArgs} args - Arguments to update many ShopItemForRents.
     * @example
     * // Update many ShopItemForRents
     * const shopItemForRent = await prisma.shopItemForRent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShopItemForRents and only return the `id`
     * const shopItemForRentWithIdOnly = await prisma.shopItemForRent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopItemForRentUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopItemForRentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ShopItemForRent.
     * @param {ShopItemForRentUpsertArgs} args - Arguments to update or create a ShopItemForRent.
     * @example
     * // Update or create a ShopItemForRent
     * const shopItemForRent = await prisma.shopItemForRent.upsert({
     *   create: {
     *     // ... data to create a ShopItemForRent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopItemForRent we want to update
     *   }
     * })
     */
    upsert<T extends ShopItemForRentUpsertArgs>(args: SelectSubset<T, ShopItemForRentUpsertArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ShopItemForRents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForRentCountArgs} args - Arguments to filter ShopItemForRents to count.
     * @example
     * // Count the number of ShopItemForRents
     * const count = await prisma.shopItemForRent.count({
     *   where: {
     *     // ... the filter for the ShopItemForRents we want to count
     *   }
     * })
    **/
    count<T extends ShopItemForRentCountArgs>(
      args?: Subset<T, ShopItemForRentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopItemForRentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopItemForRent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForRentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopItemForRentAggregateArgs>(args: Subset<T, ShopItemForRentAggregateArgs>): Prisma.PrismaPromise<GetShopItemForRentAggregateType<T>>

    /**
     * Group by ShopItemForRent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemForRentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopItemForRentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopItemForRentGroupByArgs['orderBy'] }
        : { orderBy?: ShopItemForRentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopItemForRentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopItemForRentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopItemForRent model
   */
  readonly fields: ShopItemForRentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopItemForRent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopItemForRentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends ShopItemForRent$courseArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForRent$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    module<T extends ShopItemForRent$moduleArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForRent$moduleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    exercise<T extends ShopItemForRent$exerciseArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForRent$exerciseArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    exam<T extends ShopItemForRent$examArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForRent$examArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    material<T extends ShopItemForRent$materialArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForRent$materialArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    rentalPeriods<T extends ShopItemForRent$rentalPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForRent$rentalPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopItemForRent model
   */ 
  interface ShopItemForRentFieldRefs {
    readonly id: FieldRef<"ShopItemForRent", 'String'>
    readonly itemType: FieldRef<"ShopItemForRent", 'ShopItemTypeEnum'>
    readonly itemId: FieldRef<"ShopItemForRent", 'String'>
    readonly rentPrice: FieldRef<"ShopItemForRent", 'Int'>
    readonly rentPeriod: FieldRef<"ShopItemForRent", 'Int'>
    readonly currency: FieldRef<"ShopItemForRent", 'CurrencyTypeEnum'>
    readonly createdAt: FieldRef<"ShopItemForRent", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopItemForRent", 'DateTime'>
    readonly isVisible: FieldRef<"ShopItemForRent", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ShopItemForRent findUnique
   */
  export type ShopItemForRentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    /**
     * Filter, which ShopItemForRent to fetch.
     */
    where: ShopItemForRentWhereUniqueInput
  }

  /**
   * ShopItemForRent findUniqueOrThrow
   */
  export type ShopItemForRentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    /**
     * Filter, which ShopItemForRent to fetch.
     */
    where: ShopItemForRentWhereUniqueInput
  }

  /**
   * ShopItemForRent findFirst
   */
  export type ShopItemForRentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    /**
     * Filter, which ShopItemForRent to fetch.
     */
    where?: ShopItemForRentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItemForRents to fetch.
     */
    orderBy?: ShopItemForRentOrderByWithRelationInput | ShopItemForRentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItemForRents.
     */
    cursor?: ShopItemForRentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItemForRents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItemForRents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItemForRents.
     */
    distinct?: ShopItemForRentScalarFieldEnum | ShopItemForRentScalarFieldEnum[]
  }

  /**
   * ShopItemForRent findFirstOrThrow
   */
  export type ShopItemForRentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    /**
     * Filter, which ShopItemForRent to fetch.
     */
    where?: ShopItemForRentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItemForRents to fetch.
     */
    orderBy?: ShopItemForRentOrderByWithRelationInput | ShopItemForRentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItemForRents.
     */
    cursor?: ShopItemForRentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItemForRents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItemForRents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItemForRents.
     */
    distinct?: ShopItemForRentScalarFieldEnum | ShopItemForRentScalarFieldEnum[]
  }

  /**
   * ShopItemForRent findMany
   */
  export type ShopItemForRentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    /**
     * Filter, which ShopItemForRents to fetch.
     */
    where?: ShopItemForRentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItemForRents to fetch.
     */
    orderBy?: ShopItemForRentOrderByWithRelationInput | ShopItemForRentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopItemForRents.
     */
    cursor?: ShopItemForRentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItemForRents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItemForRents.
     */
    skip?: number
    distinct?: ShopItemForRentScalarFieldEnum | ShopItemForRentScalarFieldEnum[]
  }

  /**
   * ShopItemForRent create
   */
  export type ShopItemForRentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopItemForRent.
     */
    data: XOR<ShopItemForRentCreateInput, ShopItemForRentUncheckedCreateInput>
  }

  /**
   * ShopItemForRent createMany
   */
  export type ShopItemForRentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopItemForRents.
     */
    data: ShopItemForRentCreateManyInput | ShopItemForRentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopItemForRent createManyAndReturn
   */
  export type ShopItemForRentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * The data used to create many ShopItemForRents.
     */
    data: ShopItemForRentCreateManyInput | ShopItemForRentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopItemForRent update
   */
  export type ShopItemForRentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopItemForRent.
     */
    data: XOR<ShopItemForRentUpdateInput, ShopItemForRentUncheckedUpdateInput>
    /**
     * Choose, which ShopItemForRent to update.
     */
    where: ShopItemForRentWhereUniqueInput
  }

  /**
   * ShopItemForRent updateMany
   */
  export type ShopItemForRentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopItemForRents.
     */
    data: XOR<ShopItemForRentUpdateManyMutationInput, ShopItemForRentUncheckedUpdateManyInput>
    /**
     * Filter which ShopItemForRents to update
     */
    where?: ShopItemForRentWhereInput
    /**
     * Limit how many ShopItemForRents to update.
     */
    limit?: number
  }

  /**
   * ShopItemForRent updateManyAndReturn
   */
  export type ShopItemForRentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * The data used to update ShopItemForRents.
     */
    data: XOR<ShopItemForRentUpdateManyMutationInput, ShopItemForRentUncheckedUpdateManyInput>
    /**
     * Filter which ShopItemForRents to update
     */
    where?: ShopItemForRentWhereInput
    /**
     * Limit how many ShopItemForRents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopItemForRent upsert
   */
  export type ShopItemForRentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopItemForRent to update in case it exists.
     */
    where: ShopItemForRentWhereUniqueInput
    /**
     * In case the ShopItemForRent found by the `where` argument doesn't exist, create a new ShopItemForRent with this data.
     */
    create: XOR<ShopItemForRentCreateInput, ShopItemForRentUncheckedCreateInput>
    /**
     * In case the ShopItemForRent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopItemForRentUpdateInput, ShopItemForRentUncheckedUpdateInput>
  }

  /**
   * ShopItemForRent delete
   */
  export type ShopItemForRentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
    /**
     * Filter which ShopItemForRent to delete.
     */
    where: ShopItemForRentWhereUniqueInput
  }

  /**
   * ShopItemForRent deleteMany
   */
  export type ShopItemForRentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItemForRents to delete
     */
    where?: ShopItemForRentWhereInput
    /**
     * Limit how many ShopItemForRents to delete.
     */
    limit?: number
  }

  /**
   * ShopItemForRent.course
   */
  export type ShopItemForRent$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * ShopItemForRent.module
   */
  export type ShopItemForRent$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * ShopItemForRent.exercise
   */
  export type ShopItemForRent$exerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
  }

  /**
   * ShopItemForRent.exam
   */
  export type ShopItemForRent$examArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
  }

  /**
   * ShopItemForRent.material
   */
  export type ShopItemForRent$materialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
  }

  /**
   * ShopItemForRent.rentalPeriods
   */
  export type ShopItemForRent$rentalPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    where?: RentalPeriodWhereInput
    orderBy?: RentalPeriodOrderByWithRelationInput | RentalPeriodOrderByWithRelationInput[]
    cursor?: RentalPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalPeriodScalarFieldEnum | RentalPeriodScalarFieldEnum[]
  }

  /**
   * ShopItemForRent without action
   */
  export type ShopItemForRentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItemForRent
     */
    select?: ShopItemForRentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItemForRent
     */
    omit?: ShopItemForRentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemForRentInclude<ExtArgs> | null
  }


  /**
   * Model PurchasedItem
   */

  export type AggregatePurchasedItem = {
    _count: PurchasedItemCountAggregateOutputType | null
    _min: PurchasedItemMinAggregateOutputType | null
    _max: PurchasedItemMaxAggregateOutputType | null
  }

  export type PurchasedItemMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    shopItemId: string | null
    purchaseDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasedItemMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    shopItemId: string | null
    purchaseDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasedItemCountAggregateOutputType = {
    id: number
    teacherId: number
    shopItemId: number
    purchaseDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchasedItemMinAggregateInputType = {
    id?: true
    teacherId?: true
    shopItemId?: true
    purchaseDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasedItemMaxAggregateInputType = {
    id?: true
    teacherId?: true
    shopItemId?: true
    purchaseDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasedItemCountAggregateInputType = {
    id?: true
    teacherId?: true
    shopItemId?: true
    purchaseDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchasedItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasedItem to aggregate.
     */
    where?: PurchasedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasedItems to fetch.
     */
    orderBy?: PurchasedItemOrderByWithRelationInput | PurchasedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasedItems
    **/
    _count?: true | PurchasedItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasedItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasedItemMaxAggregateInputType
  }

  export type GetPurchasedItemAggregateType<T extends PurchasedItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasedItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasedItem[P]>
      : GetScalarType<T[P], AggregatePurchasedItem[P]>
  }




  export type PurchasedItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasedItemWhereInput
    orderBy?: PurchasedItemOrderByWithAggregationInput | PurchasedItemOrderByWithAggregationInput[]
    by: PurchasedItemScalarFieldEnum[] | PurchasedItemScalarFieldEnum
    having?: PurchasedItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasedItemCountAggregateInputType | true
    _min?: PurchasedItemMinAggregateInputType
    _max?: PurchasedItemMaxAggregateInputType
  }

  export type PurchasedItemGroupByOutputType = {
    id: string
    teacherId: string
    shopItemId: string
    purchaseDate: Date
    createdAt: Date
    updatedAt: Date
    _count: PurchasedItemCountAggregateOutputType | null
    _min: PurchasedItemMinAggregateOutputType | null
    _max: PurchasedItemMaxAggregateOutputType | null
  }

  type GetPurchasedItemGroupByPayload<T extends PurchasedItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasedItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasedItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasedItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasedItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchasedItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    shopItemId?: boolean
    purchaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasedItem"]>

  export type PurchasedItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    shopItemId?: boolean
    purchaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasedItem"]>

  export type PurchasedItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    shopItemId?: boolean
    purchaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasedItem"]>

  export type PurchasedItemSelectScalar = {
    id?: boolean
    teacherId?: boolean
    shopItemId?: boolean
    purchaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchasedItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacherId" | "shopItemId" | "purchaseDate" | "createdAt" | "updatedAt", ExtArgs["result"]["purchasedItem"]>
  export type PurchasedItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForSaleDefaultArgs<ExtArgs>
  }
  export type PurchasedItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForSaleDefaultArgs<ExtArgs>
  }
  export type PurchasedItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForSaleDefaultArgs<ExtArgs>
  }

  export type $PurchasedItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasedItem"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      shopItem: Prisma.$ShopItemForSalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      shopItemId: string
      purchaseDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchasedItem"]>
    composites: {}
  }

  type PurchasedItemGetPayload<S extends boolean | null | undefined | PurchasedItemDefaultArgs> = $Result.GetResult<Prisma.$PurchasedItemPayload, S>

  type PurchasedItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasedItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasedItemCountAggregateInputType | true
    }

  export interface PurchasedItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasedItem'], meta: { name: 'PurchasedItem' } }
    /**
     * Find zero or one PurchasedItem that matches the filter.
     * @param {PurchasedItemFindUniqueArgs} args - Arguments to find a PurchasedItem
     * @example
     * // Get one PurchasedItem
     * const purchasedItem = await prisma.purchasedItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasedItemFindUniqueArgs>(args: SelectSubset<T, PurchasedItemFindUniqueArgs<ExtArgs>>): Prisma__PurchasedItemClient<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PurchasedItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasedItemFindUniqueOrThrowArgs} args - Arguments to find a PurchasedItem
     * @example
     * // Get one PurchasedItem
     * const purchasedItem = await prisma.purchasedItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasedItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasedItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasedItemClient<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PurchasedItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasedItemFindFirstArgs} args - Arguments to find a PurchasedItem
     * @example
     * // Get one PurchasedItem
     * const purchasedItem = await prisma.purchasedItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasedItemFindFirstArgs>(args?: SelectSubset<T, PurchasedItemFindFirstArgs<ExtArgs>>): Prisma__PurchasedItemClient<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PurchasedItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasedItemFindFirstOrThrowArgs} args - Arguments to find a PurchasedItem
     * @example
     * // Get one PurchasedItem
     * const purchasedItem = await prisma.purchasedItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasedItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasedItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasedItemClient<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PurchasedItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasedItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasedItems
     * const purchasedItems = await prisma.purchasedItem.findMany()
     * 
     * // Get first 10 PurchasedItems
     * const purchasedItems = await prisma.purchasedItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasedItemWithIdOnly = await prisma.purchasedItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasedItemFindManyArgs>(args?: SelectSubset<T, PurchasedItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PurchasedItem.
     * @param {PurchasedItemCreateArgs} args - Arguments to create a PurchasedItem.
     * @example
     * // Create one PurchasedItem
     * const PurchasedItem = await prisma.purchasedItem.create({
     *   data: {
     *     // ... data to create a PurchasedItem
     *   }
     * })
     * 
     */
    create<T extends PurchasedItemCreateArgs>(args: SelectSubset<T, PurchasedItemCreateArgs<ExtArgs>>): Prisma__PurchasedItemClient<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PurchasedItems.
     * @param {PurchasedItemCreateManyArgs} args - Arguments to create many PurchasedItems.
     * @example
     * // Create many PurchasedItems
     * const purchasedItem = await prisma.purchasedItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasedItemCreateManyArgs>(args?: SelectSubset<T, PurchasedItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasedItems and returns the data saved in the database.
     * @param {PurchasedItemCreateManyAndReturnArgs} args - Arguments to create many PurchasedItems.
     * @example
     * // Create many PurchasedItems
     * const purchasedItem = await prisma.purchasedItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasedItems and only return the `id`
     * const purchasedItemWithIdOnly = await prisma.purchasedItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasedItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasedItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PurchasedItem.
     * @param {PurchasedItemDeleteArgs} args - Arguments to delete one PurchasedItem.
     * @example
     * // Delete one PurchasedItem
     * const PurchasedItem = await prisma.purchasedItem.delete({
     *   where: {
     *     // ... filter to delete one PurchasedItem
     *   }
     * })
     * 
     */
    delete<T extends PurchasedItemDeleteArgs>(args: SelectSubset<T, PurchasedItemDeleteArgs<ExtArgs>>): Prisma__PurchasedItemClient<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PurchasedItem.
     * @param {PurchasedItemUpdateArgs} args - Arguments to update one PurchasedItem.
     * @example
     * // Update one PurchasedItem
     * const purchasedItem = await prisma.purchasedItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasedItemUpdateArgs>(args: SelectSubset<T, PurchasedItemUpdateArgs<ExtArgs>>): Prisma__PurchasedItemClient<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PurchasedItems.
     * @param {PurchasedItemDeleteManyArgs} args - Arguments to filter PurchasedItems to delete.
     * @example
     * // Delete a few PurchasedItems
     * const { count } = await prisma.purchasedItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasedItemDeleteManyArgs>(args?: SelectSubset<T, PurchasedItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasedItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasedItems
     * const purchasedItem = await prisma.purchasedItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasedItemUpdateManyArgs>(args: SelectSubset<T, PurchasedItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasedItems and returns the data updated in the database.
     * @param {PurchasedItemUpdateManyAndReturnArgs} args - Arguments to update many PurchasedItems.
     * @example
     * // Update many PurchasedItems
     * const purchasedItem = await prisma.purchasedItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchasedItems and only return the `id`
     * const purchasedItemWithIdOnly = await prisma.purchasedItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasedItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasedItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PurchasedItem.
     * @param {PurchasedItemUpsertArgs} args - Arguments to update or create a PurchasedItem.
     * @example
     * // Update or create a PurchasedItem
     * const purchasedItem = await prisma.purchasedItem.upsert({
     *   create: {
     *     // ... data to create a PurchasedItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasedItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchasedItemUpsertArgs>(args: SelectSubset<T, PurchasedItemUpsertArgs<ExtArgs>>): Prisma__PurchasedItemClient<$Result.GetResult<Prisma.$PurchasedItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PurchasedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasedItemCountArgs} args - Arguments to filter PurchasedItems to count.
     * @example
     * // Count the number of PurchasedItems
     * const count = await prisma.purchasedItem.count({
     *   where: {
     *     // ... the filter for the PurchasedItems we want to count
     *   }
     * })
    **/
    count<T extends PurchasedItemCountArgs>(
      args?: Subset<T, PurchasedItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasedItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasedItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasedItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasedItemAggregateArgs>(args: Subset<T, PurchasedItemAggregateArgs>): Prisma.PrismaPromise<GetPurchasedItemAggregateType<T>>

    /**
     * Group by PurchasedItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasedItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasedItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasedItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchasedItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasedItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasedItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasedItem model
   */
  readonly fields: PurchasedItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasedItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasedItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    shopItem<T extends ShopItemForSaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForSaleDefaultArgs<ExtArgs>>): Prisma__ShopItemForSaleClient<$Result.GetResult<Prisma.$ShopItemForSalePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasedItem model
   */ 
  interface PurchasedItemFieldRefs {
    readonly id: FieldRef<"PurchasedItem", 'String'>
    readonly teacherId: FieldRef<"PurchasedItem", 'String'>
    readonly shopItemId: FieldRef<"PurchasedItem", 'String'>
    readonly purchaseDate: FieldRef<"PurchasedItem", 'DateTime'>
    readonly createdAt: FieldRef<"PurchasedItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchasedItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchasedItem findUnique
   */
  export type PurchasedItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasedItem to fetch.
     */
    where: PurchasedItemWhereUniqueInput
  }

  /**
   * PurchasedItem findUniqueOrThrow
   */
  export type PurchasedItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasedItem to fetch.
     */
    where: PurchasedItemWhereUniqueInput
  }

  /**
   * PurchasedItem findFirst
   */
  export type PurchasedItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasedItem to fetch.
     */
    where?: PurchasedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasedItems to fetch.
     */
    orderBy?: PurchasedItemOrderByWithRelationInput | PurchasedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasedItems.
     */
    cursor?: PurchasedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasedItems.
     */
    distinct?: PurchasedItemScalarFieldEnum | PurchasedItemScalarFieldEnum[]
  }

  /**
   * PurchasedItem findFirstOrThrow
   */
  export type PurchasedItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasedItem to fetch.
     */
    where?: PurchasedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasedItems to fetch.
     */
    orderBy?: PurchasedItemOrderByWithRelationInput | PurchasedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasedItems.
     */
    cursor?: PurchasedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasedItems.
     */
    distinct?: PurchasedItemScalarFieldEnum | PurchasedItemScalarFieldEnum[]
  }

  /**
   * PurchasedItem findMany
   */
  export type PurchasedItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchasedItems to fetch.
     */
    where?: PurchasedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasedItems to fetch.
     */
    orderBy?: PurchasedItemOrderByWithRelationInput | PurchasedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasedItems.
     */
    cursor?: PurchasedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasedItems.
     */
    skip?: number
    distinct?: PurchasedItemScalarFieldEnum | PurchasedItemScalarFieldEnum[]
  }

  /**
   * PurchasedItem create
   */
  export type PurchasedItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasedItem.
     */
    data: XOR<PurchasedItemCreateInput, PurchasedItemUncheckedCreateInput>
  }

  /**
   * PurchasedItem createMany
   */
  export type PurchasedItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasedItems.
     */
    data: PurchasedItemCreateManyInput | PurchasedItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasedItem createManyAndReturn
   */
  export type PurchasedItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchasedItems.
     */
    data: PurchasedItemCreateManyInput | PurchasedItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasedItem update
   */
  export type PurchasedItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasedItem.
     */
    data: XOR<PurchasedItemUpdateInput, PurchasedItemUncheckedUpdateInput>
    /**
     * Choose, which PurchasedItem to update.
     */
    where: PurchasedItemWhereUniqueInput
  }

  /**
   * PurchasedItem updateMany
   */
  export type PurchasedItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasedItems.
     */
    data: XOR<PurchasedItemUpdateManyMutationInput, PurchasedItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchasedItems to update
     */
    where?: PurchasedItemWhereInput
    /**
     * Limit how many PurchasedItems to update.
     */
    limit?: number
  }

  /**
   * PurchasedItem updateManyAndReturn
   */
  export type PurchasedItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchasedItems.
     */
    data: XOR<PurchasedItemUpdateManyMutationInput, PurchasedItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchasedItems to update
     */
    where?: PurchasedItemWhereInput
    /**
     * Limit how many PurchasedItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasedItem upsert
   */
  export type PurchasedItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasedItem to update in case it exists.
     */
    where: PurchasedItemWhereUniqueInput
    /**
     * In case the PurchasedItem found by the `where` argument doesn't exist, create a new PurchasedItem with this data.
     */
    create: XOR<PurchasedItemCreateInput, PurchasedItemUncheckedCreateInput>
    /**
     * In case the PurchasedItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasedItemUpdateInput, PurchasedItemUncheckedUpdateInput>
  }

  /**
   * PurchasedItem delete
   */
  export type PurchasedItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
    /**
     * Filter which PurchasedItem to delete.
     */
    where: PurchasedItemWhereUniqueInput
  }

  /**
   * PurchasedItem deleteMany
   */
  export type PurchasedItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasedItems to delete
     */
    where?: PurchasedItemWhereInput
    /**
     * Limit how many PurchasedItems to delete.
     */
    limit?: number
  }

  /**
   * PurchasedItem without action
   */
  export type PurchasedItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasedItem
     */
    select?: PurchasedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasedItem
     */
    omit?: PurchasedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasedItemInclude<ExtArgs> | null
  }


  /**
   * Model RentalPeriod
   */

  export type AggregateRentalPeriod = {
    _count: RentalPeriodCountAggregateOutputType | null
    _min: RentalPeriodMinAggregateOutputType | null
    _max: RentalPeriodMaxAggregateOutputType | null
  }

  export type RentalPeriodMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    shopItemId: string | null
    rentStartDate: Date | null
    rentEndDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type RentalPeriodMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    shopItemId: string | null
    rentStartDate: Date | null
    rentEndDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type RentalPeriodCountAggregateOutputType = {
    id: number
    teacherId: number
    shopItemId: number
    rentStartDate: number
    rentEndDate: number
    createdAt: number
    updatedAt: number
    isActive: number
    _all: number
  }


  export type RentalPeriodMinAggregateInputType = {
    id?: true
    teacherId?: true
    shopItemId?: true
    rentStartDate?: true
    rentEndDate?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type RentalPeriodMaxAggregateInputType = {
    id?: true
    teacherId?: true
    shopItemId?: true
    rentStartDate?: true
    rentEndDate?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type RentalPeriodCountAggregateInputType = {
    id?: true
    teacherId?: true
    shopItemId?: true
    rentStartDate?: true
    rentEndDate?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    _all?: true
  }

  export type RentalPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalPeriod to aggregate.
     */
    where?: RentalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPeriods to fetch.
     */
    orderBy?: RentalPeriodOrderByWithRelationInput | RentalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RentalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RentalPeriods
    **/
    _count?: true | RentalPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RentalPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RentalPeriodMaxAggregateInputType
  }

  export type GetRentalPeriodAggregateType<T extends RentalPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateRentalPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRentalPeriod[P]>
      : GetScalarType<T[P], AggregateRentalPeriod[P]>
  }




  export type RentalPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalPeriodWhereInput
    orderBy?: RentalPeriodOrderByWithAggregationInput | RentalPeriodOrderByWithAggregationInput[]
    by: RentalPeriodScalarFieldEnum[] | RentalPeriodScalarFieldEnum
    having?: RentalPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RentalPeriodCountAggregateInputType | true
    _min?: RentalPeriodMinAggregateInputType
    _max?: RentalPeriodMaxAggregateInputType
  }

  export type RentalPeriodGroupByOutputType = {
    id: string
    teacherId: string
    shopItemId: string
    rentStartDate: Date
    rentEndDate: Date
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    _count: RentalPeriodCountAggregateOutputType | null
    _min: RentalPeriodMinAggregateOutputType | null
    _max: RentalPeriodMaxAggregateOutputType | null
  }

  type GetRentalPeriodGroupByPayload<T extends RentalPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RentalPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RentalPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RentalPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], RentalPeriodGroupByOutputType[P]>
        }
      >
    >


  export type RentalPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    shopItemId?: boolean
    rentStartDate?: boolean
    rentEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForRentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalPeriod"]>

  export type RentalPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    shopItemId?: boolean
    rentStartDate?: boolean
    rentEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForRentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalPeriod"]>

  export type RentalPeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    shopItemId?: boolean
    rentStartDate?: boolean
    rentEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForRentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalPeriod"]>

  export type RentalPeriodSelectScalar = {
    id?: boolean
    teacherId?: boolean
    shopItemId?: boolean
    rentStartDate?: boolean
    rentEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }

  export type RentalPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacherId" | "shopItemId" | "rentStartDate" | "rentEndDate" | "createdAt" | "updatedAt" | "isActive", ExtArgs["result"]["rentalPeriod"]>
  export type RentalPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForRentDefaultArgs<ExtArgs>
  }
  export type RentalPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForRentDefaultArgs<ExtArgs>
  }
  export type RentalPeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    shopItem?: boolean | ShopItemForRentDefaultArgs<ExtArgs>
  }

  export type $RentalPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RentalPeriod"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      shopItem: Prisma.$ShopItemForRentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      shopItemId: string
      rentStartDate: Date
      rentEndDate: Date
      createdAt: Date
      updatedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["rentalPeriod"]>
    composites: {}
  }

  type RentalPeriodGetPayload<S extends boolean | null | undefined | RentalPeriodDefaultArgs> = $Result.GetResult<Prisma.$RentalPeriodPayload, S>

  type RentalPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RentalPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RentalPeriodCountAggregateInputType | true
    }

  export interface RentalPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RentalPeriod'], meta: { name: 'RentalPeriod' } }
    /**
     * Find zero or one RentalPeriod that matches the filter.
     * @param {RentalPeriodFindUniqueArgs} args - Arguments to find a RentalPeriod
     * @example
     * // Get one RentalPeriod
     * const rentalPeriod = await prisma.rentalPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RentalPeriodFindUniqueArgs>(args: SelectSubset<T, RentalPeriodFindUniqueArgs<ExtArgs>>): Prisma__RentalPeriodClient<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RentalPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RentalPeriodFindUniqueOrThrowArgs} args - Arguments to find a RentalPeriod
     * @example
     * // Get one RentalPeriod
     * const rentalPeriod = await prisma.rentalPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RentalPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, RentalPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RentalPeriodClient<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RentalPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPeriodFindFirstArgs} args - Arguments to find a RentalPeriod
     * @example
     * // Get one RentalPeriod
     * const rentalPeriod = await prisma.rentalPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RentalPeriodFindFirstArgs>(args?: SelectSubset<T, RentalPeriodFindFirstArgs<ExtArgs>>): Prisma__RentalPeriodClient<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RentalPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPeriodFindFirstOrThrowArgs} args - Arguments to find a RentalPeriod
     * @example
     * // Get one RentalPeriod
     * const rentalPeriod = await prisma.rentalPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RentalPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, RentalPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__RentalPeriodClient<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RentalPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RentalPeriods
     * const rentalPeriods = await prisma.rentalPeriod.findMany()
     * 
     * // Get first 10 RentalPeriods
     * const rentalPeriods = await prisma.rentalPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rentalPeriodWithIdOnly = await prisma.rentalPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RentalPeriodFindManyArgs>(args?: SelectSubset<T, RentalPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RentalPeriod.
     * @param {RentalPeriodCreateArgs} args - Arguments to create a RentalPeriod.
     * @example
     * // Create one RentalPeriod
     * const RentalPeriod = await prisma.rentalPeriod.create({
     *   data: {
     *     // ... data to create a RentalPeriod
     *   }
     * })
     * 
     */
    create<T extends RentalPeriodCreateArgs>(args: SelectSubset<T, RentalPeriodCreateArgs<ExtArgs>>): Prisma__RentalPeriodClient<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RentalPeriods.
     * @param {RentalPeriodCreateManyArgs} args - Arguments to create many RentalPeriods.
     * @example
     * // Create many RentalPeriods
     * const rentalPeriod = await prisma.rentalPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RentalPeriodCreateManyArgs>(args?: SelectSubset<T, RentalPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RentalPeriods and returns the data saved in the database.
     * @param {RentalPeriodCreateManyAndReturnArgs} args - Arguments to create many RentalPeriods.
     * @example
     * // Create many RentalPeriods
     * const rentalPeriod = await prisma.rentalPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RentalPeriods and only return the `id`
     * const rentalPeriodWithIdOnly = await prisma.rentalPeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RentalPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, RentalPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RentalPeriod.
     * @param {RentalPeriodDeleteArgs} args - Arguments to delete one RentalPeriod.
     * @example
     * // Delete one RentalPeriod
     * const RentalPeriod = await prisma.rentalPeriod.delete({
     *   where: {
     *     // ... filter to delete one RentalPeriod
     *   }
     * })
     * 
     */
    delete<T extends RentalPeriodDeleteArgs>(args: SelectSubset<T, RentalPeriodDeleteArgs<ExtArgs>>): Prisma__RentalPeriodClient<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RentalPeriod.
     * @param {RentalPeriodUpdateArgs} args - Arguments to update one RentalPeriod.
     * @example
     * // Update one RentalPeriod
     * const rentalPeriod = await prisma.rentalPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RentalPeriodUpdateArgs>(args: SelectSubset<T, RentalPeriodUpdateArgs<ExtArgs>>): Prisma__RentalPeriodClient<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RentalPeriods.
     * @param {RentalPeriodDeleteManyArgs} args - Arguments to filter RentalPeriods to delete.
     * @example
     * // Delete a few RentalPeriods
     * const { count } = await prisma.rentalPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RentalPeriodDeleteManyArgs>(args?: SelectSubset<T, RentalPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RentalPeriods
     * const rentalPeriod = await prisma.rentalPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RentalPeriodUpdateManyArgs>(args: SelectSubset<T, RentalPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalPeriods and returns the data updated in the database.
     * @param {RentalPeriodUpdateManyAndReturnArgs} args - Arguments to update many RentalPeriods.
     * @example
     * // Update many RentalPeriods
     * const rentalPeriod = await prisma.rentalPeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RentalPeriods and only return the `id`
     * const rentalPeriodWithIdOnly = await prisma.rentalPeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RentalPeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, RentalPeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one RentalPeriod.
     * @param {RentalPeriodUpsertArgs} args - Arguments to update or create a RentalPeriod.
     * @example
     * // Update or create a RentalPeriod
     * const rentalPeriod = await prisma.rentalPeriod.upsert({
     *   create: {
     *     // ... data to create a RentalPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RentalPeriod we want to update
     *   }
     * })
     */
    upsert<T extends RentalPeriodUpsertArgs>(args: SelectSubset<T, RentalPeriodUpsertArgs<ExtArgs>>): Prisma__RentalPeriodClient<$Result.GetResult<Prisma.$RentalPeriodPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RentalPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPeriodCountArgs} args - Arguments to filter RentalPeriods to count.
     * @example
     * // Count the number of RentalPeriods
     * const count = await prisma.rentalPeriod.count({
     *   where: {
     *     // ... the filter for the RentalPeriods we want to count
     *   }
     * })
    **/
    count<T extends RentalPeriodCountArgs>(
      args?: Subset<T, RentalPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RentalPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RentalPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RentalPeriodAggregateArgs>(args: Subset<T, RentalPeriodAggregateArgs>): Prisma.PrismaPromise<GetRentalPeriodAggregateType<T>>

    /**
     * Group by RentalPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RentalPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RentalPeriodGroupByArgs['orderBy'] }
        : { orderBy?: RentalPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RentalPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRentalPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RentalPeriod model
   */
  readonly fields: RentalPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RentalPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RentalPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    shopItem<T extends ShopItemForRentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopItemForRentDefaultArgs<ExtArgs>>): Prisma__ShopItemForRentClient<$Result.GetResult<Prisma.$ShopItemForRentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RentalPeriod model
   */ 
  interface RentalPeriodFieldRefs {
    readonly id: FieldRef<"RentalPeriod", 'String'>
    readonly teacherId: FieldRef<"RentalPeriod", 'String'>
    readonly shopItemId: FieldRef<"RentalPeriod", 'String'>
    readonly rentStartDate: FieldRef<"RentalPeriod", 'DateTime'>
    readonly rentEndDate: FieldRef<"RentalPeriod", 'DateTime'>
    readonly createdAt: FieldRef<"RentalPeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"RentalPeriod", 'DateTime'>
    readonly isActive: FieldRef<"RentalPeriod", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RentalPeriod findUnique
   */
  export type RentalPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which RentalPeriod to fetch.
     */
    where: RentalPeriodWhereUniqueInput
  }

  /**
   * RentalPeriod findUniqueOrThrow
   */
  export type RentalPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which RentalPeriod to fetch.
     */
    where: RentalPeriodWhereUniqueInput
  }

  /**
   * RentalPeriod findFirst
   */
  export type RentalPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which RentalPeriod to fetch.
     */
    where?: RentalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPeriods to fetch.
     */
    orderBy?: RentalPeriodOrderByWithRelationInput | RentalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalPeriods.
     */
    cursor?: RentalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalPeriods.
     */
    distinct?: RentalPeriodScalarFieldEnum | RentalPeriodScalarFieldEnum[]
  }

  /**
   * RentalPeriod findFirstOrThrow
   */
  export type RentalPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which RentalPeriod to fetch.
     */
    where?: RentalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPeriods to fetch.
     */
    orderBy?: RentalPeriodOrderByWithRelationInput | RentalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalPeriods.
     */
    cursor?: RentalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalPeriods.
     */
    distinct?: RentalPeriodScalarFieldEnum | RentalPeriodScalarFieldEnum[]
  }

  /**
   * RentalPeriod findMany
   */
  export type RentalPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which RentalPeriods to fetch.
     */
    where?: RentalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPeriods to fetch.
     */
    orderBy?: RentalPeriodOrderByWithRelationInput | RentalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RentalPeriods.
     */
    cursor?: RentalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPeriods.
     */
    skip?: number
    distinct?: RentalPeriodScalarFieldEnum | RentalPeriodScalarFieldEnum[]
  }

  /**
   * RentalPeriod create
   */
  export type RentalPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a RentalPeriod.
     */
    data: XOR<RentalPeriodCreateInput, RentalPeriodUncheckedCreateInput>
  }

  /**
   * RentalPeriod createMany
   */
  export type RentalPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RentalPeriods.
     */
    data: RentalPeriodCreateManyInput | RentalPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentalPeriod createManyAndReturn
   */
  export type RentalPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * The data used to create many RentalPeriods.
     */
    data: RentalPeriodCreateManyInput | RentalPeriodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalPeriod update
   */
  export type RentalPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a RentalPeriod.
     */
    data: XOR<RentalPeriodUpdateInput, RentalPeriodUncheckedUpdateInput>
    /**
     * Choose, which RentalPeriod to update.
     */
    where: RentalPeriodWhereUniqueInput
  }

  /**
   * RentalPeriod updateMany
   */
  export type RentalPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RentalPeriods.
     */
    data: XOR<RentalPeriodUpdateManyMutationInput, RentalPeriodUncheckedUpdateManyInput>
    /**
     * Filter which RentalPeriods to update
     */
    where?: RentalPeriodWhereInput
    /**
     * Limit how many RentalPeriods to update.
     */
    limit?: number
  }

  /**
   * RentalPeriod updateManyAndReturn
   */
  export type RentalPeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * The data used to update RentalPeriods.
     */
    data: XOR<RentalPeriodUpdateManyMutationInput, RentalPeriodUncheckedUpdateManyInput>
    /**
     * Filter which RentalPeriods to update
     */
    where?: RentalPeriodWhereInput
    /**
     * Limit how many RentalPeriods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalPeriod upsert
   */
  export type RentalPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the RentalPeriod to update in case it exists.
     */
    where: RentalPeriodWhereUniqueInput
    /**
     * In case the RentalPeriod found by the `where` argument doesn't exist, create a new RentalPeriod with this data.
     */
    create: XOR<RentalPeriodCreateInput, RentalPeriodUncheckedCreateInput>
    /**
     * In case the RentalPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RentalPeriodUpdateInput, RentalPeriodUncheckedUpdateInput>
  }

  /**
   * RentalPeriod delete
   */
  export type RentalPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
    /**
     * Filter which RentalPeriod to delete.
     */
    where: RentalPeriodWhereUniqueInput
  }

  /**
   * RentalPeriod deleteMany
   */
  export type RentalPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalPeriods to delete
     */
    where?: RentalPeriodWhereInput
    /**
     * Limit how many RentalPeriods to delete.
     */
    limit?: number
  }

  /**
   * RentalPeriod without action
   */
  export type RentalPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPeriod
     */
    select?: RentalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPeriod
     */
    omit?: RentalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPeriodInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    userApiToken: 'userApiToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastAccessedAt: 'lastAccessedAt',
    isActive: 'isActive',
    isDeleted: 'isDeleted'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    displayName: 'displayName',
    bio: 'bio',
    birthDate: 'birthDate',
    phoneNumber: 'phoneNumber'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    oauth_token_secret: 'oauth_token_secret',
    oauth_token: 'oauth_token'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    specialization: 'specialization'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    studentId: 'studentId',
    enrollYear: 'enrollYear',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    addedById: 'addedById'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    category: 'category',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId',
    ownerId: 'ownerId',
    publishStatus: 'publishStatus'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    category: 'category',
    totalHours: 'totalHours',
    averageHoursPerLesson: 'averageHoursPerLesson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId',
    ownerId: 'ownerId',
    courseId: 'courseId',
    publishStatus: 'publishStatus'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    duration: 'duration',
    order: 'order',
    moduleId: 'moduleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    order: 'order',
    moduleId: 'moduleId'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const ObjectiveScalarFieldEnum: {
    id: 'id',
    description: 'description',
    topicId: 'topicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ObjectiveScalarFieldEnum = (typeof ObjectiveScalarFieldEnum)[keyof typeof ObjectiveScalarFieldEnum]


  export const ModuleAssignmentScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    teacherId: 'teacherId',
    courseId: 'courseId',
    hourlyRate: 'hourlyRate',
    currency: 'currency',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type ModuleAssignmentScalarFieldEnum = (typeof ModuleAssignmentScalarFieldEnum)[keyof typeof ModuleAssignmentScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    type: 'type',
    difficulty: 'difficulty',
    points: 'points',
    timeLimit: 'timeLimit',
    topicId: 'topicId',
    isTeamExercise: 'isTeamExercise',
    creatorId: 'creatorId',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    publishStatus: 'publishStatus'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    moduleId: 'moduleId',
    date: 'date',
    duration: 'duration',
    maxScore: 'maxScore',
    creatorId: 'creatorId',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishStatus: 'publishStatus'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const ExamExerciseScalarFieldEnum: {
    examId: 'examId',
    exerciseId: 'exerciseId',
    order: 'order'
  };

  export type ExamExerciseScalarFieldEnum = (typeof ExamExerciseScalarFieldEnum)[keyof typeof ExamExerciseScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    url: 'url',
    type: 'type',
    courseId: 'courseId',
    moduleId: 'moduleId',
    topicId: 'topicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId',
    ownerId: 'ownerId',
    publishStatus: 'publishStatus'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    userId: 'userId',
    courseId: 'courseId',
    moduleId: 'moduleId',
    topicId: 'topicId',
    materialId: 'materialId',
    enrollmentId: 'enrollmentId',
    classId: 'classId',
    teamId: 'teamId',
    eventId: 'eventId',
    lessonId: 'lessonId',
    examId: 'examId',
    exerciseId: 'exerciseId',
    studentId: 'studentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    classId: 'classId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    totalPrice: 'totalPrice',
    currency: 'currency',
    teacherId: 'teacherId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    color: 'color',
    courseId: 'courseId',
    teacherId: 'teacherId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const HolidayScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    enrollmentId: 'enrollmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HolidayScalarFieldEnum = (typeof HolidayScalarFieldEnum)[keyof typeof HolidayScalarFieldEnum]


  export const LessonScheduleScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    dateTime: 'dateTime',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teacherId: 'teacherId'
  };

  export type LessonScheduleScalarFieldEnum = (typeof LessonScheduleScalarFieldEnum)[keyof typeof LessonScheduleScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    type: 'type',
    courseId: 'courseId',
    moduleId: 'moduleId',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    classId: 'classId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teacherId: 'teacherId'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    type: 'type',
    teacherId: 'teacherId',
    studentId: 'studentId',
    seen: 'seen',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ShopItemForSaleScalarFieldEnum: {
    id: 'id',
    itemType: 'itemType',
    itemId: 'itemId',
    sellPrice: 'sellPrice',
    currency: 'currency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopItemForSaleScalarFieldEnum = (typeof ShopItemForSaleScalarFieldEnum)[keyof typeof ShopItemForSaleScalarFieldEnum]


  export const ShopItemForRentScalarFieldEnum: {
    id: 'id',
    itemType: 'itemType',
    itemId: 'itemId',
    rentPrice: 'rentPrice',
    rentPeriod: 'rentPeriod',
    currency: 'currency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isVisible: 'isVisible'
  };

  export type ShopItemForRentScalarFieldEnum = (typeof ShopItemForRentScalarFieldEnum)[keyof typeof ShopItemForRentScalarFieldEnum]


  export const PurchasedItemScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    shopItemId: 'shopItemId',
    purchaseDate: 'purchaseDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchasedItemScalarFieldEnum = (typeof PurchasedItemScalarFieldEnum)[keyof typeof PurchasedItemScalarFieldEnum]


  export const RentalPeriodScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    shopItemId: 'shopItemId',
    rentStartDate: 'rentStartDate',
    rentEndDate: 'rentEndDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive'
  };

  export type RentalPeriodScalarFieldEnum = (typeof RentalPeriodScalarFieldEnum)[keyof typeof RentalPeriodScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CourseStatusEnum'
   */
  export type EnumCourseStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatusEnum'>
    


  /**
   * Reference to a field of type 'CourseStatusEnum[]'
   */
  export type ListEnumCourseStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatusEnum[]'>
    


  /**
   * Reference to a field of type 'PublishStatusEnum'
   */
  export type EnumPublishStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublishStatusEnum'>
    


  /**
   * Reference to a field of type 'PublishStatusEnum[]'
   */
  export type ListEnumPublishStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublishStatusEnum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CurrencyTypeEnum'
   */
  export type EnumCurrencyTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyTypeEnum'>
    


  /**
   * Reference to a field of type 'CurrencyTypeEnum[]'
   */
  export type ListEnumCurrencyTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyTypeEnum[]'>
    


  /**
   * Reference to a field of type 'ExerciseTypeEnum'
   */
  export type EnumExerciseTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseTypeEnum'>
    


  /**
   * Reference to a field of type 'ExerciseTypeEnum[]'
   */
  export type ListEnumExerciseTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseTypeEnum[]'>
    


  /**
   * Reference to a field of type 'DifficultyLevelEnum'
   */
  export type EnumDifficultyLevelEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifficultyLevelEnum'>
    


  /**
   * Reference to a field of type 'DifficultyLevelEnum[]'
   */
  export type ListEnumDifficultyLevelEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifficultyLevelEnum[]'>
    


  /**
   * Reference to a field of type 'ExamTypeEnum'
   */
  export type EnumExamTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamTypeEnum'>
    


  /**
   * Reference to a field of type 'ExamTypeEnum[]'
   */
  export type ListEnumExamTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamTypeEnum[]'>
    


  /**
   * Reference to a field of type 'MaterialType'
   */
  export type EnumMaterialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialType'>
    


  /**
   * Reference to a field of type 'MaterialType[]'
   */
  export type ListEnumMaterialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialType[]'>
    


  /**
   * Reference to a field of type 'EnrollmentStatusEnum'
   */
  export type EnumEnrollmentStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnrollmentStatusEnum'>
    


  /**
   * Reference to a field of type 'EnrollmentStatusEnum[]'
   */
  export type ListEnumEnrollmentStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnrollmentStatusEnum[]'>
    


  /**
   * Reference to a field of type 'EventTypeEnum'
   */
  export type EnumEventTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventTypeEnum'>
    


  /**
   * Reference to a field of type 'EventTypeEnum[]'
   */
  export type ListEnumEventTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventTypeEnum[]'>
    


  /**
   * Reference to a field of type 'NotificationTypeEnum'
   */
  export type EnumNotificationTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationTypeEnum'>
    


  /**
   * Reference to a field of type 'NotificationTypeEnum[]'
   */
  export type ListEnumNotificationTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationTypeEnum[]'>
    


  /**
   * Reference to a field of type 'ShopItemTypeEnum'
   */
  export type EnumShopItemTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShopItemTypeEnum'>
    


  /**
   * Reference to a field of type 'ShopItemTypeEnum[]'
   */
  export type ListEnumShopItemTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShopItemTypeEnum[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    userApiToken?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastAccessedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    roles?: UserRoleListRelationFilter
    comments?: CommentListRelationFilter
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    userApiToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    roles?: UserRoleOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    teacher?: TeacherOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    userApiToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastAccessedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    roles?: UserRoleListRelationFilter
    comments?: CommentListRelationFilter
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id" | "email" | "userApiToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    userApiToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    userApiToken?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastAccessedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    displayName?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    birthDate?: DateTimeNullableFilter<"Profile"> | Date | string | null
    phoneNumber?: StringNullableFilter<"Profile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    displayName?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    birthDate?: DateTimeNullableFilter<"Profile"> | Date | string | null
    phoneNumber?: StringNullableFilter<"Profile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    firstName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Profile"> | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    users?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    users?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    oauth_token_secret?: StringNullableFilter<"Account"> | string | null
    oauth_token?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    oauth_token_secret?: SortOrderInput | SortOrder
    oauth_token?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    oauth_token_secret?: StringNullableFilter<"Account"> | string | null
    oauth_token?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    oauth_token_secret?: SortOrderInput | SortOrder
    oauth_token?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    oauth_token_secret?: StringNullableWithAggregatesFilter<"Account"> | string | null
    oauth_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    specialization?: StringNullableFilter<"Teacher"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    moduleAssignments?: ModuleAssignmentListRelationFilter
    createdCourses?: CourseListRelationFilter
    ownedCourses?: CourseListRelationFilter
    createdModules?: ModuleListRelationFilter
    ownedModules?: ModuleListRelationFilter
    createdExercises?: ExerciseListRelationFilter
    ownedExercises?: ExerciseListRelationFilter
    createdExams?: ExamListRelationFilter
    ownedExams?: ExamListRelationFilter
    createdClients?: ClientListRelationFilter
    events?: EventListRelationFilter
    notifications?: NotificationListRelationFilter
    purchases?: PurchasedItemListRelationFilter
    rentalPeriods?: RentalPeriodListRelationFilter
    createdMaterial?: MaterialListRelationFilter
    ownedMaterial?: MaterialListRelationFilter
    addedStudents?: StudentListRelationFilter
    classes?: ClassListRelationFilter
    lessonsSchedule?: LessonScheduleListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    teams?: TeamListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    moduleAssignments?: ModuleAssignmentOrderByRelationAggregateInput
    createdCourses?: CourseOrderByRelationAggregateInput
    ownedCourses?: CourseOrderByRelationAggregateInput
    createdModules?: ModuleOrderByRelationAggregateInput
    ownedModules?: ModuleOrderByRelationAggregateInput
    createdExercises?: ExerciseOrderByRelationAggregateInput
    ownedExercises?: ExerciseOrderByRelationAggregateInput
    createdExams?: ExamOrderByRelationAggregateInput
    ownedExams?: ExamOrderByRelationAggregateInput
    createdClients?: ClientOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    purchases?: PurchasedItemOrderByRelationAggregateInput
    rentalPeriods?: RentalPeriodOrderByRelationAggregateInput
    createdMaterial?: MaterialOrderByRelationAggregateInput
    ownedMaterial?: MaterialOrderByRelationAggregateInput
    addedStudents?: StudentOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    lessonsSchedule?: LessonScheduleOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    specialization?: StringNullableFilter<"Teacher"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    moduleAssignments?: ModuleAssignmentListRelationFilter
    createdCourses?: CourseListRelationFilter
    ownedCourses?: CourseListRelationFilter
    createdModules?: ModuleListRelationFilter
    ownedModules?: ModuleListRelationFilter
    createdExercises?: ExerciseListRelationFilter
    ownedExercises?: ExerciseListRelationFilter
    createdExams?: ExamListRelationFilter
    ownedExams?: ExamListRelationFilter
    createdClients?: ClientListRelationFilter
    events?: EventListRelationFilter
    notifications?: NotificationListRelationFilter
    purchases?: PurchasedItemListRelationFilter
    rentalPeriods?: RentalPeriodListRelationFilter
    createdMaterial?: MaterialListRelationFilter
    ownedMaterial?: MaterialListRelationFilter
    addedStudents?: StudentListRelationFilter
    classes?: ClassListRelationFilter
    lessonsSchedule?: LessonScheduleListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    teams?: TeamListRelationFilter
  }, "id" | "userId">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrderInput | SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teacher"> | string
    userId?: StringWithAggregatesFilter<"Teacher"> | string
    specialization?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    enrollYear?: IntFilter<"Student"> | number
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    addedById?: StringFilter<"Student"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    classes?: ClassListRelationFilter
    teams?: TeamListRelationFilter
    notifications?: NotificationListRelationFilter
    comments?: CommentListRelationFilter
    addedBy?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    enrollYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addedById?: SortOrder
    user?: UserOrderByWithRelationInput
    classes?: ClassOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    addedBy?: TeacherOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    studentId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    enrollYear?: IntFilter<"Student"> | number
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    addedById?: StringFilter<"Student"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    classes?: ClassListRelationFilter
    teams?: TeamListRelationFilter
    notifications?: NotificationListRelationFilter
    comments?: CommentListRelationFilter
    addedBy?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
  }, "id" | "userId" | "studentId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    enrollYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addedById?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    studentId?: StringWithAggregatesFilter<"Student"> | string
    enrollYear?: IntWithAggregatesFilter<"Student"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    addedById?: StringWithAggregatesFilter<"Student"> | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    slug?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    category?: StringFilter<"Course"> | string
    status?: EnumCourseStatusEnumFilter<"Course"> | $Enums.CourseStatusEnum
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    creatorId?: StringFilter<"Course"> | string
    ownerId?: StringFilter<"Course"> | string
    publishStatus?: EnumPublishStatusEnumFilter<"Course"> | $Enums.PublishStatusEnum
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    owner?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    modules?: ModuleListRelationFilter
    materials?: MaterialListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    events?: EventListRelationFilter
    classes?: ClassListRelationFilter
    comments?: CommentListRelationFilter
    forSale?: XOR<ShopItemForSaleNullableScalarRelationFilter, ShopItemForSaleWhereInput> | null
    forRent?: XOR<ShopItemForRentNullableScalarRelationFilter, ShopItemForRentWhereInput> | null
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    publishStatus?: SortOrder
    creator?: TeacherOrderByWithRelationInput
    owner?: TeacherOrderByWithRelationInput
    modules?: ModuleOrderByRelationAggregateInput
    materials?: MaterialOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    forSale?: ShopItemForSaleOrderByWithRelationInput
    forRent?: ShopItemForRentOrderByWithRelationInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    name?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    category?: StringFilter<"Course"> | string
    status?: EnumCourseStatusEnumFilter<"Course"> | $Enums.CourseStatusEnum
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    creatorId?: StringFilter<"Course"> | string
    ownerId?: StringFilter<"Course"> | string
    publishStatus?: EnumPublishStatusEnumFilter<"Course"> | $Enums.PublishStatusEnum
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    owner?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    modules?: ModuleListRelationFilter
    materials?: MaterialListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    events?: EventListRelationFilter
    classes?: ClassListRelationFilter
    comments?: CommentListRelationFilter
    forSale?: XOR<ShopItemForSaleNullableScalarRelationFilter, ShopItemForSaleWhereInput> | null
    forRent?: XOR<ShopItemForRentNullableScalarRelationFilter, ShopItemForRentWhereInput> | null
  }, "id" | "slug">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    publishStatus?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    slug?: StringWithAggregatesFilter<"Course"> | string
    name?: StringWithAggregatesFilter<"Course"> | string
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
    category?: StringWithAggregatesFilter<"Course"> | string
    status?: EnumCourseStatusEnumWithAggregatesFilter<"Course"> | $Enums.CourseStatusEnum
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Course"> | string
    ownerId?: StringWithAggregatesFilter<"Course"> | string
    publishStatus?: EnumPublishStatusEnumWithAggregatesFilter<"Course"> | $Enums.PublishStatusEnum
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: StringFilter<"Module"> | string
    slug?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    category?: StringFilter<"Module"> | string
    totalHours?: IntFilter<"Module"> | number
    averageHoursPerLesson?: FloatFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    creatorId?: StringFilter<"Module"> | string
    ownerId?: StringFilter<"Module"> | string
    courseId?: StringFilter<"Module"> | string
    publishStatus?: EnumPublishStatusEnumFilter<"Module"> | $Enums.PublishStatusEnum
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    owner?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    topics?: TopicListRelationFilter
    materials?: MaterialListRelationFilter
    assignments?: ModuleAssignmentListRelationFilter
    exams?: ExamListRelationFilter
    lessons?: LessonListRelationFilter
    events?: EventListRelationFilter
    comments?: CommentListRelationFilter
    forSale?: XOR<ShopItemForSaleNullableScalarRelationFilter, ShopItemForSaleWhereInput> | null
    forRent?: XOR<ShopItemForRentNullableScalarRelationFilter, ShopItemForRentWhereInput> | null
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    totalHours?: SortOrder
    averageHoursPerLesson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    courseId?: SortOrder
    publishStatus?: SortOrder
    creator?: TeacherOrderByWithRelationInput
    owner?: TeacherOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    topics?: TopicOrderByRelationAggregateInput
    materials?: MaterialOrderByRelationAggregateInput
    assignments?: ModuleAssignmentOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    forSale?: ShopItemForSaleOrderByWithRelationInput
    forRent?: ShopItemForRentOrderByWithRelationInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    category?: StringFilter<"Module"> | string
    totalHours?: IntFilter<"Module"> | number
    averageHoursPerLesson?: FloatFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    creatorId?: StringFilter<"Module"> | string
    ownerId?: StringFilter<"Module"> | string
    courseId?: StringFilter<"Module"> | string
    publishStatus?: EnumPublishStatusEnumFilter<"Module"> | $Enums.PublishStatusEnum
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    owner?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    topics?: TopicListRelationFilter
    materials?: MaterialListRelationFilter
    assignments?: ModuleAssignmentListRelationFilter
    exams?: ExamListRelationFilter
    lessons?: LessonListRelationFilter
    events?: EventListRelationFilter
    comments?: CommentListRelationFilter
    forSale?: XOR<ShopItemForSaleNullableScalarRelationFilter, ShopItemForSaleWhereInput> | null
    forRent?: XOR<ShopItemForRentNullableScalarRelationFilter, ShopItemForRentWhereInput> | null
  }, "id" | "slug">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    totalHours?: SortOrder
    averageHoursPerLesson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    courseId?: SortOrder
    publishStatus?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Module"> | string
    slug?: StringWithAggregatesFilter<"Module"> | string
    name?: StringWithAggregatesFilter<"Module"> | string
    description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    category?: StringWithAggregatesFilter<"Module"> | string
    totalHours?: IntWithAggregatesFilter<"Module"> | number
    averageHoursPerLesson?: FloatWithAggregatesFilter<"Module"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Module"> | string
    ownerId?: StringWithAggregatesFilter<"Module"> | string
    courseId?: StringWithAggregatesFilter<"Module"> | string
    publishStatus?: EnumPublishStatusEnumWithAggregatesFilter<"Module"> | $Enums.PublishStatusEnum
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    name?: StringFilter<"Lesson"> | string
    description?: StringNullableFilter<"Lesson"> | string | null
    duration?: FloatFilter<"Lesson"> | number
    order?: IntFilter<"Lesson"> | number
    moduleId?: StringFilter<"Lesson"> | string
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    schedules?: LessonScheduleListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrder
    order?: SortOrder
    moduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    module?: ModuleOrderByWithRelationInput
    schedules?: LessonScheduleOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    name?: StringFilter<"Lesson"> | string
    description?: StringNullableFilter<"Lesson"> | string | null
    duration?: FloatFilter<"Lesson"> | number
    order?: IntFilter<"Lesson"> | number
    moduleId?: StringFilter<"Lesson"> | string
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    schedules?: LessonScheduleListRelationFilter
    comments?: CommentListRelationFilter
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrder
    order?: SortOrder
    moduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    name?: StringWithAggregatesFilter<"Lesson"> | string
    description?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    duration?: FloatWithAggregatesFilter<"Lesson"> | number
    order?: IntWithAggregatesFilter<"Lesson"> | number
    moduleId?: StringWithAggregatesFilter<"Lesson"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: StringFilter<"Topic"> | string
    name?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    order?: IntFilter<"Topic"> | number
    moduleId?: StringFilter<"Topic"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    materials?: MaterialListRelationFilter
    exercises?: ExerciseListRelationFilter
    objectives?: ObjectiveListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    moduleId?: SortOrder
    module?: ModuleOrderByWithRelationInput
    materials?: MaterialOrderByRelationAggregateInput
    exercises?: ExerciseOrderByRelationAggregateInput
    objectives?: ObjectiveOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    name?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    order?: IntFilter<"Topic"> | number
    moduleId?: StringFilter<"Topic"> | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    materials?: MaterialListRelationFilter
    exercises?: ExerciseListRelationFilter
    objectives?: ObjectiveListRelationFilter
    comments?: CommentListRelationFilter
  }, "id">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    moduleId?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _avg?: TopicAvgOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
    _sum?: TopicSumOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Topic"> | string
    name?: StringWithAggregatesFilter<"Topic"> | string
    description?: StringNullableWithAggregatesFilter<"Topic"> | string | null
    order?: IntWithAggregatesFilter<"Topic"> | number
    moduleId?: StringWithAggregatesFilter<"Topic"> | string
  }

  export type ObjectiveWhereInput = {
    AND?: ObjectiveWhereInput | ObjectiveWhereInput[]
    OR?: ObjectiveWhereInput[]
    NOT?: ObjectiveWhereInput | ObjectiveWhereInput[]
    id?: StringFilter<"Objective"> | string
    description?: StringFilter<"Objective"> | string
    topicId?: StringFilter<"Objective"> | string
    createdAt?: DateTimeFilter<"Objective"> | Date | string
    updatedAt?: DateTimeFilter<"Objective"> | Date | string
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }

  export type ObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    topic?: TopicOrderByWithRelationInput
  }

  export type ObjectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObjectiveWhereInput | ObjectiveWhereInput[]
    OR?: ObjectiveWhereInput[]
    NOT?: ObjectiveWhereInput | ObjectiveWhereInput[]
    description?: StringFilter<"Objective"> | string
    topicId?: StringFilter<"Objective"> | string
    createdAt?: DateTimeFilter<"Objective"> | Date | string
    updatedAt?: DateTimeFilter<"Objective"> | Date | string
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }, "id">

  export type ObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ObjectiveCountOrderByAggregateInput
    _max?: ObjectiveMaxOrderByAggregateInput
    _min?: ObjectiveMinOrderByAggregateInput
  }

  export type ObjectiveScalarWhereWithAggregatesInput = {
    AND?: ObjectiveScalarWhereWithAggregatesInput | ObjectiveScalarWhereWithAggregatesInput[]
    OR?: ObjectiveScalarWhereWithAggregatesInput[]
    NOT?: ObjectiveScalarWhereWithAggregatesInput | ObjectiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Objective"> | string
    description?: StringWithAggregatesFilter<"Objective"> | string
    topicId?: StringWithAggregatesFilter<"Objective"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Objective"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Objective"> | Date | string
  }

  export type ModuleAssignmentWhereInput = {
    AND?: ModuleAssignmentWhereInput | ModuleAssignmentWhereInput[]
    OR?: ModuleAssignmentWhereInput[]
    NOT?: ModuleAssignmentWhereInput | ModuleAssignmentWhereInput[]
    id?: StringFilter<"ModuleAssignment"> | string
    moduleId?: StringFilter<"ModuleAssignment"> | string
    teacherId?: StringFilter<"ModuleAssignment"> | string
    courseId?: StringFilter<"ModuleAssignment"> | string
    hourlyRate?: IntFilter<"ModuleAssignment"> | number
    currency?: EnumCurrencyTypeEnumFilter<"ModuleAssignment"> | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFilter<"ModuleAssignment"> | Date | string
    endDate?: DateTimeFilter<"ModuleAssignment"> | Date | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
  }

  export type ModuleAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    teacherId?: SortOrder
    courseId?: SortOrder
    hourlyRate?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    module?: ModuleOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
  }

  export type ModuleAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    moduleId_teacherId_courseId_startDate_endDate?: ModuleAssignmentModuleIdTeacherIdCourseIdStartDateEndDateCompoundUniqueInput
    AND?: ModuleAssignmentWhereInput | ModuleAssignmentWhereInput[]
    OR?: ModuleAssignmentWhereInput[]
    NOT?: ModuleAssignmentWhereInput | ModuleAssignmentWhereInput[]
    moduleId?: StringFilter<"ModuleAssignment"> | string
    teacherId?: StringFilter<"ModuleAssignment"> | string
    courseId?: StringFilter<"ModuleAssignment"> | string
    hourlyRate?: IntFilter<"ModuleAssignment"> | number
    currency?: EnumCurrencyTypeEnumFilter<"ModuleAssignment"> | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFilter<"ModuleAssignment"> | Date | string
    endDate?: DateTimeFilter<"ModuleAssignment"> | Date | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
  }, "id" | "moduleId_teacherId_courseId_startDate_endDate">

  export type ModuleAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    teacherId?: SortOrder
    courseId?: SortOrder
    hourlyRate?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    _count?: ModuleAssignmentCountOrderByAggregateInput
    _avg?: ModuleAssignmentAvgOrderByAggregateInput
    _max?: ModuleAssignmentMaxOrderByAggregateInput
    _min?: ModuleAssignmentMinOrderByAggregateInput
    _sum?: ModuleAssignmentSumOrderByAggregateInput
  }

  export type ModuleAssignmentScalarWhereWithAggregatesInput = {
    AND?: ModuleAssignmentScalarWhereWithAggregatesInput | ModuleAssignmentScalarWhereWithAggregatesInput[]
    OR?: ModuleAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ModuleAssignmentScalarWhereWithAggregatesInput | ModuleAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModuleAssignment"> | string
    moduleId?: StringWithAggregatesFilter<"ModuleAssignment"> | string
    teacherId?: StringWithAggregatesFilter<"ModuleAssignment"> | string
    courseId?: StringWithAggregatesFilter<"ModuleAssignment"> | string
    hourlyRate?: IntWithAggregatesFilter<"ModuleAssignment"> | number
    currency?: EnumCurrencyTypeEnumWithAggregatesFilter<"ModuleAssignment"> | $Enums.CurrencyTypeEnum
    startDate?: DateTimeWithAggregatesFilter<"ModuleAssignment"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"ModuleAssignment"> | Date | string
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: StringFilter<"Exercise"> | string
    title?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    content?: StringFilter<"Exercise"> | string
    type?: EnumExerciseTypeEnumFilter<"Exercise"> | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFilter<"Exercise"> | $Enums.DifficultyLevelEnum
    points?: IntFilter<"Exercise"> | number
    timeLimit?: IntNullableFilter<"Exercise"> | number | null
    topicId?: StringNullableFilter<"Exercise"> | string | null
    isTeamExercise?: BoolFilter<"Exercise"> | boolean
    creatorId?: StringFilter<"Exercise"> | string
    ownerId?: StringFilter<"Exercise"> | string
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    clientId?: StringNullableFilter<"Exercise"> | string | null
    publishStatus?: EnumPublishStatusEnumFilter<"Exercise"> | $Enums.PublishStatusEnum
    topic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
    examExercises?: ExamExerciseListRelationFilter
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    owner?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    teams?: TeamListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    comments?: CommentListRelationFilter
    forSale?: XOR<ShopItemForSaleNullableScalarRelationFilter, ShopItemForSaleWhereInput> | null
    forRent?: XOR<ShopItemForRentNullableScalarRelationFilter, ShopItemForRentWhereInput> | null
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    isTeamExercise?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    publishStatus?: SortOrder
    topic?: TopicOrderByWithRelationInput
    examExercises?: ExamExerciseOrderByRelationAggregateInput
    creator?: TeacherOrderByWithRelationInput
    owner?: TeacherOrderByWithRelationInput
    teams?: TeamOrderByRelationAggregateInput
    client?: ClientOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    forSale?: ShopItemForSaleOrderByWithRelationInput
    forRent?: ShopItemForRentOrderByWithRelationInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    title?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    content?: StringFilter<"Exercise"> | string
    type?: EnumExerciseTypeEnumFilter<"Exercise"> | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFilter<"Exercise"> | $Enums.DifficultyLevelEnum
    points?: IntFilter<"Exercise"> | number
    timeLimit?: IntNullableFilter<"Exercise"> | number | null
    topicId?: StringNullableFilter<"Exercise"> | string | null
    isTeamExercise?: BoolFilter<"Exercise"> | boolean
    creatorId?: StringFilter<"Exercise"> | string
    ownerId?: StringFilter<"Exercise"> | string
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    clientId?: StringNullableFilter<"Exercise"> | string | null
    publishStatus?: EnumPublishStatusEnumFilter<"Exercise"> | $Enums.PublishStatusEnum
    topic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
    examExercises?: ExamExerciseListRelationFilter
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    owner?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    teams?: TeamListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    comments?: CommentListRelationFilter
    forSale?: XOR<ShopItemForSaleNullableScalarRelationFilter, ShopItemForSaleWhereInput> | null
    forRent?: XOR<ShopItemForRentNullableScalarRelationFilter, ShopItemForRentWhereInput> | null
  }, "id">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    isTeamExercise?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    publishStatus?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exercise"> | string
    title?: StringWithAggregatesFilter<"Exercise"> | string
    description?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    content?: StringWithAggregatesFilter<"Exercise"> | string
    type?: EnumExerciseTypeEnumWithAggregatesFilter<"Exercise"> | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumWithAggregatesFilter<"Exercise"> | $Enums.DifficultyLevelEnum
    points?: IntWithAggregatesFilter<"Exercise"> | number
    timeLimit?: IntNullableWithAggregatesFilter<"Exercise"> | number | null
    topicId?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    isTeamExercise?: BoolWithAggregatesFilter<"Exercise"> | boolean
    creatorId?: StringWithAggregatesFilter<"Exercise"> | string
    ownerId?: StringWithAggregatesFilter<"Exercise"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    clientId?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    publishStatus?: EnumPublishStatusEnumWithAggregatesFilter<"Exercise"> | $Enums.PublishStatusEnum
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    name?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    type?: EnumExamTypeEnumFilter<"Exam"> | $Enums.ExamTypeEnum
    moduleId?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    duration?: IntFilter<"Exam"> | number
    maxScore?: FloatFilter<"Exam"> | number
    creatorId?: StringFilter<"Exam"> | string
    ownerId?: StringFilter<"Exam"> | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    publishStatus?: EnumPublishStatusEnumFilter<"Exam"> | $Enums.PublishStatusEnum
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    exercises?: ExamExerciseListRelationFilter
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    owner?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    comments?: CommentListRelationFilter
    forSale?: XOR<ShopItemForSaleNullableScalarRelationFilter, ShopItemForSaleWhereInput> | null
    forRent?: XOR<ShopItemForRentNullableScalarRelationFilter, ShopItemForRentWhereInput> | null
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    moduleId?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    maxScore?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishStatus?: SortOrder
    module?: ModuleOrderByWithRelationInput
    exercises?: ExamExerciseOrderByRelationAggregateInput
    creator?: TeacherOrderByWithRelationInput
    owner?: TeacherOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    forSale?: ShopItemForSaleOrderByWithRelationInput
    forRent?: ShopItemForRentOrderByWithRelationInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    name?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    type?: EnumExamTypeEnumFilter<"Exam"> | $Enums.ExamTypeEnum
    moduleId?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    duration?: IntFilter<"Exam"> | number
    maxScore?: FloatFilter<"Exam"> | number
    creatorId?: StringFilter<"Exam"> | string
    ownerId?: StringFilter<"Exam"> | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    publishStatus?: EnumPublishStatusEnumFilter<"Exam"> | $Enums.PublishStatusEnum
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    exercises?: ExamExerciseListRelationFilter
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    owner?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    comments?: CommentListRelationFilter
    forSale?: XOR<ShopItemForSaleNullableScalarRelationFilter, ShopItemForSaleWhereInput> | null
    forRent?: XOR<ShopItemForRentNullableScalarRelationFilter, ShopItemForRentWhereInput> | null
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    moduleId?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    maxScore?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishStatus?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    name?: StringWithAggregatesFilter<"Exam"> | string
    description?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    type?: EnumExamTypeEnumWithAggregatesFilter<"Exam"> | $Enums.ExamTypeEnum
    moduleId?: StringWithAggregatesFilter<"Exam"> | string
    date?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    duration?: IntWithAggregatesFilter<"Exam"> | number
    maxScore?: FloatWithAggregatesFilter<"Exam"> | number
    creatorId?: StringWithAggregatesFilter<"Exam"> | string
    ownerId?: StringWithAggregatesFilter<"Exam"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    publishStatus?: EnumPublishStatusEnumWithAggregatesFilter<"Exam"> | $Enums.PublishStatusEnum
  }

  export type ExamExerciseWhereInput = {
    AND?: ExamExerciseWhereInput | ExamExerciseWhereInput[]
    OR?: ExamExerciseWhereInput[]
    NOT?: ExamExerciseWhereInput | ExamExerciseWhereInput[]
    examId?: StringFilter<"ExamExercise"> | string
    exerciseId?: StringFilter<"ExamExercise"> | string
    order?: IntFilter<"ExamExercise"> | number
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
  }

  export type ExamExerciseOrderByWithRelationInput = {
    examId?: SortOrder
    exerciseId?: SortOrder
    order?: SortOrder
    exam?: ExamOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type ExamExerciseWhereUniqueInput = Prisma.AtLeast<{
    examId_exerciseId?: ExamExerciseExamIdExerciseIdCompoundUniqueInput
    AND?: ExamExerciseWhereInput | ExamExerciseWhereInput[]
    OR?: ExamExerciseWhereInput[]
    NOT?: ExamExerciseWhereInput | ExamExerciseWhereInput[]
    examId?: StringFilter<"ExamExercise"> | string
    exerciseId?: StringFilter<"ExamExercise"> | string
    order?: IntFilter<"ExamExercise"> | number
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
  }, "examId_exerciseId">

  export type ExamExerciseOrderByWithAggregationInput = {
    examId?: SortOrder
    exerciseId?: SortOrder
    order?: SortOrder
    _count?: ExamExerciseCountOrderByAggregateInput
    _avg?: ExamExerciseAvgOrderByAggregateInput
    _max?: ExamExerciseMaxOrderByAggregateInput
    _min?: ExamExerciseMinOrderByAggregateInput
    _sum?: ExamExerciseSumOrderByAggregateInput
  }

  export type ExamExerciseScalarWhereWithAggregatesInput = {
    AND?: ExamExerciseScalarWhereWithAggregatesInput | ExamExerciseScalarWhereWithAggregatesInput[]
    OR?: ExamExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExamExerciseScalarWhereWithAggregatesInput | ExamExerciseScalarWhereWithAggregatesInput[]
    examId?: StringWithAggregatesFilter<"ExamExercise"> | string
    exerciseId?: StringWithAggregatesFilter<"ExamExercise"> | string
    order?: IntWithAggregatesFilter<"ExamExercise"> | number
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: StringFilter<"Material"> | string
    name?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    url?: StringNullableFilter<"Material"> | string | null
    type?: EnumMaterialTypeFilter<"Material"> | $Enums.MaterialType
    courseId?: StringNullableFilter<"Material"> | string | null
    moduleId?: StringNullableFilter<"Material"> | string | null
    topicId?: StringNullableFilter<"Material"> | string | null
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    creatorId?: StringFilter<"Material"> | string
    ownerId?: StringFilter<"Material"> | string
    publishStatus?: EnumPublishStatusEnumFilter<"Material"> | $Enums.PublishStatusEnum
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    topic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
    comments?: CommentListRelationFilter
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    owner?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    forSale?: XOR<ShopItemForSaleNullableScalarRelationFilter, ShopItemForSaleWhereInput> | null
    forRent?: XOR<ShopItemForRentNullableScalarRelationFilter, ShopItemForRentWhereInput> | null
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    type?: SortOrder
    courseId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    publishStatus?: SortOrder
    course?: CourseOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    creator?: TeacherOrderByWithRelationInput
    owner?: TeacherOrderByWithRelationInput
    forSale?: ShopItemForSaleOrderByWithRelationInput
    forRent?: ShopItemForRentOrderByWithRelationInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    name?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    url?: StringNullableFilter<"Material"> | string | null
    type?: EnumMaterialTypeFilter<"Material"> | $Enums.MaterialType
    courseId?: StringNullableFilter<"Material"> | string | null
    moduleId?: StringNullableFilter<"Material"> | string | null
    topicId?: StringNullableFilter<"Material"> | string | null
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    creatorId?: StringFilter<"Material"> | string
    ownerId?: StringFilter<"Material"> | string
    publishStatus?: EnumPublishStatusEnumFilter<"Material"> | $Enums.PublishStatusEnum
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    topic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
    comments?: CommentListRelationFilter
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    owner?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    forSale?: XOR<ShopItemForSaleNullableScalarRelationFilter, ShopItemForSaleWhereInput> | null
    forRent?: XOR<ShopItemForRentNullableScalarRelationFilter, ShopItemForRentWhereInput> | null
  }, "id">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    type?: SortOrder
    courseId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    publishStatus?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Material"> | string
    name?: StringWithAggregatesFilter<"Material"> | string
    description?: StringNullableWithAggregatesFilter<"Material"> | string | null
    url?: StringNullableWithAggregatesFilter<"Material"> | string | null
    type?: EnumMaterialTypeWithAggregatesFilter<"Material"> | $Enums.MaterialType
    courseId?: StringNullableWithAggregatesFilter<"Material"> | string | null
    moduleId?: StringNullableWithAggregatesFilter<"Material"> | string | null
    topicId?: StringNullableWithAggregatesFilter<"Material"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Material"> | string
    ownerId?: StringWithAggregatesFilter<"Material"> | string
    publishStatus?: EnumPublishStatusEnumWithAggregatesFilter<"Material"> | $Enums.PublishStatusEnum
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    courseId?: StringNullableFilter<"Comment"> | string | null
    moduleId?: StringNullableFilter<"Comment"> | string | null
    topicId?: StringNullableFilter<"Comment"> | string | null
    materialId?: StringNullableFilter<"Comment"> | string | null
    enrollmentId?: StringNullableFilter<"Comment"> | string | null
    classId?: StringNullableFilter<"Comment"> | string | null
    teamId?: StringNullableFilter<"Comment"> | string | null
    eventId?: StringNullableFilter<"Comment"> | string | null
    lessonId?: StringNullableFilter<"Comment"> | string | null
    examId?: StringNullableFilter<"Comment"> | string | null
    exerciseId?: StringNullableFilter<"Comment"> | string | null
    studentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    topic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    enrollment?: XOR<EnrollmentNullableScalarRelationFilter, EnrollmentWhereInput> | null
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    event?: XOR<EventNullableScalarRelationFilter, EventWhereInput> | null
    lesson?: XOR<LessonNullableScalarRelationFilter, LessonWhereInput> | null
    exam?: XOR<ExamNullableScalarRelationFilter, ExamWhereInput> | null
    exercise?: XOR<ExerciseNullableScalarRelationFilter, ExerciseWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    materialId?: SortOrderInput | SortOrder
    enrollmentId?: SortOrderInput | SortOrder
    classId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    lessonId?: SortOrderInput | SortOrder
    examId?: SortOrderInput | SortOrder
    exerciseId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
    enrollment?: EnrollmentOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    courseId?: StringNullableFilter<"Comment"> | string | null
    moduleId?: StringNullableFilter<"Comment"> | string | null
    topicId?: StringNullableFilter<"Comment"> | string | null
    materialId?: StringNullableFilter<"Comment"> | string | null
    enrollmentId?: StringNullableFilter<"Comment"> | string | null
    classId?: StringNullableFilter<"Comment"> | string | null
    teamId?: StringNullableFilter<"Comment"> | string | null
    eventId?: StringNullableFilter<"Comment"> | string | null
    lessonId?: StringNullableFilter<"Comment"> | string | null
    examId?: StringNullableFilter<"Comment"> | string | null
    exerciseId?: StringNullableFilter<"Comment"> | string | null
    studentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    topic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    enrollment?: XOR<EnrollmentNullableScalarRelationFilter, EnrollmentWhereInput> | null
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    event?: XOR<EventNullableScalarRelationFilter, EventWhereInput> | null
    lesson?: XOR<LessonNullableScalarRelationFilter, LessonWhereInput> | null
    exam?: XOR<ExamNullableScalarRelationFilter, ExamWhereInput> | null
    exercise?: XOR<ExerciseNullableScalarRelationFilter, ExerciseWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    materialId?: SortOrderInput | SortOrder
    enrollmentId?: SortOrderInput | SortOrder
    classId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    lessonId?: SortOrderInput | SortOrder
    examId?: SortOrderInput | SortOrder
    exerciseId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    courseId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    moduleId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    topicId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    materialId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    enrollmentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    classId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    eventId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    lessonId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    examId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    exerciseId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    studentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    classId?: StringFilter<"Enrollment"> | string
    status?: EnumEnrollmentStatusEnumFilter<"Enrollment"> | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFilter<"Enrollment"> | Date | string
    endDate?: DateTimeFilter<"Enrollment"> | Date | string
    totalPrice?: IntNullableFilter<"Enrollment"> | number | null
    currency?: EnumCurrencyTypeEnumFilter<"Enrollment"> | $Enums.CurrencyTypeEnum
    teacherId?: StringNullableFilter<"Enrollment"> | string | null
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    holidays?: HolidayListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    classId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalPrice?: SortOrderInput | SortOrder
    currency?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    holidays?: HolidayOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_classId?: EnrollmentCourseIdClassIdCompoundUniqueInput
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    courseId?: StringFilter<"Enrollment"> | string
    classId?: StringFilter<"Enrollment"> | string
    status?: EnumEnrollmentStatusEnumFilter<"Enrollment"> | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFilter<"Enrollment"> | Date | string
    endDate?: DateTimeFilter<"Enrollment"> | Date | string
    totalPrice?: IntNullableFilter<"Enrollment"> | number | null
    currency?: EnumCurrencyTypeEnumFilter<"Enrollment"> | $Enums.CurrencyTypeEnum
    teacherId?: StringNullableFilter<"Enrollment"> | string | null
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    holidays?: HolidayListRelationFilter
    comments?: CommentListRelationFilter
  }, "id" | "courseId_classId">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    classId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalPrice?: SortOrderInput | SortOrder
    currency?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _avg?: EnrollmentAvgOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
    _sum?: EnrollmentSumOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enrollment"> | string
    courseId?: StringWithAggregatesFilter<"Enrollment"> | string
    classId?: StringWithAggregatesFilter<"Enrollment"> | string
    status?: EnumEnrollmentStatusEnumWithAggregatesFilter<"Enrollment"> | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    totalPrice?: IntNullableWithAggregatesFilter<"Enrollment"> | number | null
    currency?: EnumCurrencyTypeEnumWithAggregatesFilter<"Enrollment"> | $Enums.CurrencyTypeEnum
    teacherId?: StringNullableWithAggregatesFilter<"Enrollment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    color?: StringNullableFilter<"Class"> | string | null
    courseId?: StringFilter<"Class"> | string
    teacherId?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    students?: StudentListRelationFilter
    teams?: TeamListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    courseId?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    color?: StringNullableFilter<"Class"> | string | null
    courseId?: StringFilter<"Class"> | string
    teacherId?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    students?: StudentListRelationFilter
    teams?: TeamListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    comments?: CommentListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    courseId?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    description?: StringNullableWithAggregatesFilter<"Class"> | string | null
    color?: StringNullableWithAggregatesFilter<"Class"> | string | null
    courseId?: StringWithAggregatesFilter<"Class"> | string
    teacherId?: StringNullableWithAggregatesFilter<"Class"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type HolidayWhereInput = {
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    id?: StringFilter<"Holiday"> | string
    name?: StringFilter<"Holiday"> | string
    startDate?: DateTimeFilter<"Holiday"> | Date | string
    endDate?: DateTimeFilter<"Holiday"> | Date | string
    enrollmentId?: StringFilter<"Holiday"> | string
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
    enrollment?: XOR<EnrollmentScalarRelationFilter, EnrollmentWhereInput>
  }

  export type HolidayOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    enrollmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enrollment?: EnrollmentOrderByWithRelationInput
  }

  export type HolidayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    name?: StringFilter<"Holiday"> | string
    startDate?: DateTimeFilter<"Holiday"> | Date | string
    endDate?: DateTimeFilter<"Holiday"> | Date | string
    enrollmentId?: StringFilter<"Holiday"> | string
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
    enrollment?: XOR<EnrollmentScalarRelationFilter, EnrollmentWhereInput>
  }, "id">

  export type HolidayOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    enrollmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HolidayCountOrderByAggregateInput
    _max?: HolidayMaxOrderByAggregateInput
    _min?: HolidayMinOrderByAggregateInput
  }

  export type HolidayScalarWhereWithAggregatesInput = {
    AND?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    OR?: HolidayScalarWhereWithAggregatesInput[]
    NOT?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Holiday"> | string
    name?: StringWithAggregatesFilter<"Holiday"> | string
    startDate?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    enrollmentId?: StringWithAggregatesFilter<"Holiday"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
  }

  export type LessonScheduleWhereInput = {
    AND?: LessonScheduleWhereInput | LessonScheduleWhereInput[]
    OR?: LessonScheduleWhereInput[]
    NOT?: LessonScheduleWhereInput | LessonScheduleWhereInput[]
    id?: StringFilter<"LessonSchedule"> | string
    lessonId?: StringFilter<"LessonSchedule"> | string
    dateTime?: DateTimeFilter<"LessonSchedule"> | Date | string
    duration?: IntFilter<"LessonSchedule"> | number
    createdAt?: DateTimeFilter<"LessonSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"LessonSchedule"> | Date | string
    teacherId?: StringNullableFilter<"LessonSchedule"> | string | null
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
  }

  export type LessonScheduleOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    dateTime?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    lesson?: LessonOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
  }

  export type LessonScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonScheduleWhereInput | LessonScheduleWhereInput[]
    OR?: LessonScheduleWhereInput[]
    NOT?: LessonScheduleWhereInput | LessonScheduleWhereInput[]
    lessonId?: StringFilter<"LessonSchedule"> | string
    dateTime?: DateTimeFilter<"LessonSchedule"> | Date | string
    duration?: IntFilter<"LessonSchedule"> | number
    createdAt?: DateTimeFilter<"LessonSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"LessonSchedule"> | Date | string
    teacherId?: StringNullableFilter<"LessonSchedule"> | string | null
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
  }, "id">

  export type LessonScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    dateTime?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    _count?: LessonScheduleCountOrderByAggregateInput
    _avg?: LessonScheduleAvgOrderByAggregateInput
    _max?: LessonScheduleMaxOrderByAggregateInput
    _min?: LessonScheduleMinOrderByAggregateInput
    _sum?: LessonScheduleSumOrderByAggregateInput
  }

  export type LessonScheduleScalarWhereWithAggregatesInput = {
    AND?: LessonScheduleScalarWhereWithAggregatesInput | LessonScheduleScalarWhereWithAggregatesInput[]
    OR?: LessonScheduleScalarWhereWithAggregatesInput[]
    NOT?: LessonScheduleScalarWhereWithAggregatesInput | LessonScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonSchedule"> | string
    lessonId?: StringWithAggregatesFilter<"LessonSchedule"> | string
    dateTime?: DateTimeWithAggregatesFilter<"LessonSchedule"> | Date | string
    duration?: IntWithAggregatesFilter<"LessonSchedule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LessonSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LessonSchedule"> | Date | string
    teacherId?: StringNullableWithAggregatesFilter<"LessonSchedule"> | string | null
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    type?: EnumEventTypeEnumFilter<"Event"> | $Enums.EventTypeEnum
    courseId?: StringNullableFilter<"Event"> | string | null
    moduleId?: StringNullableFilter<"Event"> | string | null
    creatorId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    comments?: CommentListRelationFilter
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    courseId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    creator?: TeacherOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    type?: EnumEventTypeEnumFilter<"Event"> | $Enums.EventTypeEnum
    courseId?: StringNullableFilter<"Event"> | string | null
    moduleId?: StringNullableFilter<"Event"> | string | null
    creatorId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    comments?: CommentListRelationFilter
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    courseId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    type?: EnumEventTypeEnumWithAggregatesFilter<"Event"> | $Enums.EventTypeEnum
    courseId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    moduleId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    creatorId?: StringWithAggregatesFilter<"Event"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    classId?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    teacherId?: StringNullableFilter<"Team"> | string | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    students?: StudentListRelationFilter
    exercises?: ExerciseListRelationFilter
    comments?: CommentListRelationFilter
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    class?: ClassOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    exercises?: ExerciseOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    teacher?: TeacherOrderByWithRelationInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    classId?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    teacherId?: StringNullableFilter<"Team"> | string | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    students?: StudentListRelationFilter
    exercises?: ExerciseListRelationFilter
    comments?: CommentListRelationFilter
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    classId?: StringWithAggregatesFilter<"Team"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    teacherId?: StringNullableWithAggregatesFilter<"Team"> | string | null
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    description?: StringNullableFilter<"Client"> | string | null
    creatorId?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    exercises?: ExerciseListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: TeacherOrderByWithRelationInput
    exercises?: ExerciseOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    description?: StringNullableFilter<"Client"> | string | null
    creatorId?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    creator?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    exercises?: ExerciseListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    description?: StringNullableWithAggregatesFilter<"Client"> | string | null
    creatorId?: StringWithAggregatesFilter<"Client"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringNullableFilter<"Notification"> | string | null
    message?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeEnumFilter<"Notification"> | $Enums.NotificationTypeEnum
    teacherId?: StringNullableFilter<"Notification"> | string | null
    studentId?: StringNullableFilter<"Notification"> | string | null
    seen?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    type?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    seen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringNullableFilter<"Notification"> | string | null
    message?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeEnumFilter<"Notification"> | $Enums.NotificationTypeEnum
    teacherId?: StringNullableFilter<"Notification"> | string | null
    studentId?: StringNullableFilter<"Notification"> | string | null
    seen?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    type?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    seen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    message?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeEnumWithAggregatesFilter<"Notification"> | $Enums.NotificationTypeEnum
    teacherId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    studentId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    seen?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ShopItemForSaleWhereInput = {
    AND?: ShopItemForSaleWhereInput | ShopItemForSaleWhereInput[]
    OR?: ShopItemForSaleWhereInput[]
    NOT?: ShopItemForSaleWhereInput | ShopItemForSaleWhereInput[]
    id?: StringFilter<"ShopItemForSale"> | string
    itemType?: EnumShopItemTypeEnumFilter<"ShopItemForSale"> | $Enums.ShopItemTypeEnum
    itemId?: StringFilter<"ShopItemForSale"> | string
    sellPrice?: IntFilter<"ShopItemForSale"> | number
    currency?: EnumCurrencyTypeEnumFilter<"ShopItemForSale"> | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFilter<"ShopItemForSale"> | Date | string
    updatedAt?: DateTimeFilter<"ShopItemForSale"> | Date | string
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    exercise?: XOR<ExerciseNullableScalarRelationFilter, ExerciseWhereInput> | null
    exam?: XOR<ExamNullableScalarRelationFilter, ExamWhereInput> | null
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    purchases?: PurchasedItemListRelationFilter
  }

  export type ShopItemForSaleOrderByWithRelationInput = {
    id?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    sellPrice?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
    purchases?: PurchasedItemOrderByRelationAggregateInput
  }

  export type ShopItemForSaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    itemId?: string
    itemType_itemId?: ShopItemForSaleItemTypeItemIdCompoundUniqueInput
    AND?: ShopItemForSaleWhereInput | ShopItemForSaleWhereInput[]
    OR?: ShopItemForSaleWhereInput[]
    NOT?: ShopItemForSaleWhereInput | ShopItemForSaleWhereInput[]
    itemType?: EnumShopItemTypeEnumFilter<"ShopItemForSale"> | $Enums.ShopItemTypeEnum
    sellPrice?: IntFilter<"ShopItemForSale"> | number
    currency?: EnumCurrencyTypeEnumFilter<"ShopItemForSale"> | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFilter<"ShopItemForSale"> | Date | string
    updatedAt?: DateTimeFilter<"ShopItemForSale"> | Date | string
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    exercise?: XOR<ExerciseNullableScalarRelationFilter, ExerciseWhereInput> | null
    exam?: XOR<ExamNullableScalarRelationFilter, ExamWhereInput> | null
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    purchases?: PurchasedItemListRelationFilter
  }, "id" | "itemId" | "itemType_itemId">

  export type ShopItemForSaleOrderByWithAggregationInput = {
    id?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    sellPrice?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopItemForSaleCountOrderByAggregateInput
    _avg?: ShopItemForSaleAvgOrderByAggregateInput
    _max?: ShopItemForSaleMaxOrderByAggregateInput
    _min?: ShopItemForSaleMinOrderByAggregateInput
    _sum?: ShopItemForSaleSumOrderByAggregateInput
  }

  export type ShopItemForSaleScalarWhereWithAggregatesInput = {
    AND?: ShopItemForSaleScalarWhereWithAggregatesInput | ShopItemForSaleScalarWhereWithAggregatesInput[]
    OR?: ShopItemForSaleScalarWhereWithAggregatesInput[]
    NOT?: ShopItemForSaleScalarWhereWithAggregatesInput | ShopItemForSaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopItemForSale"> | string
    itemType?: EnumShopItemTypeEnumWithAggregatesFilter<"ShopItemForSale"> | $Enums.ShopItemTypeEnum
    itemId?: StringWithAggregatesFilter<"ShopItemForSale"> | string
    sellPrice?: IntWithAggregatesFilter<"ShopItemForSale"> | number
    currency?: EnumCurrencyTypeEnumWithAggregatesFilter<"ShopItemForSale"> | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeWithAggregatesFilter<"ShopItemForSale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopItemForSale"> | Date | string
  }

  export type ShopItemForRentWhereInput = {
    AND?: ShopItemForRentWhereInput | ShopItemForRentWhereInput[]
    OR?: ShopItemForRentWhereInput[]
    NOT?: ShopItemForRentWhereInput | ShopItemForRentWhereInput[]
    id?: StringFilter<"ShopItemForRent"> | string
    itemType?: EnumShopItemTypeEnumFilter<"ShopItemForRent"> | $Enums.ShopItemTypeEnum
    itemId?: StringFilter<"ShopItemForRent"> | string
    rentPrice?: IntFilter<"ShopItemForRent"> | number
    rentPeriod?: IntFilter<"ShopItemForRent"> | number
    currency?: EnumCurrencyTypeEnumFilter<"ShopItemForRent"> | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFilter<"ShopItemForRent"> | Date | string
    updatedAt?: DateTimeFilter<"ShopItemForRent"> | Date | string
    isVisible?: BoolFilter<"ShopItemForRent"> | boolean
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    exercise?: XOR<ExerciseNullableScalarRelationFilter, ExerciseWhereInput> | null
    exam?: XOR<ExamNullableScalarRelationFilter, ExamWhereInput> | null
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    rentalPeriods?: RentalPeriodListRelationFilter
  }

  export type ShopItemForRentOrderByWithRelationInput = {
    id?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    rentPrice?: SortOrder
    rentPeriod?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVisible?: SortOrder
    course?: CourseOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
    rentalPeriods?: RentalPeriodOrderByRelationAggregateInput
  }

  export type ShopItemForRentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    itemId?: string
    itemType_itemId?: ShopItemForRentItemTypeItemIdCompoundUniqueInput
    AND?: ShopItemForRentWhereInput | ShopItemForRentWhereInput[]
    OR?: ShopItemForRentWhereInput[]
    NOT?: ShopItemForRentWhereInput | ShopItemForRentWhereInput[]
    itemType?: EnumShopItemTypeEnumFilter<"ShopItemForRent"> | $Enums.ShopItemTypeEnum
    rentPrice?: IntFilter<"ShopItemForRent"> | number
    rentPeriod?: IntFilter<"ShopItemForRent"> | number
    currency?: EnumCurrencyTypeEnumFilter<"ShopItemForRent"> | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFilter<"ShopItemForRent"> | Date | string
    updatedAt?: DateTimeFilter<"ShopItemForRent"> | Date | string
    isVisible?: BoolFilter<"ShopItemForRent"> | boolean
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    exercise?: XOR<ExerciseNullableScalarRelationFilter, ExerciseWhereInput> | null
    exam?: XOR<ExamNullableScalarRelationFilter, ExamWhereInput> | null
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    rentalPeriods?: RentalPeriodListRelationFilter
  }, "id" | "itemId" | "itemType_itemId">

  export type ShopItemForRentOrderByWithAggregationInput = {
    id?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    rentPrice?: SortOrder
    rentPeriod?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVisible?: SortOrder
    _count?: ShopItemForRentCountOrderByAggregateInput
    _avg?: ShopItemForRentAvgOrderByAggregateInput
    _max?: ShopItemForRentMaxOrderByAggregateInput
    _min?: ShopItemForRentMinOrderByAggregateInput
    _sum?: ShopItemForRentSumOrderByAggregateInput
  }

  export type ShopItemForRentScalarWhereWithAggregatesInput = {
    AND?: ShopItemForRentScalarWhereWithAggregatesInput | ShopItemForRentScalarWhereWithAggregatesInput[]
    OR?: ShopItemForRentScalarWhereWithAggregatesInput[]
    NOT?: ShopItemForRentScalarWhereWithAggregatesInput | ShopItemForRentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopItemForRent"> | string
    itemType?: EnumShopItemTypeEnumWithAggregatesFilter<"ShopItemForRent"> | $Enums.ShopItemTypeEnum
    itemId?: StringWithAggregatesFilter<"ShopItemForRent"> | string
    rentPrice?: IntWithAggregatesFilter<"ShopItemForRent"> | number
    rentPeriod?: IntWithAggregatesFilter<"ShopItemForRent"> | number
    currency?: EnumCurrencyTypeEnumWithAggregatesFilter<"ShopItemForRent"> | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeWithAggregatesFilter<"ShopItemForRent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopItemForRent"> | Date | string
    isVisible?: BoolWithAggregatesFilter<"ShopItemForRent"> | boolean
  }

  export type PurchasedItemWhereInput = {
    AND?: PurchasedItemWhereInput | PurchasedItemWhereInput[]
    OR?: PurchasedItemWhereInput[]
    NOT?: PurchasedItemWhereInput | PurchasedItemWhereInput[]
    id?: StringFilter<"PurchasedItem"> | string
    teacherId?: StringFilter<"PurchasedItem"> | string
    shopItemId?: StringFilter<"PurchasedItem"> | string
    purchaseDate?: DateTimeFilter<"PurchasedItem"> | Date | string
    createdAt?: DateTimeFilter<"PurchasedItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasedItem"> | Date | string
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    shopItem?: XOR<ShopItemForSaleScalarRelationFilter, ShopItemForSaleWhereInput>
  }

  export type PurchasedItemOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    shopItemId?: SortOrder
    purchaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    shopItem?: ShopItemForSaleOrderByWithRelationInput
  }

  export type PurchasedItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teacherId_shopItemId?: PurchasedItemTeacherIdShopItemIdCompoundUniqueInput
    AND?: PurchasedItemWhereInput | PurchasedItemWhereInput[]
    OR?: PurchasedItemWhereInput[]
    NOT?: PurchasedItemWhereInput | PurchasedItemWhereInput[]
    teacherId?: StringFilter<"PurchasedItem"> | string
    shopItemId?: StringFilter<"PurchasedItem"> | string
    purchaseDate?: DateTimeFilter<"PurchasedItem"> | Date | string
    createdAt?: DateTimeFilter<"PurchasedItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasedItem"> | Date | string
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    shopItem?: XOR<ShopItemForSaleScalarRelationFilter, ShopItemForSaleWhereInput>
  }, "id" | "teacherId_shopItemId">

  export type PurchasedItemOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    shopItemId?: SortOrder
    purchaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchasedItemCountOrderByAggregateInput
    _max?: PurchasedItemMaxOrderByAggregateInput
    _min?: PurchasedItemMinOrderByAggregateInput
  }

  export type PurchasedItemScalarWhereWithAggregatesInput = {
    AND?: PurchasedItemScalarWhereWithAggregatesInput | PurchasedItemScalarWhereWithAggregatesInput[]
    OR?: PurchasedItemScalarWhereWithAggregatesInput[]
    NOT?: PurchasedItemScalarWhereWithAggregatesInput | PurchasedItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchasedItem"> | string
    teacherId?: StringWithAggregatesFilter<"PurchasedItem"> | string
    shopItemId?: StringWithAggregatesFilter<"PurchasedItem"> | string
    purchaseDate?: DateTimeWithAggregatesFilter<"PurchasedItem"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PurchasedItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchasedItem"> | Date | string
  }

  export type RentalPeriodWhereInput = {
    AND?: RentalPeriodWhereInput | RentalPeriodWhereInput[]
    OR?: RentalPeriodWhereInput[]
    NOT?: RentalPeriodWhereInput | RentalPeriodWhereInput[]
    id?: StringFilter<"RentalPeriod"> | string
    teacherId?: StringFilter<"RentalPeriod"> | string
    shopItemId?: StringFilter<"RentalPeriod"> | string
    rentStartDate?: DateTimeFilter<"RentalPeriod"> | Date | string
    rentEndDate?: DateTimeFilter<"RentalPeriod"> | Date | string
    createdAt?: DateTimeFilter<"RentalPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"RentalPeriod"> | Date | string
    isActive?: BoolFilter<"RentalPeriod"> | boolean
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    shopItem?: XOR<ShopItemForRentScalarRelationFilter, ShopItemForRentWhereInput>
  }

  export type RentalPeriodOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    shopItemId?: SortOrder
    rentStartDate?: SortOrder
    rentEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    shopItem?: ShopItemForRentOrderByWithRelationInput
  }

  export type RentalPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RentalPeriodWhereInput | RentalPeriodWhereInput[]
    OR?: RentalPeriodWhereInput[]
    NOT?: RentalPeriodWhereInput | RentalPeriodWhereInput[]
    teacherId?: StringFilter<"RentalPeriod"> | string
    shopItemId?: StringFilter<"RentalPeriod"> | string
    rentStartDate?: DateTimeFilter<"RentalPeriod"> | Date | string
    rentEndDate?: DateTimeFilter<"RentalPeriod"> | Date | string
    createdAt?: DateTimeFilter<"RentalPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"RentalPeriod"> | Date | string
    isActive?: BoolFilter<"RentalPeriod"> | boolean
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    shopItem?: XOR<ShopItemForRentScalarRelationFilter, ShopItemForRentWhereInput>
  }, "id">

  export type RentalPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    shopItemId?: SortOrder
    rentStartDate?: SortOrder
    rentEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    _count?: RentalPeriodCountOrderByAggregateInput
    _max?: RentalPeriodMaxOrderByAggregateInput
    _min?: RentalPeriodMinOrderByAggregateInput
  }

  export type RentalPeriodScalarWhereWithAggregatesInput = {
    AND?: RentalPeriodScalarWhereWithAggregatesInput | RentalPeriodScalarWhereWithAggregatesInput[]
    OR?: RentalPeriodScalarWhereWithAggregatesInput[]
    NOT?: RentalPeriodScalarWhereWithAggregatesInput | RentalPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RentalPeriod"> | string
    teacherId?: StringWithAggregatesFilter<"RentalPeriod"> | string
    shopItemId?: StringWithAggregatesFilter<"RentalPeriod"> | string
    rentStartDate?: DateTimeWithAggregatesFilter<"RentalPeriod"> | Date | string
    rentEndDate?: DateTimeWithAggregatesFilter<"RentalPeriod"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RentalPeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RentalPeriod"> | Date | string
    isActive?: BoolWithAggregatesFilter<"RentalPeriod"> | boolean
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateInput = {
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: string
    roleId: string
  }

  export type UserRoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyInput = {
    userId: string
    roleId: string
  }

  export type UserRoleUpdateManyMutationInput = {

  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    userId: string
    specialization?: string | null
  }

  export type TeacherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentCreateInput = {
    id?: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    classes?: ClassCreateNestedManyWithoutStudentsInput
    teams?: TeamCreateNestedManyWithoutStudentsInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
    comments?: CommentCreateNestedManyWithoutStudentInput
    addedBy: TeacherCreateNestedOneWithoutAddedStudentsInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedById: string
    classes?: ClassUncheckedCreateNestedManyWithoutStudentsInput
    teams?: TeamUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
    comments?: CommentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: ClassUpdateManyWithoutStudentsNestedInput
    teams?: TeamUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
    comments?: CommentUpdateManyWithoutStudentNestedInput
    addedBy?: TeacherUpdateOneRequiredWithoutAddedStudentsNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: StringFieldUpdateOperationsInput | string
    classes?: ClassUncheckedUpdateManyWithoutStudentsNestedInput
    teams?: TeamUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedById: string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedCoursesInput
    owner: TeacherCreateNestedOneWithoutOwnedCoursesInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    materials?: MaterialCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    events?: EventCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutCourseInput
    comments?: CommentCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    materials?: MaterialUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    events?: EventUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutCourseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    materials?: MaterialUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    events?: EventUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutCourseNestedInput
    comments?: CommentUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    events?: EventUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCourseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ModuleCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type LessonCreateInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutLessonsInput
    schedules?: LessonScheduleCreateNestedManyWithoutLessonInput
    comments?: CommentCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    order: number
    moduleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: LessonScheduleUncheckedCreateNestedManyWithoutLessonInput
    comments?: CommentUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    schedules?: LessonScheduleUpdateManyWithoutLessonNestedInput
    comments?: CommentUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    moduleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: LessonScheduleUncheckedUpdateManyWithoutLessonNestedInput
    comments?: CommentUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    order: number
    moduleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    moduleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicCreateInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    module: ModuleCreateNestedOneWithoutTopicsInput
    materials?: MaterialCreateNestedManyWithoutTopicInput
    exercises?: ExerciseCreateNestedManyWithoutTopicInput
    objectives?: ObjectiveCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    moduleId: string
    materials?: MaterialUncheckedCreateNestedManyWithoutTopicInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutTopicInput
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    module?: ModuleUpdateOneRequiredWithoutTopicsNestedInput
    materials?: MaterialUpdateManyWithoutTopicNestedInput
    exercises?: ExerciseUpdateManyWithoutTopicNestedInput
    objectives?: ObjectiveUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    moduleId?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUncheckedUpdateManyWithoutTopicNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutTopicNestedInput
    objectives?: ObjectiveUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    moduleId: string
  }

  export type TopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectiveCreateInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutObjectivesInput
  }

  export type ObjectiveUncheckedCreateInput = {
    id?: string
    description: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObjectiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutObjectivesNestedInput
  }

  export type ObjectiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObjectiveCreateManyInput = {
    id?: string
    description: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObjectiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObjectiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentCreateInput = {
    id?: string
    courseId: string
    hourlyRate: number
    currency?: $Enums.CurrencyTypeEnum
    startDate: Date | string
    endDate: Date | string
    module: ModuleCreateNestedOneWithoutAssignmentsInput
    teacher: TeacherCreateNestedOneWithoutModuleAssignmentsInput
  }

  export type ModuleAssignmentUncheckedCreateInput = {
    id?: string
    moduleId: string
    teacherId: string
    courseId: string
    hourlyRate: number
    currency?: $Enums.CurrencyTypeEnum
    startDate: Date | string
    endDate: Date | string
  }

  export type ModuleAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutAssignmentsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutModuleAssignmentsNestedInput
  }

  export type ModuleAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentCreateManyInput = {
    id?: string
    moduleId: string
    teacherId: string
    courseId: string
    hourlyRate: number
    currency?: $Enums.CurrencyTypeEnum
    startDate: Date | string
    endDate: Date | string
  }

  export type ModuleAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    topic?: TopicCreateNestedOneWithoutExercisesInput
    examExercises?: ExamExerciseCreateNestedManyWithoutExerciseInput
    creator: TeacherCreateNestedOneWithoutCreatedExercisesInput
    owner: TeacherCreateNestedOneWithoutOwnedExercisesInput
    teams?: TeamCreateNestedManyWithoutExercisesInput
    client?: ClientCreateNestedOneWithoutExercisesInput
    comments?: CommentCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedCreateNestedManyWithoutExerciseInput
    teams?: TeamUncheckedCreateNestedManyWithoutExercisesInput
    comments?: CommentUncheckedCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topic?: TopicUpdateOneWithoutExercisesNestedInput
    examExercises?: ExamExerciseUpdateManyWithoutExerciseNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExercisesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExercisesNestedInput
    teams?: TeamUpdateManyWithoutExercisesNestedInput
    client?: ClientUpdateOneWithoutExercisesNestedInput
    comments?: CommentUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    teams?: TeamUncheckedUpdateManyWithoutExercisesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ExamCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    date: Date | string
    duration: number
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    module: ModuleCreateNestedOneWithoutExamsInput
    exercises?: ExamExerciseCreateNestedManyWithoutExamInput
    creator: TeacherCreateNestedOneWithoutCreatedExamsInput
    owner: TeacherCreateNestedOneWithoutOwnedExamsInput
    comments?: CommentCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExamInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date | string
    duration: number
    maxScore: number
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedCreateNestedManyWithoutExamInput
    comments?: CommentUncheckedCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExamInput
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    module?: ModuleUpdateOneRequiredWithoutExamsNestedInput
    exercises?: ExamExerciseUpdateManyWithoutExamNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExamsNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExamsNestedInput
    comments?: CommentUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    moduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedUpdateManyWithoutExamNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExamNestedInput
  }

  export type ExamCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date | string
    duration: number
    maxScore: number
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    moduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ExamExerciseCreateInput = {
    order: number
    exam: ExamCreateNestedOneWithoutExercisesInput
    exercise: ExerciseCreateNestedOneWithoutExamExercisesInput
  }

  export type ExamExerciseUncheckedCreateInput = {
    examId: string
    exerciseId: string
    order: number
  }

  export type ExamExerciseUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    exam?: ExamUpdateOneRequiredWithoutExercisesNestedInput
    exercise?: ExerciseUpdateOneRequiredWithoutExamExercisesNestedInput
  }

  export type ExamExerciseUncheckedUpdateInput = {
    examId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ExamExerciseCreateManyInput = {
    examId: string
    exerciseId: string
    order: number
  }

  export type ExamExerciseUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ExamExerciseUncheckedUpdateManyInput = {
    examId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialCreateInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    course?: CourseCreateNestedOneWithoutMaterialsInput
    module?: ModuleCreateNestedOneWithoutMaterialsInput
    topic?: TopicCreateNestedOneWithoutMaterialsInput
    comments?: CommentCreateNestedManyWithoutMaterialInput
    creator: TeacherCreateNestedOneWithoutCreatedMaterialInput
    owner: TeacherCreateNestedOneWithoutOwnedMaterialInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    comments?: CommentUncheckedCreateNestedManyWithoutMaterialInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    course?: CourseUpdateOneWithoutMaterialsNestedInput
    module?: ModuleUpdateOneWithoutMaterialsNestedInput
    topic?: TopicUpdateOneWithoutMaterialsNestedInput
    comments?: CommentUpdateManyWithoutMaterialNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedMaterialNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedMaterialNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    comments?: CommentUncheckedUpdateManyWithoutMaterialNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type MaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateInput = {
    id?: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    class: ClassCreateNestedOneWithoutEnrollmentsInput
    teacher?: TeacherCreateNestedOneWithoutEnrollmentsInput
    holidays?: HolidayCreateNestedManyWithoutEnrollmentInput
    comments?: CommentCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: string
    courseId: string
    classId: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    holidays?: HolidayUncheckedCreateNestedManyWithoutEnrollmentInput
    comments?: CommentUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    class?: ClassUpdateOneRequiredWithoutEnrollmentsNestedInput
    teacher?: TeacherUpdateOneWithoutEnrollmentsNestedInput
    holidays?: HolidayUpdateManyWithoutEnrollmentNestedInput
    comments?: CommentUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holidays?: HolidayUncheckedUpdateManyWithoutEnrollmentNestedInput
    comments?: CommentUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentCreateManyInput = {
    id?: string
    courseId: string
    classId: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutClassesInput
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassesInput
    teams?: TeamCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    comments?: CommentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    courseId: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassesInput
    teams?: TeamUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    comments?: CommentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassesNestedInput
    teams?: TeamUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    comments?: CommentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassesNestedInput
    teams?: TeamUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    comments?: CommentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    courseId: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollment: EnrollmentCreateNestedOneWithoutHolidaysInput
  }

  export type HolidayUncheckedCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    enrollmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollment?: EnrollmentUpdateOneRequiredWithoutHolidaysNestedInput
  }

  export type HolidayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateManyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    enrollmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonScheduleCreateInput = {
    id?: string
    dateTime: Date | string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutSchedulesInput
    teacher?: TeacherCreateNestedOneWithoutLessonsScheduleInput
  }

  export type LessonScheduleUncheckedCreateInput = {
    id?: string
    lessonId: string
    dateTime: Date | string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
  }

  export type LessonScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutSchedulesNestedInput
    teacher?: TeacherUpdateOneWithoutLessonsScheduleNestedInput
  }

  export type LessonScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LessonScheduleCreateManyInput = {
    id?: string
    lessonId: string
    dateTime: Date | string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
  }

  export type LessonScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutEventsInput
    module?: ModuleCreateNestedOneWithoutEventsInput
    comments?: CommentCreateNestedManyWithoutEventInput
    creator: TeacherCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    courseId?: string | null
    moduleId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutEventsNestedInput
    module?: ModuleUpdateOneWithoutEventsNestedInput
    comments?: CommentUpdateManyWithoutEventNestedInput
    creator?: TeacherUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    courseId?: string | null
    moduleId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTeamsInput
    students?: StudentCreateNestedManyWithoutTeamsInput
    exercises?: ExerciseCreateNestedManyWithoutTeamsInput
    comments?: CommentCreateNestedManyWithoutTeamInput
    teacher?: TeacherCreateNestedOneWithoutTeamsInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
    students?: StudentUncheckedCreateNestedManyWithoutTeamsInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutTeamsInput
    comments?: CommentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTeamsNestedInput
    students?: StudentUpdateManyWithoutTeamsNestedInput
    exercises?: ExerciseUpdateManyWithoutTeamsNestedInput
    comments?: CommentUpdateManyWithoutTeamNestedInput
    teacher?: TeacherUpdateOneWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateManyWithoutTeamsNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutTeamsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: TeacherCreateNestedOneWithoutCreatedClientsInput
    exercises?: ExerciseCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: TeacherUpdateOneRequiredWithoutCreatedClientsNestedInput
    exercises?: ExerciseUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title?: string | null
    message?: string | null
    type: $Enums.NotificationTypeEnum
    seen?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutNotificationsInput
    student?: StudentCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title?: string | null
    message?: string | null
    type: $Enums.NotificationTypeEnum
    teacherId?: string | null
    studentId?: string | null
    seen?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeEnumFieldUpdateOperationsInput | $Enums.NotificationTypeEnum
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutNotificationsNestedInput
    student?: StudentUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeEnumFieldUpdateOperationsInput | $Enums.NotificationTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    title?: string | null
    message?: string | null
    type: $Enums.NotificationTypeEnum
    teacherId?: string | null
    studentId?: string | null
    seen?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeEnumFieldUpdateOperationsInput | $Enums.NotificationTypeEnum
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeEnumFieldUpdateOperationsInput | $Enums.NotificationTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemForSaleCreateInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutForSaleInput
    module?: ModuleCreateNestedOneWithoutForSaleInput
    exercise?: ExerciseCreateNestedOneWithoutForSaleInput
    exam?: ExamCreateNestedOneWithoutForSaleInput
    material?: MaterialCreateNestedOneWithoutForSaleInput
    purchases?: PurchasedItemCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleUncheckedCreateInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    itemId: string
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutForSaleNestedInput
    module?: ModuleUpdateOneWithoutForSaleNestedInput
    exercise?: ExerciseUpdateOneWithoutForSaleNestedInput
    exam?: ExamUpdateOneWithoutForSaleNestedInput
    material?: MaterialUpdateOneWithoutForSaleNestedInput
    purchases?: PurchasedItemUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForSaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    itemId?: StringFieldUpdateOperationsInput | string
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchasedItemUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForSaleCreateManyInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    itemId: string
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopItemForSaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemForSaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    itemId?: StringFieldUpdateOperationsInput | string
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemForRentCreateInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    course?: CourseCreateNestedOneWithoutForRentInput
    module?: ModuleCreateNestedOneWithoutForRentInput
    exercise?: ExerciseCreateNestedOneWithoutForRentInput
    exam?: ExamCreateNestedOneWithoutForRentInput
    material?: MaterialCreateNestedOneWithoutForRentInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentUncheckedCreateInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    itemId: string
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutForRentNestedInput
    module?: ModuleUpdateOneWithoutForRentNestedInput
    exercise?: ExerciseUpdateOneWithoutForRentNestedInput
    exam?: ExamUpdateOneWithoutForRentNestedInput
    material?: MaterialUpdateOneWithoutForRentNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    itemId?: StringFieldUpdateOperationsInput | string
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentCreateManyInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    itemId: string
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
  }

  export type ShopItemForRentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShopItemForRentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    itemId?: StringFieldUpdateOperationsInput | string
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchasedItemCreateInput = {
    id?: string
    purchaseDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutPurchasesInput
    shopItem: ShopItemForSaleCreateNestedOneWithoutPurchasesInput
  }

  export type PurchasedItemUncheckedCreateInput = {
    id?: string
    teacherId: string
    shopItemId: string
    purchaseDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasedItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutPurchasesNestedInput
    shopItem?: ShopItemForSaleUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchasedItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    shopItemId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasedItemCreateManyInput = {
    id?: string
    teacherId: string
    shopItemId: string
    purchaseDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasedItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasedItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    shopItemId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalPeriodCreateInput = {
    id?: string
    rentStartDate: Date | string
    rentEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    teacher: TeacherCreateNestedOneWithoutRentalPeriodsInput
    shopItem: ShopItemForRentCreateNestedOneWithoutRentalPeriodsInput
  }

  export type RentalPeriodUncheckedCreateInput = {
    id?: string
    teacherId: string
    shopItemId: string
    rentStartDate: Date | string
    rentEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type RentalPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rentStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teacher?: TeacherUpdateOneRequiredWithoutRentalPeriodsNestedInput
    shopItem?: ShopItemForRentUpdateOneRequiredWithoutRentalPeriodsNestedInput
  }

  export type RentalPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    shopItemId?: StringFieldUpdateOperationsInput | string
    rentStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RentalPeriodCreateManyInput = {
    id?: string
    teacherId: string
    shopItemId: string
    rentStartDate: Date | string
    rentEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type RentalPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rentStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RentalPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    shopItemId?: StringFieldUpdateOperationsInput | string
    rentStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type TeacherNullableScalarRelationFilter = {
    is?: TeacherWhereInput | null
    isNot?: TeacherWhereInput | null
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    userApiToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessedAt?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    userApiToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessedAt?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    userApiToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessedAt?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    phoneNumber?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    phoneNumber?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    phoneNumber?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type ModuleAssignmentListRelationFilter = {
    every?: ModuleAssignmentWhereInput
    some?: ModuleAssignmentWhereInput
    none?: ModuleAssignmentWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type ExerciseListRelationFilter = {
    every?: ExerciseWhereInput
    some?: ExerciseWhereInput
    none?: ExerciseWhereInput
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PurchasedItemListRelationFilter = {
    every?: PurchasedItemWhereInput
    some?: PurchasedItemWhereInput
    none?: PurchasedItemWhereInput
  }

  export type RentalPeriodListRelationFilter = {
    every?: RentalPeriodWhereInput
    some?: RentalPeriodWhereInput
    none?: RentalPeriodWhereInput
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type LessonScheduleListRelationFilter = {
    every?: LessonScheduleWhereInput
    some?: LessonScheduleWhereInput
    none?: LessonScheduleWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type ModuleAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchasedItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RentalPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TeacherScalarRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    enrollYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addedById?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    enrollYear?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    enrollYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addedById?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    enrollYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addedById?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    enrollYear?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCourseStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatusEnum | EnumCourseStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatusEnum[] | ListEnumCourseStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatusEnum[] | ListEnumCourseStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusEnumFilter<$PrismaModel> | $Enums.CourseStatusEnum
  }

  export type EnumPublishStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatusEnum | EnumPublishStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatusEnum[] | ListEnumPublishStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatusEnum[] | ListEnumPublishStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusEnumFilter<$PrismaModel> | $Enums.PublishStatusEnum
  }

  export type ShopItemForSaleNullableScalarRelationFilter = {
    is?: ShopItemForSaleWhereInput | null
    isNot?: ShopItemForSaleWhereInput | null
  }

  export type ShopItemForRentNullableScalarRelationFilter = {
    is?: ShopItemForRentWhereInput | null
    isNot?: ShopItemForRentWhereInput | null
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    publishStatus?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    publishStatus?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    publishStatus?: SortOrder
  }

  export type EnumCourseStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatusEnum | EnumCourseStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatusEnum[] | ListEnumCourseStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatusEnum[] | ListEnumCourseStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusEnumFilter<$PrismaModel>
  }

  export type EnumPublishStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatusEnum | EnumPublishStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatusEnum[] | ListEnumPublishStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatusEnum[] | ListEnumPublishStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.PublishStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublishStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumPublishStatusEnumFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    totalHours?: SortOrder
    averageHoursPerLesson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    courseId?: SortOrder
    publishStatus?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    totalHours?: SortOrder
    averageHoursPerLesson?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    totalHours?: SortOrder
    averageHoursPerLesson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    courseId?: SortOrder
    publishStatus?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    totalHours?: SortOrder
    averageHoursPerLesson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    courseId?: SortOrder
    publishStatus?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    totalHours?: SortOrder
    averageHoursPerLesson?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ModuleScalarRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    moduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    moduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    moduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
  }

  export type ObjectiveListRelationFilter = {
    every?: ObjectiveWhereInput
    some?: ObjectiveWhereInput
    none?: ObjectiveWhereInput
  }

  export type ObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    moduleId?: SortOrder
  }

  export type TopicAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    moduleId?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    moduleId?: SortOrder
  }

  export type TopicSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TopicScalarRelationFilter = {
    is?: TopicWhereInput
    isNot?: TopicWhereInput
  }

  export type ObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCurrencyTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyTypeEnum | EnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyTypeEnum[] | ListEnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyTypeEnum[] | ListEnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyTypeEnumFilter<$PrismaModel> | $Enums.CurrencyTypeEnum
  }

  export type ModuleAssignmentModuleIdTeacherIdCourseIdStartDateEndDateCompoundUniqueInput = {
    moduleId: string
    teacherId: string
    courseId: string
    startDate: Date | string
    endDate: Date | string
  }

  export type ModuleAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    teacherId?: SortOrder
    courseId?: SortOrder
    hourlyRate?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type ModuleAssignmentAvgOrderByAggregateInput = {
    hourlyRate?: SortOrder
  }

  export type ModuleAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    teacherId?: SortOrder
    courseId?: SortOrder
    hourlyRate?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type ModuleAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    teacherId?: SortOrder
    courseId?: SortOrder
    hourlyRate?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type ModuleAssignmentSumOrderByAggregateInput = {
    hourlyRate?: SortOrder
  }

  export type EnumCurrencyTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyTypeEnum | EnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyTypeEnum[] | ListEnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyTypeEnum[] | ListEnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumCurrencyTypeEnumFilter<$PrismaModel>
  }

  export type EnumExerciseTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseTypeEnum | EnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseTypeEnum[] | ListEnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseTypeEnum[] | ListEnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeEnumFilter<$PrismaModel> | $Enums.ExerciseTypeEnum
  }

  export type EnumDifficultyLevelEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevelEnum | EnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevelEnum[] | ListEnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevelEnum[] | ListEnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelEnumFilter<$PrismaModel> | $Enums.DifficultyLevelEnum
  }

  export type TopicNullableScalarRelationFilter = {
    is?: TopicWhereInput | null
    isNot?: TopicWhereInput | null
  }

  export type ExamExerciseListRelationFilter = {
    every?: ExamExerciseWhereInput
    some?: ExamExerciseWhereInput
    none?: ExamExerciseWhereInput
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type ExamExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    timeLimit?: SortOrder
    topicId?: SortOrder
    isTeamExercise?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    publishStatus?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    points?: SortOrder
    timeLimit?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    timeLimit?: SortOrder
    topicId?: SortOrder
    isTeamExercise?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    publishStatus?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    timeLimit?: SortOrder
    topicId?: SortOrder
    isTeamExercise?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    publishStatus?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    points?: SortOrder
    timeLimit?: SortOrder
  }

  export type EnumExerciseTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseTypeEnum | EnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseTypeEnum[] | ListEnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseTypeEnum[] | ListEnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumExerciseTypeEnumFilter<$PrismaModel>
  }

  export type EnumDifficultyLevelEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevelEnum | EnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevelEnum[] | ListEnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevelEnum[] | ListEnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelEnumWithAggregatesFilter<$PrismaModel> | $Enums.DifficultyLevelEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyLevelEnumFilter<$PrismaModel>
    _max?: NestedEnumDifficultyLevelEnumFilter<$PrismaModel>
  }

  export type EnumExamTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamTypeEnum | EnumExamTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ExamTypeEnum[] | ListEnumExamTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamTypeEnum[] | ListEnumExamTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumExamTypeEnumFilter<$PrismaModel> | $Enums.ExamTypeEnum
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    moduleId?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    maxScore?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishStatus?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    duration?: SortOrder
    maxScore?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    moduleId?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    maxScore?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishStatus?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    moduleId?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    maxScore?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishStatus?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    duration?: SortOrder
    maxScore?: SortOrder
  }

  export type EnumExamTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamTypeEnum | EnumExamTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ExamTypeEnum[] | ListEnumExamTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamTypeEnum[] | ListEnumExamTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumExamTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.ExamTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumExamTypeEnumFilter<$PrismaModel>
  }

  export type ExamScalarRelationFilter = {
    is?: ExamWhereInput
    isNot?: ExamWhereInput
  }

  export type ExerciseScalarRelationFilter = {
    is?: ExerciseWhereInput
    isNot?: ExerciseWhereInput
  }

  export type ExamExerciseExamIdExerciseIdCompoundUniqueInput = {
    examId: string
    exerciseId: string
  }

  export type ExamExerciseCountOrderByAggregateInput = {
    examId?: SortOrder
    exerciseId?: SortOrder
    order?: SortOrder
  }

  export type ExamExerciseAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ExamExerciseMaxOrderByAggregateInput = {
    examId?: SortOrder
    exerciseId?: SortOrder
    order?: SortOrder
  }

  export type ExamExerciseMinOrderByAggregateInput = {
    examId?: SortOrder
    exerciseId?: SortOrder
    order?: SortOrder
  }

  export type ExamExerciseSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumMaterialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialType | EnumMaterialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialTypeFilter<$PrismaModel> | $Enums.MaterialType
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type ModuleNullableScalarRelationFilter = {
    is?: ModuleWhereInput | null
    isNot?: ModuleWhereInput | null
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    publishStatus?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    publishStatus?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    ownerId?: SortOrder
    publishStatus?: SortOrder
  }

  export type EnumMaterialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialType | EnumMaterialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaterialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialTypeFilter<$PrismaModel>
    _max?: NestedEnumMaterialTypeFilter<$PrismaModel>
  }

  export type MaterialNullableScalarRelationFilter = {
    is?: MaterialWhereInput | null
    isNot?: MaterialWhereInput | null
  }

  export type EnrollmentNullableScalarRelationFilter = {
    is?: EnrollmentWhereInput | null
    isNot?: EnrollmentWhereInput | null
  }

  export type ClassNullableScalarRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type EventNullableScalarRelationFilter = {
    is?: EventWhereInput | null
    isNot?: EventWhereInput | null
  }

  export type LessonNullableScalarRelationFilter = {
    is?: LessonWhereInput | null
    isNot?: LessonWhereInput | null
  }

  export type ExamNullableScalarRelationFilter = {
    is?: ExamWhereInput | null
    isNot?: ExamWhereInput | null
  }

  export type ExerciseNullableScalarRelationFilter = {
    is?: ExerciseWhereInput | null
    isNot?: ExerciseWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    topicId?: SortOrder
    materialId?: SortOrder
    enrollmentId?: SortOrder
    classId?: SortOrder
    teamId?: SortOrder
    eventId?: SortOrder
    lessonId?: SortOrder
    examId?: SortOrder
    exerciseId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    topicId?: SortOrder
    materialId?: SortOrder
    enrollmentId?: SortOrder
    classId?: SortOrder
    teamId?: SortOrder
    eventId?: SortOrder
    lessonId?: SortOrder
    examId?: SortOrder
    exerciseId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    topicId?: SortOrder
    materialId?: SortOrder
    enrollmentId?: SortOrder
    classId?: SortOrder
    teamId?: SortOrder
    eventId?: SortOrder
    lessonId?: SortOrder
    examId?: SortOrder
    exerciseId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnrollmentStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatusEnum | EnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatusEnum[] | ListEnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatusEnum[] | ListEnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusEnumFilter<$PrismaModel> | $Enums.EnrollmentStatusEnum
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type HolidayListRelationFilter = {
    every?: HolidayWhereInput
    some?: HolidayWhereInput
    none?: HolidayWhereInput
  }

  export type HolidayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentCourseIdClassIdCompoundUniqueInput = {
    courseId: string
    classId: string
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    classId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    classId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    classId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentSumOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type EnumEnrollmentStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatusEnum | EnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatusEnum[] | ListEnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatusEnum[] | ListEnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.EnrollmentStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnrollmentStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumEnrollmentStatusEnumFilter<$PrismaModel>
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    courseId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    courseId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    courseId?: SortOrder
    teacherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentScalarRelationFilter = {
    is?: EnrollmentWhereInput
    isNot?: EnrollmentWhereInput
  }

  export type HolidayCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    enrollmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    enrollmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    enrollmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type LessonScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    dateTime?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherId?: SortOrder
  }

  export type LessonScheduleAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type LessonScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    dateTime?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherId?: SortOrder
  }

  export type LessonScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    dateTime?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherId?: SortOrder
  }

  export type LessonScheduleSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumEventTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.EventTypeEnum | EnumEventTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EventTypeEnum[] | ListEnumEventTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventTypeEnum[] | ListEnumEventTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeEnumFilter<$PrismaModel> | $Enums.EventTypeEnum
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    courseId?: SortOrder
    moduleId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEventTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventTypeEnum | EnumEventTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EventTypeEnum[] | ListEnumEventTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventTypeEnum[] | ListEnumEventTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.EventTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumEventTypeEnumFilter<$PrismaModel>
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherId?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherId?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTypeEnum | EnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTypeEnum[] | ListEnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationTypeEnum[] | ListEnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeEnumFilter<$PrismaModel> | $Enums.NotificationTypeEnum
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    seen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    seen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    seen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTypeEnum | EnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTypeEnum[] | ListEnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationTypeEnum[] | ListEnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.NotificationTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeEnumFilter<$PrismaModel>
  }

  export type EnumShopItemTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopItemTypeEnum | EnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ShopItemTypeEnum[] | ListEnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopItemTypeEnum[] | ListEnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumShopItemTypeEnumFilter<$PrismaModel> | $Enums.ShopItemTypeEnum
  }

  export type ShopItemForSaleItemTypeItemIdCompoundUniqueInput = {
    itemType: $Enums.ShopItemTypeEnum
    itemId: string
  }

  export type ShopItemForSaleCountOrderByAggregateInput = {
    id?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    sellPrice?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemForSaleAvgOrderByAggregateInput = {
    sellPrice?: SortOrder
  }

  export type ShopItemForSaleMaxOrderByAggregateInput = {
    id?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    sellPrice?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemForSaleMinOrderByAggregateInput = {
    id?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    sellPrice?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemForSaleSumOrderByAggregateInput = {
    sellPrice?: SortOrder
  }

  export type EnumShopItemTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopItemTypeEnum | EnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ShopItemTypeEnum[] | ListEnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopItemTypeEnum[] | ListEnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumShopItemTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.ShopItemTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShopItemTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumShopItemTypeEnumFilter<$PrismaModel>
  }

  export type ShopItemForRentItemTypeItemIdCompoundUniqueInput = {
    itemType: $Enums.ShopItemTypeEnum
    itemId: string
  }

  export type ShopItemForRentCountOrderByAggregateInput = {
    id?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    rentPrice?: SortOrder
    rentPeriod?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVisible?: SortOrder
  }

  export type ShopItemForRentAvgOrderByAggregateInput = {
    rentPrice?: SortOrder
    rentPeriod?: SortOrder
  }

  export type ShopItemForRentMaxOrderByAggregateInput = {
    id?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    rentPrice?: SortOrder
    rentPeriod?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVisible?: SortOrder
  }

  export type ShopItemForRentMinOrderByAggregateInput = {
    id?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    rentPrice?: SortOrder
    rentPeriod?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVisible?: SortOrder
  }

  export type ShopItemForRentSumOrderByAggregateInput = {
    rentPrice?: SortOrder
    rentPeriod?: SortOrder
  }

  export type ShopItemForSaleScalarRelationFilter = {
    is?: ShopItemForSaleWhereInput
    isNot?: ShopItemForSaleWhereInput
  }

  export type PurchasedItemTeacherIdShopItemIdCompoundUniqueInput = {
    teacherId: string
    shopItemId: string
  }

  export type PurchasedItemCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    shopItemId?: SortOrder
    purchaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasedItemMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    shopItemId?: SortOrder
    purchaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasedItemMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    shopItemId?: SortOrder
    purchaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopItemForRentScalarRelationFilter = {
    is?: ShopItemForRentWhereInput
    isNot?: ShopItemForRentWhereInput
  }

  export type RentalPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    shopItemId?: SortOrder
    rentStartDate?: SortOrder
    rentEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type RentalPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    shopItemId?: SortOrder
    rentStartDate?: SortOrder
    rentEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type RentalPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    shopItemId?: SortOrder
    rentStartDate?: SortOrder
    rentEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TeacherCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TeacherUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutTeacherInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type ModuleAssignmentCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ModuleAssignmentCreateWithoutTeacherInput, ModuleAssignmentUncheckedCreateWithoutTeacherInput> | ModuleAssignmentCreateWithoutTeacherInput[] | ModuleAssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutTeacherInput | ModuleAssignmentCreateOrConnectWithoutTeacherInput[]
    createMany?: ModuleAssignmentCreateManyTeacherInputEnvelope
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CourseCreateWithoutOwnerInput, CourseUncheckedCreateWithoutOwnerInput> | CourseCreateWithoutOwnerInput[] | CourseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutOwnerInput | CourseCreateOrConnectWithoutOwnerInput[]
    createMany?: CourseCreateManyOwnerInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ModuleCreateWithoutCreatorInput, ModuleUncheckedCreateWithoutCreatorInput> | ModuleCreateWithoutCreatorInput[] | ModuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCreatorInput | ModuleCreateOrConnectWithoutCreatorInput[]
    createMany?: ModuleCreateManyCreatorInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ModuleCreateWithoutOwnerInput, ModuleUncheckedCreateWithoutOwnerInput> | ModuleCreateWithoutOwnerInput[] | ModuleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutOwnerInput | ModuleCreateOrConnectWithoutOwnerInput[]
    createMany?: ModuleCreateManyOwnerInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type ExerciseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput> | ExerciseCreateWithoutCreatorInput[] | ExerciseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutCreatorInput | ExerciseCreateOrConnectWithoutCreatorInput[]
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExerciseCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput> | ExerciseCreateWithoutOwnerInput[] | ExerciseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutOwnerInput | ExerciseCreateOrConnectWithoutOwnerInput[]
    createMany?: ExerciseCreateManyOwnerInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput> | ExamCreateWithoutCreatorInput[] | ExamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCreatorInput | ExamCreateOrConnectWithoutCreatorInput[]
    createMany?: ExamCreateManyCreatorInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ExamCreateWithoutOwnerInput, ExamUncheckedCreateWithoutOwnerInput> | ExamCreateWithoutOwnerInput[] | ExamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutOwnerInput | ExamCreateOrConnectWithoutOwnerInput[]
    createMany?: ExamCreateManyOwnerInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ClientCreateWithoutCreatorInput, ClientUncheckedCreateWithoutCreatorInput> | ClientCreateWithoutCreatorInput[] | ClientUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatorInput | ClientCreateOrConnectWithoutCreatorInput[]
    createMany?: ClientCreateManyCreatorInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTeacherInput = {
    create?: XOR<NotificationCreateWithoutTeacherInput, NotificationUncheckedCreateWithoutTeacherInput> | NotificationCreateWithoutTeacherInput[] | NotificationUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTeacherInput | NotificationCreateOrConnectWithoutTeacherInput[]
    createMany?: NotificationCreateManyTeacherInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PurchasedItemCreateNestedManyWithoutTeacherInput = {
    create?: XOR<PurchasedItemCreateWithoutTeacherInput, PurchasedItemUncheckedCreateWithoutTeacherInput> | PurchasedItemCreateWithoutTeacherInput[] | PurchasedItemUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: PurchasedItemCreateOrConnectWithoutTeacherInput | PurchasedItemCreateOrConnectWithoutTeacherInput[]
    createMany?: PurchasedItemCreateManyTeacherInputEnvelope
    connect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
  }

  export type RentalPeriodCreateNestedManyWithoutTeacherInput = {
    create?: XOR<RentalPeriodCreateWithoutTeacherInput, RentalPeriodUncheckedCreateWithoutTeacherInput> | RentalPeriodCreateWithoutTeacherInput[] | RentalPeriodUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: RentalPeriodCreateOrConnectWithoutTeacherInput | RentalPeriodCreateOrConnectWithoutTeacherInput[]
    createMany?: RentalPeriodCreateManyTeacherInputEnvelope
    connect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MaterialCreateWithoutCreatorInput, MaterialUncheckedCreateWithoutCreatorInput> | MaterialCreateWithoutCreatorInput[] | MaterialUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCreatorInput | MaterialCreateOrConnectWithoutCreatorInput[]
    createMany?: MaterialCreateManyCreatorInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutOwnerInput = {
    create?: XOR<MaterialCreateWithoutOwnerInput, MaterialUncheckedCreateWithoutOwnerInput> | MaterialCreateWithoutOwnerInput[] | MaterialUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutOwnerInput | MaterialCreateOrConnectWithoutOwnerInput[]
    createMany?: MaterialCreateManyOwnerInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutAddedByInput = {
    create?: XOR<StudentCreateWithoutAddedByInput, StudentUncheckedCreateWithoutAddedByInput> | StudentCreateWithoutAddedByInput[] | StudentUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAddedByInput | StudentCreateOrConnectWithoutAddedByInput[]
    createMany?: StudentCreateManyAddedByInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type LessonScheduleCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonScheduleCreateWithoutTeacherInput, LessonScheduleUncheckedCreateWithoutTeacherInput> | LessonScheduleCreateWithoutTeacherInput[] | LessonScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonScheduleCreateOrConnectWithoutTeacherInput | LessonScheduleCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonScheduleCreateManyTeacherInputEnvelope
    connect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutTeacherInput = {
    create?: XOR<EnrollmentCreateWithoutTeacherInput, EnrollmentUncheckedCreateWithoutTeacherInput> | EnrollmentCreateWithoutTeacherInput[] | EnrollmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutTeacherInput | EnrollmentCreateOrConnectWithoutTeacherInput[]
    createMany?: EnrollmentCreateManyTeacherInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeamCreateWithoutTeacherInput, TeamUncheckedCreateWithoutTeacherInput> | TeamCreateWithoutTeacherInput[] | TeamUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTeacherInput | TeamCreateOrConnectWithoutTeacherInput[]
    createMany?: TeamCreateManyTeacherInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ModuleAssignmentCreateWithoutTeacherInput, ModuleAssignmentUncheckedCreateWithoutTeacherInput> | ModuleAssignmentCreateWithoutTeacherInput[] | ModuleAssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutTeacherInput | ModuleAssignmentCreateOrConnectWithoutTeacherInput[]
    createMany?: ModuleAssignmentCreateManyTeacherInputEnvelope
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CourseCreateWithoutOwnerInput, CourseUncheckedCreateWithoutOwnerInput> | CourseCreateWithoutOwnerInput[] | CourseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutOwnerInput | CourseCreateOrConnectWithoutOwnerInput[]
    createMany?: CourseCreateManyOwnerInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ModuleCreateWithoutCreatorInput, ModuleUncheckedCreateWithoutCreatorInput> | ModuleCreateWithoutCreatorInput[] | ModuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCreatorInput | ModuleCreateOrConnectWithoutCreatorInput[]
    createMany?: ModuleCreateManyCreatorInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ModuleCreateWithoutOwnerInput, ModuleUncheckedCreateWithoutOwnerInput> | ModuleCreateWithoutOwnerInput[] | ModuleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutOwnerInput | ModuleCreateOrConnectWithoutOwnerInput[]
    createMany?: ModuleCreateManyOwnerInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput> | ExerciseCreateWithoutCreatorInput[] | ExerciseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutCreatorInput | ExerciseCreateOrConnectWithoutCreatorInput[]
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput> | ExerciseCreateWithoutOwnerInput[] | ExerciseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutOwnerInput | ExerciseCreateOrConnectWithoutOwnerInput[]
    createMany?: ExerciseCreateManyOwnerInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput> | ExamCreateWithoutCreatorInput[] | ExamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCreatorInput | ExamCreateOrConnectWithoutCreatorInput[]
    createMany?: ExamCreateManyCreatorInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ExamCreateWithoutOwnerInput, ExamUncheckedCreateWithoutOwnerInput> | ExamCreateWithoutOwnerInput[] | ExamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutOwnerInput | ExamCreateOrConnectWithoutOwnerInput[]
    createMany?: ExamCreateManyOwnerInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ClientCreateWithoutCreatorInput, ClientUncheckedCreateWithoutCreatorInput> | ClientCreateWithoutCreatorInput[] | ClientUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatorInput | ClientCreateOrConnectWithoutCreatorInput[]
    createMany?: ClientCreateManyCreatorInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<NotificationCreateWithoutTeacherInput, NotificationUncheckedCreateWithoutTeacherInput> | NotificationCreateWithoutTeacherInput[] | NotificationUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTeacherInput | NotificationCreateOrConnectWithoutTeacherInput[]
    createMany?: NotificationCreateManyTeacherInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<PurchasedItemCreateWithoutTeacherInput, PurchasedItemUncheckedCreateWithoutTeacherInput> | PurchasedItemCreateWithoutTeacherInput[] | PurchasedItemUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: PurchasedItemCreateOrConnectWithoutTeacherInput | PurchasedItemCreateOrConnectWithoutTeacherInput[]
    createMany?: PurchasedItemCreateManyTeacherInputEnvelope
    connect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
  }

  export type RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<RentalPeriodCreateWithoutTeacherInput, RentalPeriodUncheckedCreateWithoutTeacherInput> | RentalPeriodCreateWithoutTeacherInput[] | RentalPeriodUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: RentalPeriodCreateOrConnectWithoutTeacherInput | RentalPeriodCreateOrConnectWithoutTeacherInput[]
    createMany?: RentalPeriodCreateManyTeacherInputEnvelope
    connect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MaterialCreateWithoutCreatorInput, MaterialUncheckedCreateWithoutCreatorInput> | MaterialCreateWithoutCreatorInput[] | MaterialUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCreatorInput | MaterialCreateOrConnectWithoutCreatorInput[]
    createMany?: MaterialCreateManyCreatorInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<MaterialCreateWithoutOwnerInput, MaterialUncheckedCreateWithoutOwnerInput> | MaterialCreateWithoutOwnerInput[] | MaterialUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutOwnerInput | MaterialCreateOrConnectWithoutOwnerInput[]
    createMany?: MaterialCreateManyOwnerInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<StudentCreateWithoutAddedByInput, StudentUncheckedCreateWithoutAddedByInput> | StudentCreateWithoutAddedByInput[] | StudentUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAddedByInput | StudentCreateOrConnectWithoutAddedByInput[]
    createMany?: StudentCreateManyAddedByInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonScheduleCreateWithoutTeacherInput, LessonScheduleUncheckedCreateWithoutTeacherInput> | LessonScheduleCreateWithoutTeacherInput[] | LessonScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonScheduleCreateOrConnectWithoutTeacherInput | LessonScheduleCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonScheduleCreateManyTeacherInputEnvelope
    connect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<EnrollmentCreateWithoutTeacherInput, EnrollmentUncheckedCreateWithoutTeacherInput> | EnrollmentCreateWithoutTeacherInput[] | EnrollmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutTeacherInput | EnrollmentCreateOrConnectWithoutTeacherInput[]
    createMany?: EnrollmentCreateManyTeacherInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeamCreateWithoutTeacherInput, TeamUncheckedCreateWithoutTeacherInput> | TeamCreateWithoutTeacherInput[] | TeamUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTeacherInput | TeamCreateOrConnectWithoutTeacherInput[]
    createMany?: TeamCreateManyTeacherInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    upsert?: UserUpsertWithoutTeacherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherInput, UserUpdateWithoutTeacherInput>, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type ModuleAssignmentUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ModuleAssignmentCreateWithoutTeacherInput, ModuleAssignmentUncheckedCreateWithoutTeacherInput> | ModuleAssignmentCreateWithoutTeacherInput[] | ModuleAssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutTeacherInput | ModuleAssignmentCreateOrConnectWithoutTeacherInput[]
    upsert?: ModuleAssignmentUpsertWithWhereUniqueWithoutTeacherInput | ModuleAssignmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ModuleAssignmentCreateManyTeacherInputEnvelope
    set?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    disconnect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    delete?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    update?: ModuleAssignmentUpdateWithWhereUniqueWithoutTeacherInput | ModuleAssignmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ModuleAssignmentUpdateManyWithWhereWithoutTeacherInput | ModuleAssignmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatorInput | CourseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatorInput | CourseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatorInput | CourseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CourseCreateWithoutOwnerInput, CourseUncheckedCreateWithoutOwnerInput> | CourseCreateWithoutOwnerInput[] | CourseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutOwnerInput | CourseCreateOrConnectWithoutOwnerInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutOwnerInput | CourseUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CourseCreateManyOwnerInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutOwnerInput | CourseUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutOwnerInput | CourseUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ModuleCreateWithoutCreatorInput, ModuleUncheckedCreateWithoutCreatorInput> | ModuleCreateWithoutCreatorInput[] | ModuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCreatorInput | ModuleCreateOrConnectWithoutCreatorInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCreatorInput | ModuleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ModuleCreateManyCreatorInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCreatorInput | ModuleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCreatorInput | ModuleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ModuleCreateWithoutOwnerInput, ModuleUncheckedCreateWithoutOwnerInput> | ModuleCreateWithoutOwnerInput[] | ModuleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutOwnerInput | ModuleCreateOrConnectWithoutOwnerInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutOwnerInput | ModuleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ModuleCreateManyOwnerInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutOwnerInput | ModuleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutOwnerInput | ModuleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ExerciseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput> | ExerciseCreateWithoutCreatorInput[] | ExerciseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutCreatorInput | ExerciseCreateOrConnectWithoutCreatorInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutCreatorInput | ExerciseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutCreatorInput | ExerciseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutCreatorInput | ExerciseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExerciseUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput> | ExerciseCreateWithoutOwnerInput[] | ExerciseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutOwnerInput | ExerciseCreateOrConnectWithoutOwnerInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutOwnerInput | ExerciseUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ExerciseCreateManyOwnerInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutOwnerInput | ExerciseUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutOwnerInput | ExerciseUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput> | ExamCreateWithoutCreatorInput[] | ExamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCreatorInput | ExamCreateOrConnectWithoutCreatorInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutCreatorInput | ExamUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExamCreateManyCreatorInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutCreatorInput | ExamUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutCreatorInput | ExamUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ExamCreateWithoutOwnerInput, ExamUncheckedCreateWithoutOwnerInput> | ExamCreateWithoutOwnerInput[] | ExamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutOwnerInput | ExamCreateOrConnectWithoutOwnerInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutOwnerInput | ExamUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ExamCreateManyOwnerInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutOwnerInput | ExamUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutOwnerInput | ExamUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ClientCreateWithoutCreatorInput, ClientUncheckedCreateWithoutCreatorInput> | ClientCreateWithoutCreatorInput[] | ClientUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatorInput | ClientCreateOrConnectWithoutCreatorInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCreatorInput | ClientUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ClientCreateManyCreatorInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCreatorInput | ClientUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCreatorInput | ClientUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type EventUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatorInput | EventUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatorInput | EventUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatorInput | EventUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<NotificationCreateWithoutTeacherInput, NotificationUncheckedCreateWithoutTeacherInput> | NotificationCreateWithoutTeacherInput[] | NotificationUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTeacherInput | NotificationCreateOrConnectWithoutTeacherInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTeacherInput | NotificationUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: NotificationCreateManyTeacherInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTeacherInput | NotificationUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTeacherInput | NotificationUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PurchasedItemUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<PurchasedItemCreateWithoutTeacherInput, PurchasedItemUncheckedCreateWithoutTeacherInput> | PurchasedItemCreateWithoutTeacherInput[] | PurchasedItemUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: PurchasedItemCreateOrConnectWithoutTeacherInput | PurchasedItemCreateOrConnectWithoutTeacherInput[]
    upsert?: PurchasedItemUpsertWithWhereUniqueWithoutTeacherInput | PurchasedItemUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: PurchasedItemCreateManyTeacherInputEnvelope
    set?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    disconnect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    delete?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    connect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    update?: PurchasedItemUpdateWithWhereUniqueWithoutTeacherInput | PurchasedItemUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: PurchasedItemUpdateManyWithWhereWithoutTeacherInput | PurchasedItemUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: PurchasedItemScalarWhereInput | PurchasedItemScalarWhereInput[]
  }

  export type RentalPeriodUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<RentalPeriodCreateWithoutTeacherInput, RentalPeriodUncheckedCreateWithoutTeacherInput> | RentalPeriodCreateWithoutTeacherInput[] | RentalPeriodUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: RentalPeriodCreateOrConnectWithoutTeacherInput | RentalPeriodCreateOrConnectWithoutTeacherInput[]
    upsert?: RentalPeriodUpsertWithWhereUniqueWithoutTeacherInput | RentalPeriodUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: RentalPeriodCreateManyTeacherInputEnvelope
    set?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    disconnect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    delete?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    connect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    update?: RentalPeriodUpdateWithWhereUniqueWithoutTeacherInput | RentalPeriodUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: RentalPeriodUpdateManyWithWhereWithoutTeacherInput | RentalPeriodUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: RentalPeriodScalarWhereInput | RentalPeriodScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MaterialCreateWithoutCreatorInput, MaterialUncheckedCreateWithoutCreatorInput> | MaterialCreateWithoutCreatorInput[] | MaterialUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCreatorInput | MaterialCreateOrConnectWithoutCreatorInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutCreatorInput | MaterialUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MaterialCreateManyCreatorInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutCreatorInput | MaterialUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutCreatorInput | MaterialUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<MaterialCreateWithoutOwnerInput, MaterialUncheckedCreateWithoutOwnerInput> | MaterialCreateWithoutOwnerInput[] | MaterialUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutOwnerInput | MaterialCreateOrConnectWithoutOwnerInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutOwnerInput | MaterialUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: MaterialCreateManyOwnerInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutOwnerInput | MaterialUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutOwnerInput | MaterialUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<StudentCreateWithoutAddedByInput, StudentUncheckedCreateWithoutAddedByInput> | StudentCreateWithoutAddedByInput[] | StudentUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAddedByInput | StudentCreateOrConnectWithoutAddedByInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAddedByInput | StudentUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: StudentCreateManyAddedByInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAddedByInput | StudentUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAddedByInput | StudentUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTeacherInput | ClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTeacherInput | ClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTeacherInput | ClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type LessonScheduleUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonScheduleCreateWithoutTeacherInput, LessonScheduleUncheckedCreateWithoutTeacherInput> | LessonScheduleCreateWithoutTeacherInput[] | LessonScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonScheduleCreateOrConnectWithoutTeacherInput | LessonScheduleCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonScheduleUpsertWithWhereUniqueWithoutTeacherInput | LessonScheduleUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonScheduleCreateManyTeacherInputEnvelope
    set?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    disconnect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    delete?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    connect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    update?: LessonScheduleUpdateWithWhereUniqueWithoutTeacherInput | LessonScheduleUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonScheduleUpdateManyWithWhereWithoutTeacherInput | LessonScheduleUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonScheduleScalarWhereInput | LessonScheduleScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<EnrollmentCreateWithoutTeacherInput, EnrollmentUncheckedCreateWithoutTeacherInput> | EnrollmentCreateWithoutTeacherInput[] | EnrollmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutTeacherInput | EnrollmentCreateOrConnectWithoutTeacherInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutTeacherInput | EnrollmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: EnrollmentCreateManyTeacherInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutTeacherInput | EnrollmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutTeacherInput | EnrollmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeamCreateWithoutTeacherInput, TeamUncheckedCreateWithoutTeacherInput> | TeamCreateWithoutTeacherInput[] | TeamUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTeacherInput | TeamCreateOrConnectWithoutTeacherInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutTeacherInput | TeamUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeamCreateManyTeacherInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutTeacherInput | TeamUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutTeacherInput | TeamUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ModuleAssignmentCreateWithoutTeacherInput, ModuleAssignmentUncheckedCreateWithoutTeacherInput> | ModuleAssignmentCreateWithoutTeacherInput[] | ModuleAssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutTeacherInput | ModuleAssignmentCreateOrConnectWithoutTeacherInput[]
    upsert?: ModuleAssignmentUpsertWithWhereUniqueWithoutTeacherInput | ModuleAssignmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ModuleAssignmentCreateManyTeacherInputEnvelope
    set?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    disconnect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    delete?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    update?: ModuleAssignmentUpdateWithWhereUniqueWithoutTeacherInput | ModuleAssignmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ModuleAssignmentUpdateManyWithWhereWithoutTeacherInput | ModuleAssignmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatorInput | CourseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatorInput | CourseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatorInput | CourseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CourseCreateWithoutOwnerInput, CourseUncheckedCreateWithoutOwnerInput> | CourseCreateWithoutOwnerInput[] | CourseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutOwnerInput | CourseCreateOrConnectWithoutOwnerInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutOwnerInput | CourseUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CourseCreateManyOwnerInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutOwnerInput | CourseUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutOwnerInput | CourseUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ModuleCreateWithoutCreatorInput, ModuleUncheckedCreateWithoutCreatorInput> | ModuleCreateWithoutCreatorInput[] | ModuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCreatorInput | ModuleCreateOrConnectWithoutCreatorInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCreatorInput | ModuleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ModuleCreateManyCreatorInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCreatorInput | ModuleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCreatorInput | ModuleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ModuleCreateWithoutOwnerInput, ModuleUncheckedCreateWithoutOwnerInput> | ModuleCreateWithoutOwnerInput[] | ModuleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutOwnerInput | ModuleCreateOrConnectWithoutOwnerInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutOwnerInput | ModuleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ModuleCreateManyOwnerInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutOwnerInput | ModuleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutOwnerInput | ModuleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput> | ExerciseCreateWithoutCreatorInput[] | ExerciseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutCreatorInput | ExerciseCreateOrConnectWithoutCreatorInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutCreatorInput | ExerciseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutCreatorInput | ExerciseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutCreatorInput | ExerciseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput> | ExerciseCreateWithoutOwnerInput[] | ExerciseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutOwnerInput | ExerciseCreateOrConnectWithoutOwnerInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutOwnerInput | ExerciseUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ExerciseCreateManyOwnerInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutOwnerInput | ExerciseUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutOwnerInput | ExerciseUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput> | ExamCreateWithoutCreatorInput[] | ExamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCreatorInput | ExamCreateOrConnectWithoutCreatorInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutCreatorInput | ExamUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExamCreateManyCreatorInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutCreatorInput | ExamUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutCreatorInput | ExamUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ExamCreateWithoutOwnerInput, ExamUncheckedCreateWithoutOwnerInput> | ExamCreateWithoutOwnerInput[] | ExamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutOwnerInput | ExamCreateOrConnectWithoutOwnerInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutOwnerInput | ExamUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ExamCreateManyOwnerInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutOwnerInput | ExamUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutOwnerInput | ExamUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ClientCreateWithoutCreatorInput, ClientUncheckedCreateWithoutCreatorInput> | ClientCreateWithoutCreatorInput[] | ClientUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatorInput | ClientCreateOrConnectWithoutCreatorInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCreatorInput | ClientUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ClientCreateManyCreatorInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCreatorInput | ClientUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCreatorInput | ClientUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatorInput | EventUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatorInput | EventUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatorInput | EventUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<NotificationCreateWithoutTeacherInput, NotificationUncheckedCreateWithoutTeacherInput> | NotificationCreateWithoutTeacherInput[] | NotificationUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTeacherInput | NotificationCreateOrConnectWithoutTeacherInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTeacherInput | NotificationUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: NotificationCreateManyTeacherInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTeacherInput | NotificationUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTeacherInput | NotificationUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<PurchasedItemCreateWithoutTeacherInput, PurchasedItemUncheckedCreateWithoutTeacherInput> | PurchasedItemCreateWithoutTeacherInput[] | PurchasedItemUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: PurchasedItemCreateOrConnectWithoutTeacherInput | PurchasedItemCreateOrConnectWithoutTeacherInput[]
    upsert?: PurchasedItemUpsertWithWhereUniqueWithoutTeacherInput | PurchasedItemUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: PurchasedItemCreateManyTeacherInputEnvelope
    set?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    disconnect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    delete?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    connect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    update?: PurchasedItemUpdateWithWhereUniqueWithoutTeacherInput | PurchasedItemUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: PurchasedItemUpdateManyWithWhereWithoutTeacherInput | PurchasedItemUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: PurchasedItemScalarWhereInput | PurchasedItemScalarWhereInput[]
  }

  export type RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<RentalPeriodCreateWithoutTeacherInput, RentalPeriodUncheckedCreateWithoutTeacherInput> | RentalPeriodCreateWithoutTeacherInput[] | RentalPeriodUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: RentalPeriodCreateOrConnectWithoutTeacherInput | RentalPeriodCreateOrConnectWithoutTeacherInput[]
    upsert?: RentalPeriodUpsertWithWhereUniqueWithoutTeacherInput | RentalPeriodUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: RentalPeriodCreateManyTeacherInputEnvelope
    set?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    disconnect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    delete?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    connect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    update?: RentalPeriodUpdateWithWhereUniqueWithoutTeacherInput | RentalPeriodUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: RentalPeriodUpdateManyWithWhereWithoutTeacherInput | RentalPeriodUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: RentalPeriodScalarWhereInput | RentalPeriodScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MaterialCreateWithoutCreatorInput, MaterialUncheckedCreateWithoutCreatorInput> | MaterialCreateWithoutCreatorInput[] | MaterialUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCreatorInput | MaterialCreateOrConnectWithoutCreatorInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutCreatorInput | MaterialUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MaterialCreateManyCreatorInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutCreatorInput | MaterialUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutCreatorInput | MaterialUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<MaterialCreateWithoutOwnerInput, MaterialUncheckedCreateWithoutOwnerInput> | MaterialCreateWithoutOwnerInput[] | MaterialUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutOwnerInput | MaterialCreateOrConnectWithoutOwnerInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutOwnerInput | MaterialUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: MaterialCreateManyOwnerInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutOwnerInput | MaterialUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutOwnerInput | MaterialUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<StudentCreateWithoutAddedByInput, StudentUncheckedCreateWithoutAddedByInput> | StudentCreateWithoutAddedByInput[] | StudentUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAddedByInput | StudentCreateOrConnectWithoutAddedByInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAddedByInput | StudentUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: StudentCreateManyAddedByInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAddedByInput | StudentUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAddedByInput | StudentUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput> | ClassCreateWithoutTeacherInput[] | ClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherInput | ClassCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTeacherInput | ClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ClassCreateManyTeacherInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTeacherInput | ClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTeacherInput | ClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonScheduleCreateWithoutTeacherInput, LessonScheduleUncheckedCreateWithoutTeacherInput> | LessonScheduleCreateWithoutTeacherInput[] | LessonScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonScheduleCreateOrConnectWithoutTeacherInput | LessonScheduleCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonScheduleUpsertWithWhereUniqueWithoutTeacherInput | LessonScheduleUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonScheduleCreateManyTeacherInputEnvelope
    set?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    disconnect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    delete?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    connect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    update?: LessonScheduleUpdateWithWhereUniqueWithoutTeacherInput | LessonScheduleUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonScheduleUpdateManyWithWhereWithoutTeacherInput | LessonScheduleUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonScheduleScalarWhereInput | LessonScheduleScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<EnrollmentCreateWithoutTeacherInput, EnrollmentUncheckedCreateWithoutTeacherInput> | EnrollmentCreateWithoutTeacherInput[] | EnrollmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutTeacherInput | EnrollmentCreateOrConnectWithoutTeacherInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutTeacherInput | EnrollmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: EnrollmentCreateManyTeacherInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutTeacherInput | EnrollmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutTeacherInput | EnrollmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeamCreateWithoutTeacherInput, TeamUncheckedCreateWithoutTeacherInput> | TeamCreateWithoutTeacherInput[] | TeamUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTeacherInput | TeamCreateOrConnectWithoutTeacherInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutTeacherInput | TeamUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeamCreateManyTeacherInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutTeacherInput | TeamUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutTeacherInput | TeamUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedManyWithoutStudentsInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput> | ClassCreateWithoutStudentsInput[] | ClassUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput | ClassCreateOrConnectWithoutStudentsInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutStudentsInput = {
    create?: XOR<TeamCreateWithoutStudentsInput, TeamUncheckedCreateWithoutStudentsInput> | TeamCreateWithoutStudentsInput[] | TeamUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutStudentsInput | TeamCreateOrConnectWithoutStudentsInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutStudentInput = {
    create?: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput> | NotificationCreateWithoutStudentInput[] | NotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStudentInput | NotificationCreateOrConnectWithoutStudentInput[]
    createMany?: NotificationCreateManyStudentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutStudentInput = {
    create?: XOR<CommentCreateWithoutStudentInput, CommentUncheckedCreateWithoutStudentInput> | CommentCreateWithoutStudentInput[] | CommentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStudentInput | CommentCreateOrConnectWithoutStudentInput[]
    createMany?: CommentCreateManyStudentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TeacherCreateNestedOneWithoutAddedStudentsInput = {
    create?: XOR<TeacherCreateWithoutAddedStudentsInput, TeacherUncheckedCreateWithoutAddedStudentsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAddedStudentsInput
    connect?: TeacherWhereUniqueInput
  }

  export type ClassUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput> | ClassCreateWithoutStudentsInput[] | ClassUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput | ClassCreateOrConnectWithoutStudentsInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<TeamCreateWithoutStudentsInput, TeamUncheckedCreateWithoutStudentsInput> | TeamCreateWithoutStudentsInput[] | TeamUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutStudentsInput | TeamCreateOrConnectWithoutStudentsInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput> | NotificationCreateWithoutStudentInput[] | NotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStudentInput | NotificationCreateOrConnectWithoutStudentInput[]
    createMany?: NotificationCreateManyStudentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CommentCreateWithoutStudentInput, CommentUncheckedCreateWithoutStudentInput> | CommentCreateWithoutStudentInput[] | CommentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStudentInput | CommentCreateOrConnectWithoutStudentInput[]
    createMany?: CommentCreateManyStudentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type ClassUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput> | ClassCreateWithoutStudentsInput[] | ClassUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput | ClassCreateOrConnectWithoutStudentsInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutStudentsInput | ClassUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutStudentsInput | ClassUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutStudentsInput | ClassUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<TeamCreateWithoutStudentsInput, TeamUncheckedCreateWithoutStudentsInput> | TeamCreateWithoutStudentsInput[] | TeamUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutStudentsInput | TeamCreateOrConnectWithoutStudentsInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutStudentsInput | TeamUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutStudentsInput | TeamUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutStudentsInput | TeamUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput> | NotificationCreateWithoutStudentInput[] | NotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStudentInput | NotificationCreateOrConnectWithoutStudentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutStudentInput | NotificationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NotificationCreateManyStudentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutStudentInput | NotificationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutStudentInput | NotificationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CommentCreateWithoutStudentInput, CommentUncheckedCreateWithoutStudentInput> | CommentCreateWithoutStudentInput[] | CommentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStudentInput | CommentCreateOrConnectWithoutStudentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutStudentInput | CommentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CommentCreateManyStudentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutStudentInput | CommentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutStudentInput | CommentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TeacherUpdateOneRequiredWithoutAddedStudentsNestedInput = {
    create?: XOR<TeacherCreateWithoutAddedStudentsInput, TeacherUncheckedCreateWithoutAddedStudentsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAddedStudentsInput
    upsert?: TeacherUpsertWithoutAddedStudentsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutAddedStudentsInput, TeacherUpdateWithoutAddedStudentsInput>, TeacherUncheckedUpdateWithoutAddedStudentsInput>
  }

  export type ClassUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput> | ClassCreateWithoutStudentsInput[] | ClassUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput | ClassCreateOrConnectWithoutStudentsInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutStudentsInput | ClassUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutStudentsInput | ClassUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutStudentsInput | ClassUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<TeamCreateWithoutStudentsInput, TeamUncheckedCreateWithoutStudentsInput> | TeamCreateWithoutStudentsInput[] | TeamUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutStudentsInput | TeamCreateOrConnectWithoutStudentsInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutStudentsInput | TeamUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutStudentsInput | TeamUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutStudentsInput | TeamUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput> | NotificationCreateWithoutStudentInput[] | NotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStudentInput | NotificationCreateOrConnectWithoutStudentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutStudentInput | NotificationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NotificationCreateManyStudentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutStudentInput | NotificationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutStudentInput | NotificationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CommentCreateWithoutStudentInput, CommentUncheckedCreateWithoutStudentInput> | CommentCreateWithoutStudentInput[] | CommentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStudentInput | CommentCreateOrConnectWithoutStudentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutStudentInput | CommentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CommentCreateManyStudentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutStudentInput | CommentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutStudentInput | CommentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TeacherCreateNestedOneWithoutCreatedCoursesInput = {
    create?: XOR<TeacherCreateWithoutCreatedCoursesInput, TeacherUncheckedCreateWithoutCreatedCoursesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedCoursesInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutOwnedCoursesInput = {
    create?: XOR<TeacherCreateWithoutOwnedCoursesInput, TeacherUncheckedCreateWithoutOwnedCoursesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutOwnedCoursesInput
    connect?: TeacherWhereUniqueInput
  }

  export type ModuleCreateNestedManyWithoutCourseInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutCourseInput = {
    create?: XOR<MaterialCreateWithoutCourseInput, MaterialUncheckedCreateWithoutCourseInput> | MaterialCreateWithoutCourseInput[] | MaterialUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCourseInput | MaterialCreateOrConnectWithoutCourseInput[]
    createMany?: MaterialCreateManyCourseInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutCourseInput = {
    create?: XOR<EventCreateWithoutCourseInput, EventUncheckedCreateWithoutCourseInput> | EventCreateWithoutCourseInput[] | EventUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCourseInput | EventCreateOrConnectWithoutCourseInput[]
    createMany?: EventCreateManyCourseInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutCourseInput = {
    create?: XOR<ClassCreateWithoutCourseInput, ClassUncheckedCreateWithoutCourseInput> | ClassCreateWithoutCourseInput[] | ClassUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutCourseInput | ClassCreateOrConnectWithoutCourseInput[]
    createMany?: ClassCreateManyCourseInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutCourseInput = {
    create?: XOR<CommentCreateWithoutCourseInput, CommentUncheckedCreateWithoutCourseInput> | CommentCreateWithoutCourseInput[] | CommentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCourseInput | CommentCreateOrConnectWithoutCourseInput[]
    createMany?: CommentCreateManyCourseInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ShopItemForSaleCreateNestedOneWithoutCourseInput = {
    create?: XOR<ShopItemForSaleCreateWithoutCourseInput, ShopItemForSaleUncheckedCreateWithoutCourseInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutCourseInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type ShopItemForRentCreateNestedOneWithoutCourseInput = {
    create?: XOR<ShopItemForRentCreateWithoutCourseInput, ShopItemForRentUncheckedCreateWithoutCourseInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutCourseInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type ModuleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<MaterialCreateWithoutCourseInput, MaterialUncheckedCreateWithoutCourseInput> | MaterialCreateWithoutCourseInput[] | MaterialUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCourseInput | MaterialCreateOrConnectWithoutCourseInput[]
    createMany?: MaterialCreateManyCourseInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<EventCreateWithoutCourseInput, EventUncheckedCreateWithoutCourseInput> | EventCreateWithoutCourseInput[] | EventUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCourseInput | EventCreateOrConnectWithoutCourseInput[]
    createMany?: EventCreateManyCourseInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ClassCreateWithoutCourseInput, ClassUncheckedCreateWithoutCourseInput> | ClassCreateWithoutCourseInput[] | ClassUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutCourseInput | ClassCreateOrConnectWithoutCourseInput[]
    createMany?: ClassCreateManyCourseInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CommentCreateWithoutCourseInput, CommentUncheckedCreateWithoutCourseInput> | CommentCreateWithoutCourseInput[] | CommentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCourseInput | CommentCreateOrConnectWithoutCourseInput[]
    createMany?: CommentCreateManyCourseInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput = {
    create?: XOR<ShopItemForSaleCreateWithoutCourseInput, ShopItemForSaleUncheckedCreateWithoutCourseInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutCourseInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput = {
    create?: XOR<ShopItemForRentCreateWithoutCourseInput, ShopItemForRentUncheckedCreateWithoutCourseInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutCourseInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type EnumCourseStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.CourseStatusEnum
  }

  export type EnumPublishStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.PublishStatusEnum
  }

  export type TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput = {
    create?: XOR<TeacherCreateWithoutCreatedCoursesInput, TeacherUncheckedCreateWithoutCreatedCoursesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedCoursesInput
    upsert?: TeacherUpsertWithoutCreatedCoursesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutCreatedCoursesInput, TeacherUpdateWithoutCreatedCoursesInput>, TeacherUncheckedUpdateWithoutCreatedCoursesInput>
  }

  export type TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput = {
    create?: XOR<TeacherCreateWithoutOwnedCoursesInput, TeacherUncheckedCreateWithoutOwnedCoursesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutOwnedCoursesInput
    upsert?: TeacherUpsertWithoutOwnedCoursesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutOwnedCoursesInput, TeacherUpdateWithoutOwnedCoursesInput>, TeacherUncheckedUpdateWithoutOwnedCoursesInput>
  }

  export type ModuleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCourseInput | ModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCourseInput | ModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCourseInput | ModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutCourseNestedInput = {
    create?: XOR<MaterialCreateWithoutCourseInput, MaterialUncheckedCreateWithoutCourseInput> | MaterialCreateWithoutCourseInput[] | MaterialUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCourseInput | MaterialCreateOrConnectWithoutCourseInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutCourseInput | MaterialUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: MaterialCreateManyCourseInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutCourseInput | MaterialUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutCourseInput | MaterialUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type EventUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EventCreateWithoutCourseInput, EventUncheckedCreateWithoutCourseInput> | EventCreateWithoutCourseInput[] | EventUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCourseInput | EventCreateOrConnectWithoutCourseInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCourseInput | EventUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EventCreateManyCourseInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCourseInput | EventUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCourseInput | EventUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ClassCreateWithoutCourseInput, ClassUncheckedCreateWithoutCourseInput> | ClassCreateWithoutCourseInput[] | ClassUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutCourseInput | ClassCreateOrConnectWithoutCourseInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutCourseInput | ClassUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ClassCreateManyCourseInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutCourseInput | ClassUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutCourseInput | ClassUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CommentCreateWithoutCourseInput, CommentUncheckedCreateWithoutCourseInput> | CommentCreateWithoutCourseInput[] | CommentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCourseInput | CommentCreateOrConnectWithoutCourseInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCourseInput | CommentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CommentCreateManyCourseInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCourseInput | CommentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCourseInput | CommentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ShopItemForSaleUpdateOneWithoutCourseNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutCourseInput, ShopItemForSaleUncheckedCreateWithoutCourseInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutCourseInput
    upsert?: ShopItemForSaleUpsertWithoutCourseInput
    disconnect?: ShopItemForSaleWhereInput | boolean
    delete?: ShopItemForSaleWhereInput | boolean
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutCourseInput, ShopItemForSaleUpdateWithoutCourseInput>, ShopItemForSaleUncheckedUpdateWithoutCourseInput>
  }

  export type ShopItemForRentUpdateOneWithoutCourseNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutCourseInput, ShopItemForRentUncheckedCreateWithoutCourseInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutCourseInput
    upsert?: ShopItemForRentUpsertWithoutCourseInput
    disconnect?: ShopItemForRentWhereInput | boolean
    delete?: ShopItemForRentWhereInput | boolean
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutCourseInput, ShopItemForRentUpdateWithoutCourseInput>, ShopItemForRentUncheckedUpdateWithoutCourseInput>
  }

  export type ModuleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCourseInput | ModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCourseInput | ModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCourseInput | ModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<MaterialCreateWithoutCourseInput, MaterialUncheckedCreateWithoutCourseInput> | MaterialCreateWithoutCourseInput[] | MaterialUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCourseInput | MaterialCreateOrConnectWithoutCourseInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutCourseInput | MaterialUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: MaterialCreateManyCourseInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutCourseInput | MaterialUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutCourseInput | MaterialUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EventCreateWithoutCourseInput, EventUncheckedCreateWithoutCourseInput> | EventCreateWithoutCourseInput[] | EventUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCourseInput | EventCreateOrConnectWithoutCourseInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCourseInput | EventUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EventCreateManyCourseInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCourseInput | EventUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCourseInput | EventUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ClassCreateWithoutCourseInput, ClassUncheckedCreateWithoutCourseInput> | ClassCreateWithoutCourseInput[] | ClassUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutCourseInput | ClassCreateOrConnectWithoutCourseInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutCourseInput | ClassUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ClassCreateManyCourseInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutCourseInput | ClassUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutCourseInput | ClassUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CommentCreateWithoutCourseInput, CommentUncheckedCreateWithoutCourseInput> | CommentCreateWithoutCourseInput[] | CommentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCourseInput | CommentCreateOrConnectWithoutCourseInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCourseInput | CommentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CommentCreateManyCourseInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCourseInput | CommentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCourseInput | CommentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutCourseInput, ShopItemForSaleUncheckedCreateWithoutCourseInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutCourseInput
    upsert?: ShopItemForSaleUpsertWithoutCourseInput
    disconnect?: ShopItemForSaleWhereInput | boolean
    delete?: ShopItemForSaleWhereInput | boolean
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutCourseInput, ShopItemForSaleUpdateWithoutCourseInput>, ShopItemForSaleUncheckedUpdateWithoutCourseInput>
  }

  export type ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutCourseInput, ShopItemForRentUncheckedCreateWithoutCourseInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutCourseInput
    upsert?: ShopItemForRentUpsertWithoutCourseInput
    disconnect?: ShopItemForRentWhereInput | boolean
    delete?: ShopItemForRentWhereInput | boolean
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutCourseInput, ShopItemForRentUpdateWithoutCourseInput>, ShopItemForRentUncheckedUpdateWithoutCourseInput>
  }

  export type TeacherCreateNestedOneWithoutCreatedModulesInput = {
    create?: XOR<TeacherCreateWithoutCreatedModulesInput, TeacherUncheckedCreateWithoutCreatedModulesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedModulesInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutOwnedModulesInput = {
    create?: XOR<TeacherCreateWithoutOwnedModulesInput, TeacherUncheckedCreateWithoutOwnedModulesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutOwnedModulesInput
    connect?: TeacherWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutModulesInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    connect?: CourseWhereUniqueInput
  }

  export type TopicCreateNestedManyWithoutModuleInput = {
    create?: XOR<TopicCreateWithoutModuleInput, TopicUncheckedCreateWithoutModuleInput> | TopicCreateWithoutModuleInput[] | TopicUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutModuleInput | TopicCreateOrConnectWithoutModuleInput[]
    createMany?: TopicCreateManyModuleInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutModuleInput = {
    create?: XOR<MaterialCreateWithoutModuleInput, MaterialUncheckedCreateWithoutModuleInput> | MaterialCreateWithoutModuleInput[] | MaterialUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutModuleInput | MaterialCreateOrConnectWithoutModuleInput[]
    createMany?: MaterialCreateManyModuleInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ModuleAssignmentCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput> | ModuleAssignmentCreateWithoutModuleInput[] | ModuleAssignmentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutModuleInput | ModuleAssignmentCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleAssignmentCreateManyModuleInputEnvelope
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutModuleInput = {
    create?: XOR<ExamCreateWithoutModuleInput, ExamUncheckedCreateWithoutModuleInput> | ExamCreateWithoutModuleInput[] | ExamUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutModuleInput | ExamCreateOrConnectWithoutModuleInput[]
    createMany?: ExamCreateManyModuleInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutModuleInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutModuleInput = {
    create?: XOR<EventCreateWithoutModuleInput, EventUncheckedCreateWithoutModuleInput> | EventCreateWithoutModuleInput[] | EventUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutModuleInput | EventCreateOrConnectWithoutModuleInput[]
    createMany?: EventCreateManyModuleInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutModuleInput = {
    create?: XOR<CommentCreateWithoutModuleInput, CommentUncheckedCreateWithoutModuleInput> | CommentCreateWithoutModuleInput[] | CommentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutModuleInput | CommentCreateOrConnectWithoutModuleInput[]
    createMany?: CommentCreateManyModuleInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ShopItemForSaleCreateNestedOneWithoutModuleInput = {
    create?: XOR<ShopItemForSaleCreateWithoutModuleInput, ShopItemForSaleUncheckedCreateWithoutModuleInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutModuleInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type ShopItemForRentCreateNestedOneWithoutModuleInput = {
    create?: XOR<ShopItemForRentCreateWithoutModuleInput, ShopItemForRentUncheckedCreateWithoutModuleInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutModuleInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type TopicUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<TopicCreateWithoutModuleInput, TopicUncheckedCreateWithoutModuleInput> | TopicCreateWithoutModuleInput[] | TopicUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutModuleInput | TopicCreateOrConnectWithoutModuleInput[]
    createMany?: TopicCreateManyModuleInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<MaterialCreateWithoutModuleInput, MaterialUncheckedCreateWithoutModuleInput> | MaterialCreateWithoutModuleInput[] | MaterialUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutModuleInput | MaterialCreateOrConnectWithoutModuleInput[]
    createMany?: MaterialCreateManyModuleInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput> | ModuleAssignmentCreateWithoutModuleInput[] | ModuleAssignmentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutModuleInput | ModuleAssignmentCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleAssignmentCreateManyModuleInputEnvelope
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ExamCreateWithoutModuleInput, ExamUncheckedCreateWithoutModuleInput> | ExamCreateWithoutModuleInput[] | ExamUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutModuleInput | ExamCreateOrConnectWithoutModuleInput[]
    createMany?: ExamCreateManyModuleInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<EventCreateWithoutModuleInput, EventUncheckedCreateWithoutModuleInput> | EventCreateWithoutModuleInput[] | EventUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutModuleInput | EventCreateOrConnectWithoutModuleInput[]
    createMany?: EventCreateManyModuleInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<CommentCreateWithoutModuleInput, CommentUncheckedCreateWithoutModuleInput> | CommentCreateWithoutModuleInput[] | CommentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutModuleInput | CommentCreateOrConnectWithoutModuleInput[]
    createMany?: CommentCreateManyModuleInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput = {
    create?: XOR<ShopItemForSaleCreateWithoutModuleInput, ShopItemForSaleUncheckedCreateWithoutModuleInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutModuleInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput = {
    create?: XOR<ShopItemForRentCreateWithoutModuleInput, ShopItemForRentUncheckedCreateWithoutModuleInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutModuleInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput = {
    create?: XOR<TeacherCreateWithoutCreatedModulesInput, TeacherUncheckedCreateWithoutCreatedModulesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedModulesInput
    upsert?: TeacherUpsertWithoutCreatedModulesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutCreatedModulesInput, TeacherUpdateWithoutCreatedModulesInput>, TeacherUncheckedUpdateWithoutCreatedModulesInput>
  }

  export type TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput = {
    create?: XOR<TeacherCreateWithoutOwnedModulesInput, TeacherUncheckedCreateWithoutOwnedModulesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutOwnedModulesInput
    upsert?: TeacherUpsertWithoutOwnedModulesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutOwnedModulesInput, TeacherUpdateWithoutOwnedModulesInput>, TeacherUncheckedUpdateWithoutOwnedModulesInput>
  }

  export type CourseUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    upsert?: CourseUpsertWithoutModulesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutModulesInput, CourseUpdateWithoutModulesInput>, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type TopicUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TopicCreateWithoutModuleInput, TopicUncheckedCreateWithoutModuleInput> | TopicCreateWithoutModuleInput[] | TopicUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutModuleInput | TopicCreateOrConnectWithoutModuleInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutModuleInput | TopicUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TopicCreateManyModuleInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutModuleInput | TopicUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutModuleInput | TopicUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutModuleNestedInput = {
    create?: XOR<MaterialCreateWithoutModuleInput, MaterialUncheckedCreateWithoutModuleInput> | MaterialCreateWithoutModuleInput[] | MaterialUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutModuleInput | MaterialCreateOrConnectWithoutModuleInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutModuleInput | MaterialUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: MaterialCreateManyModuleInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutModuleInput | MaterialUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutModuleInput | MaterialUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ModuleAssignmentUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput> | ModuleAssignmentCreateWithoutModuleInput[] | ModuleAssignmentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutModuleInput | ModuleAssignmentCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleAssignmentUpsertWithWhereUniqueWithoutModuleInput | ModuleAssignmentUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleAssignmentCreateManyModuleInputEnvelope
    set?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    disconnect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    delete?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    update?: ModuleAssignmentUpdateWithWhereUniqueWithoutModuleInput | ModuleAssignmentUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleAssignmentUpdateManyWithWhereWithoutModuleInput | ModuleAssignmentUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ExamCreateWithoutModuleInput, ExamUncheckedCreateWithoutModuleInput> | ExamCreateWithoutModuleInput[] | ExamUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutModuleInput | ExamCreateOrConnectWithoutModuleInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutModuleInput | ExamUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ExamCreateManyModuleInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutModuleInput | ExamUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutModuleInput | ExamUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutModuleNestedInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutModuleInput | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutModuleInput | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutModuleInput | LessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type EventUpdateManyWithoutModuleNestedInput = {
    create?: XOR<EventCreateWithoutModuleInput, EventUncheckedCreateWithoutModuleInput> | EventCreateWithoutModuleInput[] | EventUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutModuleInput | EventCreateOrConnectWithoutModuleInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutModuleInput | EventUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: EventCreateManyModuleInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutModuleInput | EventUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: EventUpdateManyWithWhereWithoutModuleInput | EventUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutModuleNestedInput = {
    create?: XOR<CommentCreateWithoutModuleInput, CommentUncheckedCreateWithoutModuleInput> | CommentCreateWithoutModuleInput[] | CommentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutModuleInput | CommentCreateOrConnectWithoutModuleInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutModuleInput | CommentUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: CommentCreateManyModuleInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutModuleInput | CommentUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutModuleInput | CommentUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ShopItemForSaleUpdateOneWithoutModuleNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutModuleInput, ShopItemForSaleUncheckedCreateWithoutModuleInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutModuleInput
    upsert?: ShopItemForSaleUpsertWithoutModuleInput
    disconnect?: ShopItemForSaleWhereInput | boolean
    delete?: ShopItemForSaleWhereInput | boolean
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutModuleInput, ShopItemForSaleUpdateWithoutModuleInput>, ShopItemForSaleUncheckedUpdateWithoutModuleInput>
  }

  export type ShopItemForRentUpdateOneWithoutModuleNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutModuleInput, ShopItemForRentUncheckedCreateWithoutModuleInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutModuleInput
    upsert?: ShopItemForRentUpsertWithoutModuleInput
    disconnect?: ShopItemForRentWhereInput | boolean
    delete?: ShopItemForRentWhereInput | boolean
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutModuleInput, ShopItemForRentUpdateWithoutModuleInput>, ShopItemForRentUncheckedUpdateWithoutModuleInput>
  }

  export type TopicUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TopicCreateWithoutModuleInput, TopicUncheckedCreateWithoutModuleInput> | TopicCreateWithoutModuleInput[] | TopicUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutModuleInput | TopicCreateOrConnectWithoutModuleInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutModuleInput | TopicUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TopicCreateManyModuleInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutModuleInput | TopicUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutModuleInput | TopicUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<MaterialCreateWithoutModuleInput, MaterialUncheckedCreateWithoutModuleInput> | MaterialCreateWithoutModuleInput[] | MaterialUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutModuleInput | MaterialCreateOrConnectWithoutModuleInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutModuleInput | MaterialUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: MaterialCreateManyModuleInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutModuleInput | MaterialUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutModuleInput | MaterialUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput> | ModuleAssignmentCreateWithoutModuleInput[] | ModuleAssignmentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutModuleInput | ModuleAssignmentCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleAssignmentUpsertWithWhereUniqueWithoutModuleInput | ModuleAssignmentUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleAssignmentCreateManyModuleInputEnvelope
    set?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    disconnect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    delete?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    update?: ModuleAssignmentUpdateWithWhereUniqueWithoutModuleInput | ModuleAssignmentUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleAssignmentUpdateManyWithWhereWithoutModuleInput | ModuleAssignmentUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ExamCreateWithoutModuleInput, ExamUncheckedCreateWithoutModuleInput> | ExamCreateWithoutModuleInput[] | ExamUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutModuleInput | ExamCreateOrConnectWithoutModuleInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutModuleInput | ExamUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ExamCreateManyModuleInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutModuleInput | ExamUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutModuleInput | ExamUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutModuleInput | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutModuleInput | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutModuleInput | LessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<EventCreateWithoutModuleInput, EventUncheckedCreateWithoutModuleInput> | EventCreateWithoutModuleInput[] | EventUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutModuleInput | EventCreateOrConnectWithoutModuleInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutModuleInput | EventUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: EventCreateManyModuleInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutModuleInput | EventUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: EventUpdateManyWithWhereWithoutModuleInput | EventUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<CommentCreateWithoutModuleInput, CommentUncheckedCreateWithoutModuleInput> | CommentCreateWithoutModuleInput[] | CommentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutModuleInput | CommentCreateOrConnectWithoutModuleInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutModuleInput | CommentUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: CommentCreateManyModuleInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutModuleInput | CommentUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutModuleInput | CommentUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutModuleInput, ShopItemForSaleUncheckedCreateWithoutModuleInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutModuleInput
    upsert?: ShopItemForSaleUpsertWithoutModuleInput
    disconnect?: ShopItemForSaleWhereInput | boolean
    delete?: ShopItemForSaleWhereInput | boolean
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutModuleInput, ShopItemForSaleUpdateWithoutModuleInput>, ShopItemForSaleUncheckedUpdateWithoutModuleInput>
  }

  export type ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutModuleInput, ShopItemForRentUncheckedCreateWithoutModuleInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutModuleInput
    upsert?: ShopItemForRentUpsertWithoutModuleInput
    disconnect?: ShopItemForRentWhereInput | boolean
    delete?: ShopItemForRentWhereInput | boolean
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutModuleInput, ShopItemForRentUpdateWithoutModuleInput>, ShopItemForRentUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutLessonsInput
    connect?: ModuleWhereUniqueInput
  }

  export type LessonScheduleCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonScheduleCreateWithoutLessonInput, LessonScheduleUncheckedCreateWithoutLessonInput> | LessonScheduleCreateWithoutLessonInput[] | LessonScheduleUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonScheduleCreateOrConnectWithoutLessonInput | LessonScheduleCreateOrConnectWithoutLessonInput[]
    createMany?: LessonScheduleCreateManyLessonInputEnvelope
    connect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutLessonInput = {
    create?: XOR<CommentCreateWithoutLessonInput, CommentUncheckedCreateWithoutLessonInput> | CommentCreateWithoutLessonInput[] | CommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutLessonInput | CommentCreateOrConnectWithoutLessonInput[]
    createMany?: CommentCreateManyLessonInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LessonScheduleUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonScheduleCreateWithoutLessonInput, LessonScheduleUncheckedCreateWithoutLessonInput> | LessonScheduleCreateWithoutLessonInput[] | LessonScheduleUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonScheduleCreateOrConnectWithoutLessonInput | LessonScheduleCreateOrConnectWithoutLessonInput[]
    createMany?: LessonScheduleCreateManyLessonInputEnvelope
    connect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<CommentCreateWithoutLessonInput, CommentUncheckedCreateWithoutLessonInput> | CommentCreateWithoutLessonInput[] | CommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutLessonInput | CommentCreateOrConnectWithoutLessonInput[]
    createMany?: CommentCreateManyLessonInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ModuleUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutLessonsInput
    upsert?: ModuleUpsertWithoutLessonsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutLessonsInput, ModuleUpdateWithoutLessonsInput>, ModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type LessonScheduleUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonScheduleCreateWithoutLessonInput, LessonScheduleUncheckedCreateWithoutLessonInput> | LessonScheduleCreateWithoutLessonInput[] | LessonScheduleUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonScheduleCreateOrConnectWithoutLessonInput | LessonScheduleCreateOrConnectWithoutLessonInput[]
    upsert?: LessonScheduleUpsertWithWhereUniqueWithoutLessonInput | LessonScheduleUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonScheduleCreateManyLessonInputEnvelope
    set?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    disconnect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    delete?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    connect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    update?: LessonScheduleUpdateWithWhereUniqueWithoutLessonInput | LessonScheduleUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonScheduleUpdateManyWithWhereWithoutLessonInput | LessonScheduleUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonScheduleScalarWhereInput | LessonScheduleScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutLessonNestedInput = {
    create?: XOR<CommentCreateWithoutLessonInput, CommentUncheckedCreateWithoutLessonInput> | CommentCreateWithoutLessonInput[] | CommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutLessonInput | CommentCreateOrConnectWithoutLessonInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutLessonInput | CommentUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: CommentCreateManyLessonInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutLessonInput | CommentUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutLessonInput | CommentUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LessonScheduleUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonScheduleCreateWithoutLessonInput, LessonScheduleUncheckedCreateWithoutLessonInput> | LessonScheduleCreateWithoutLessonInput[] | LessonScheduleUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonScheduleCreateOrConnectWithoutLessonInput | LessonScheduleCreateOrConnectWithoutLessonInput[]
    upsert?: LessonScheduleUpsertWithWhereUniqueWithoutLessonInput | LessonScheduleUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonScheduleCreateManyLessonInputEnvelope
    set?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    disconnect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    delete?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    connect?: LessonScheduleWhereUniqueInput | LessonScheduleWhereUniqueInput[]
    update?: LessonScheduleUpdateWithWhereUniqueWithoutLessonInput | LessonScheduleUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonScheduleUpdateManyWithWhereWithoutLessonInput | LessonScheduleUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonScheduleScalarWhereInput | LessonScheduleScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<CommentCreateWithoutLessonInput, CommentUncheckedCreateWithoutLessonInput> | CommentCreateWithoutLessonInput[] | CommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutLessonInput | CommentCreateOrConnectWithoutLessonInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutLessonInput | CommentUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: CommentCreateManyLessonInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutLessonInput | CommentUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutLessonInput | CommentUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ModuleCreateNestedOneWithoutTopicsInput = {
    create?: XOR<ModuleCreateWithoutTopicsInput, ModuleUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTopicsInput
    connect?: ModuleWhereUniqueInput
  }

  export type MaterialCreateNestedManyWithoutTopicInput = {
    create?: XOR<MaterialCreateWithoutTopicInput, MaterialUncheckedCreateWithoutTopicInput> | MaterialCreateWithoutTopicInput[] | MaterialUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutTopicInput | MaterialCreateOrConnectWithoutTopicInput[]
    createMany?: MaterialCreateManyTopicInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ExerciseCreateNestedManyWithoutTopicInput = {
    create?: XOR<ExerciseCreateWithoutTopicInput, ExerciseUncheckedCreateWithoutTopicInput> | ExerciseCreateWithoutTopicInput[] | ExerciseUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutTopicInput | ExerciseCreateOrConnectWithoutTopicInput[]
    createMany?: ExerciseCreateManyTopicInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ObjectiveCreateNestedManyWithoutTopicInput = {
    create?: XOR<ObjectiveCreateWithoutTopicInput, ObjectiveUncheckedCreateWithoutTopicInput> | ObjectiveCreateWithoutTopicInput[] | ObjectiveUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ObjectiveCreateOrConnectWithoutTopicInput | ObjectiveCreateOrConnectWithoutTopicInput[]
    createMany?: ObjectiveCreateManyTopicInputEnvelope
    connect?: ObjectiveWhereUniqueInput | ObjectiveWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTopicInput = {
    create?: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput> | CommentCreateWithoutTopicInput[] | CommentUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTopicInput | CommentCreateOrConnectWithoutTopicInput[]
    createMany?: CommentCreateManyTopicInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<MaterialCreateWithoutTopicInput, MaterialUncheckedCreateWithoutTopicInput> | MaterialCreateWithoutTopicInput[] | MaterialUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutTopicInput | MaterialCreateOrConnectWithoutTopicInput[]
    createMany?: MaterialCreateManyTopicInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ExerciseCreateWithoutTopicInput, ExerciseUncheckedCreateWithoutTopicInput> | ExerciseCreateWithoutTopicInput[] | ExerciseUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutTopicInput | ExerciseCreateOrConnectWithoutTopicInput[]
    createMany?: ExerciseCreateManyTopicInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ObjectiveCreateWithoutTopicInput, ObjectiveUncheckedCreateWithoutTopicInput> | ObjectiveCreateWithoutTopicInput[] | ObjectiveUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ObjectiveCreateOrConnectWithoutTopicInput | ObjectiveCreateOrConnectWithoutTopicInput[]
    createMany?: ObjectiveCreateManyTopicInputEnvelope
    connect?: ObjectiveWhereUniqueInput | ObjectiveWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput> | CommentCreateWithoutTopicInput[] | CommentUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTopicInput | CommentCreateOrConnectWithoutTopicInput[]
    createMany?: CommentCreateManyTopicInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ModuleUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<ModuleCreateWithoutTopicsInput, ModuleUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTopicsInput
    upsert?: ModuleUpsertWithoutTopicsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutTopicsInput, ModuleUpdateWithoutTopicsInput>, ModuleUncheckedUpdateWithoutTopicsInput>
  }

  export type MaterialUpdateManyWithoutTopicNestedInput = {
    create?: XOR<MaterialCreateWithoutTopicInput, MaterialUncheckedCreateWithoutTopicInput> | MaterialCreateWithoutTopicInput[] | MaterialUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutTopicInput | MaterialCreateOrConnectWithoutTopicInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutTopicInput | MaterialUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: MaterialCreateManyTopicInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutTopicInput | MaterialUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutTopicInput | MaterialUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ExerciseUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ExerciseCreateWithoutTopicInput, ExerciseUncheckedCreateWithoutTopicInput> | ExerciseCreateWithoutTopicInput[] | ExerciseUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutTopicInput | ExerciseCreateOrConnectWithoutTopicInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutTopicInput | ExerciseUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ExerciseCreateManyTopicInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutTopicInput | ExerciseUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutTopicInput | ExerciseUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ObjectiveUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ObjectiveCreateWithoutTopicInput, ObjectiveUncheckedCreateWithoutTopicInput> | ObjectiveCreateWithoutTopicInput[] | ObjectiveUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ObjectiveCreateOrConnectWithoutTopicInput | ObjectiveCreateOrConnectWithoutTopicInput[]
    upsert?: ObjectiveUpsertWithWhereUniqueWithoutTopicInput | ObjectiveUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ObjectiveCreateManyTopicInputEnvelope
    set?: ObjectiveWhereUniqueInput | ObjectiveWhereUniqueInput[]
    disconnect?: ObjectiveWhereUniqueInput | ObjectiveWhereUniqueInput[]
    delete?: ObjectiveWhereUniqueInput | ObjectiveWhereUniqueInput[]
    connect?: ObjectiveWhereUniqueInput | ObjectiveWhereUniqueInput[]
    update?: ObjectiveUpdateWithWhereUniqueWithoutTopicInput | ObjectiveUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ObjectiveUpdateManyWithWhereWithoutTopicInput | ObjectiveUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ObjectiveScalarWhereInput | ObjectiveScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTopicNestedInput = {
    create?: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput> | CommentCreateWithoutTopicInput[] | CommentUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTopicInput | CommentCreateOrConnectWithoutTopicInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTopicInput | CommentUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: CommentCreateManyTopicInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTopicInput | CommentUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTopicInput | CommentUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<MaterialCreateWithoutTopicInput, MaterialUncheckedCreateWithoutTopicInput> | MaterialCreateWithoutTopicInput[] | MaterialUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutTopicInput | MaterialCreateOrConnectWithoutTopicInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutTopicInput | MaterialUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: MaterialCreateManyTopicInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutTopicInput | MaterialUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutTopicInput | MaterialUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ExerciseCreateWithoutTopicInput, ExerciseUncheckedCreateWithoutTopicInput> | ExerciseCreateWithoutTopicInput[] | ExerciseUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutTopicInput | ExerciseCreateOrConnectWithoutTopicInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutTopicInput | ExerciseUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ExerciseCreateManyTopicInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutTopicInput | ExerciseUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutTopicInput | ExerciseUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ObjectiveUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ObjectiveCreateWithoutTopicInput, ObjectiveUncheckedCreateWithoutTopicInput> | ObjectiveCreateWithoutTopicInput[] | ObjectiveUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ObjectiveCreateOrConnectWithoutTopicInput | ObjectiveCreateOrConnectWithoutTopicInput[]
    upsert?: ObjectiveUpsertWithWhereUniqueWithoutTopicInput | ObjectiveUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ObjectiveCreateManyTopicInputEnvelope
    set?: ObjectiveWhereUniqueInput | ObjectiveWhereUniqueInput[]
    disconnect?: ObjectiveWhereUniqueInput | ObjectiveWhereUniqueInput[]
    delete?: ObjectiveWhereUniqueInput | ObjectiveWhereUniqueInput[]
    connect?: ObjectiveWhereUniqueInput | ObjectiveWhereUniqueInput[]
    update?: ObjectiveUpdateWithWhereUniqueWithoutTopicInput | ObjectiveUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ObjectiveUpdateManyWithWhereWithoutTopicInput | ObjectiveUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ObjectiveScalarWhereInput | ObjectiveScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput> | CommentCreateWithoutTopicInput[] | CommentUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTopicInput | CommentCreateOrConnectWithoutTopicInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTopicInput | CommentUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: CommentCreateManyTopicInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTopicInput | CommentUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTopicInput | CommentUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TopicCreateNestedOneWithoutObjectivesInput = {
    create?: XOR<TopicCreateWithoutObjectivesInput, TopicUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutObjectivesInput
    connect?: TopicWhereUniqueInput
  }

  export type TopicUpdateOneRequiredWithoutObjectivesNestedInput = {
    create?: XOR<TopicCreateWithoutObjectivesInput, TopicUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutObjectivesInput
    upsert?: TopicUpsertWithoutObjectivesInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutObjectivesInput, TopicUpdateWithoutObjectivesInput>, TopicUncheckedUpdateWithoutObjectivesInput>
  }

  export type ModuleCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ModuleCreateWithoutAssignmentsInput, ModuleUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutAssignmentsInput
    connect?: ModuleWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutModuleAssignmentsInput = {
    create?: XOR<TeacherCreateWithoutModuleAssignmentsInput, TeacherUncheckedCreateWithoutModuleAssignmentsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutModuleAssignmentsInput
    connect?: TeacherWhereUniqueInput
  }

  export type EnumCurrencyTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.CurrencyTypeEnum
  }

  export type ModuleUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ModuleCreateWithoutAssignmentsInput, ModuleUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutAssignmentsInput
    upsert?: ModuleUpsertWithoutAssignmentsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutAssignmentsInput, ModuleUpdateWithoutAssignmentsInput>, ModuleUncheckedUpdateWithoutAssignmentsInput>
  }

  export type TeacherUpdateOneRequiredWithoutModuleAssignmentsNestedInput = {
    create?: XOR<TeacherCreateWithoutModuleAssignmentsInput, TeacherUncheckedCreateWithoutModuleAssignmentsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutModuleAssignmentsInput
    upsert?: TeacherUpsertWithoutModuleAssignmentsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutModuleAssignmentsInput, TeacherUpdateWithoutModuleAssignmentsInput>, TeacherUncheckedUpdateWithoutModuleAssignmentsInput>
  }

  export type TopicCreateNestedOneWithoutExercisesInput = {
    create?: XOR<TopicCreateWithoutExercisesInput, TopicUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutExercisesInput
    connect?: TopicWhereUniqueInput
  }

  export type ExamExerciseCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExamExerciseCreateWithoutExerciseInput, ExamExerciseUncheckedCreateWithoutExerciseInput> | ExamExerciseCreateWithoutExerciseInput[] | ExamExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExamExerciseCreateOrConnectWithoutExerciseInput | ExamExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: ExamExerciseCreateManyExerciseInputEnvelope
    connect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
  }

  export type TeacherCreateNestedOneWithoutCreatedExercisesInput = {
    create?: XOR<TeacherCreateWithoutCreatedExercisesInput, TeacherUncheckedCreateWithoutCreatedExercisesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedExercisesInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutOwnedExercisesInput = {
    create?: XOR<TeacherCreateWithoutOwnedExercisesInput, TeacherUncheckedCreateWithoutOwnedExercisesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutOwnedExercisesInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeamCreateNestedManyWithoutExercisesInput = {
    create?: XOR<TeamCreateWithoutExercisesInput, TeamUncheckedCreateWithoutExercisesInput> | TeamCreateWithoutExercisesInput[] | TeamUncheckedCreateWithoutExercisesInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutExercisesInput | TeamCreateOrConnectWithoutExercisesInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type ClientCreateNestedOneWithoutExercisesInput = {
    create?: XOR<ClientCreateWithoutExercisesInput, ClientUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutExercisesInput
    connect?: ClientWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutExerciseInput = {
    create?: XOR<CommentCreateWithoutExerciseInput, CommentUncheckedCreateWithoutExerciseInput> | CommentCreateWithoutExerciseInput[] | CommentUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutExerciseInput | CommentCreateOrConnectWithoutExerciseInput[]
    createMany?: CommentCreateManyExerciseInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ShopItemForSaleCreateNestedOneWithoutExerciseInput = {
    create?: XOR<ShopItemForSaleCreateWithoutExerciseInput, ShopItemForSaleUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutExerciseInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type ShopItemForRentCreateNestedOneWithoutExerciseInput = {
    create?: XOR<ShopItemForRentCreateWithoutExerciseInput, ShopItemForRentUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutExerciseInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type ExamExerciseUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExamExerciseCreateWithoutExerciseInput, ExamExerciseUncheckedCreateWithoutExerciseInput> | ExamExerciseCreateWithoutExerciseInput[] | ExamExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExamExerciseCreateOrConnectWithoutExerciseInput | ExamExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: ExamExerciseCreateManyExerciseInputEnvelope
    connect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutExercisesInput = {
    create?: XOR<TeamCreateWithoutExercisesInput, TeamUncheckedCreateWithoutExercisesInput> | TeamCreateWithoutExercisesInput[] | TeamUncheckedCreateWithoutExercisesInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutExercisesInput | TeamCreateOrConnectWithoutExercisesInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<CommentCreateWithoutExerciseInput, CommentUncheckedCreateWithoutExerciseInput> | CommentCreateWithoutExerciseInput[] | CommentUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutExerciseInput | CommentCreateOrConnectWithoutExerciseInput[]
    createMany?: CommentCreateManyExerciseInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ShopItemForSaleUncheckedCreateNestedOneWithoutExerciseInput = {
    create?: XOR<ShopItemForSaleCreateWithoutExerciseInput, ShopItemForSaleUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutExerciseInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type ShopItemForRentUncheckedCreateNestedOneWithoutExerciseInput = {
    create?: XOR<ShopItemForRentCreateWithoutExerciseInput, ShopItemForRentUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutExerciseInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type EnumExerciseTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.ExerciseTypeEnum
  }

  export type EnumDifficultyLevelEnumFieldUpdateOperationsInput = {
    set?: $Enums.DifficultyLevelEnum
  }

  export type TopicUpdateOneWithoutExercisesNestedInput = {
    create?: XOR<TopicCreateWithoutExercisesInput, TopicUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutExercisesInput
    upsert?: TopicUpsertWithoutExercisesInput
    disconnect?: TopicWhereInput | boolean
    delete?: TopicWhereInput | boolean
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutExercisesInput, TopicUpdateWithoutExercisesInput>, TopicUncheckedUpdateWithoutExercisesInput>
  }

  export type ExamExerciseUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExamExerciseCreateWithoutExerciseInput, ExamExerciseUncheckedCreateWithoutExerciseInput> | ExamExerciseCreateWithoutExerciseInput[] | ExamExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExamExerciseCreateOrConnectWithoutExerciseInput | ExamExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: ExamExerciseUpsertWithWhereUniqueWithoutExerciseInput | ExamExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExamExerciseCreateManyExerciseInputEnvelope
    set?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    disconnect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    delete?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    connect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    update?: ExamExerciseUpdateWithWhereUniqueWithoutExerciseInput | ExamExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExamExerciseUpdateManyWithWhereWithoutExerciseInput | ExamExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExamExerciseScalarWhereInput | ExamExerciseScalarWhereInput[]
  }

  export type TeacherUpdateOneRequiredWithoutCreatedExercisesNestedInput = {
    create?: XOR<TeacherCreateWithoutCreatedExercisesInput, TeacherUncheckedCreateWithoutCreatedExercisesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedExercisesInput
    upsert?: TeacherUpsertWithoutCreatedExercisesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutCreatedExercisesInput, TeacherUpdateWithoutCreatedExercisesInput>, TeacherUncheckedUpdateWithoutCreatedExercisesInput>
  }

  export type TeacherUpdateOneRequiredWithoutOwnedExercisesNestedInput = {
    create?: XOR<TeacherCreateWithoutOwnedExercisesInput, TeacherUncheckedCreateWithoutOwnedExercisesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutOwnedExercisesInput
    upsert?: TeacherUpsertWithoutOwnedExercisesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutOwnedExercisesInput, TeacherUpdateWithoutOwnedExercisesInput>, TeacherUncheckedUpdateWithoutOwnedExercisesInput>
  }

  export type TeamUpdateManyWithoutExercisesNestedInput = {
    create?: XOR<TeamCreateWithoutExercisesInput, TeamUncheckedCreateWithoutExercisesInput> | TeamCreateWithoutExercisesInput[] | TeamUncheckedCreateWithoutExercisesInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutExercisesInput | TeamCreateOrConnectWithoutExercisesInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutExercisesInput | TeamUpsertWithWhereUniqueWithoutExercisesInput[]
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutExercisesInput | TeamUpdateWithWhereUniqueWithoutExercisesInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutExercisesInput | TeamUpdateManyWithWhereWithoutExercisesInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type ClientUpdateOneWithoutExercisesNestedInput = {
    create?: XOR<ClientCreateWithoutExercisesInput, ClientUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutExercisesInput
    upsert?: ClientUpsertWithoutExercisesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutExercisesInput, ClientUpdateWithoutExercisesInput>, ClientUncheckedUpdateWithoutExercisesInput>
  }

  export type CommentUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<CommentCreateWithoutExerciseInput, CommentUncheckedCreateWithoutExerciseInput> | CommentCreateWithoutExerciseInput[] | CommentUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutExerciseInput | CommentCreateOrConnectWithoutExerciseInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutExerciseInput | CommentUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: CommentCreateManyExerciseInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutExerciseInput | CommentUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutExerciseInput | CommentUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ShopItemForSaleUpdateOneWithoutExerciseNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutExerciseInput, ShopItemForSaleUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutExerciseInput
    upsert?: ShopItemForSaleUpsertWithoutExerciseInput
    disconnect?: ShopItemForSaleWhereInput | boolean
    delete?: ShopItemForSaleWhereInput | boolean
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutExerciseInput, ShopItemForSaleUpdateWithoutExerciseInput>, ShopItemForSaleUncheckedUpdateWithoutExerciseInput>
  }

  export type ShopItemForRentUpdateOneWithoutExerciseNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutExerciseInput, ShopItemForRentUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutExerciseInput
    upsert?: ShopItemForRentUpsertWithoutExerciseInput
    disconnect?: ShopItemForRentWhereInput | boolean
    delete?: ShopItemForRentWhereInput | boolean
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutExerciseInput, ShopItemForRentUpdateWithoutExerciseInput>, ShopItemForRentUncheckedUpdateWithoutExerciseInput>
  }

  export type ExamExerciseUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExamExerciseCreateWithoutExerciseInput, ExamExerciseUncheckedCreateWithoutExerciseInput> | ExamExerciseCreateWithoutExerciseInput[] | ExamExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExamExerciseCreateOrConnectWithoutExerciseInput | ExamExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: ExamExerciseUpsertWithWhereUniqueWithoutExerciseInput | ExamExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExamExerciseCreateManyExerciseInputEnvelope
    set?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    disconnect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    delete?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    connect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    update?: ExamExerciseUpdateWithWhereUniqueWithoutExerciseInput | ExamExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExamExerciseUpdateManyWithWhereWithoutExerciseInput | ExamExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExamExerciseScalarWhereInput | ExamExerciseScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutExercisesNestedInput = {
    create?: XOR<TeamCreateWithoutExercisesInput, TeamUncheckedCreateWithoutExercisesInput> | TeamCreateWithoutExercisesInput[] | TeamUncheckedCreateWithoutExercisesInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutExercisesInput | TeamCreateOrConnectWithoutExercisesInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutExercisesInput | TeamUpsertWithWhereUniqueWithoutExercisesInput[]
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutExercisesInput | TeamUpdateWithWhereUniqueWithoutExercisesInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutExercisesInput | TeamUpdateManyWithWhereWithoutExercisesInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<CommentCreateWithoutExerciseInput, CommentUncheckedCreateWithoutExerciseInput> | CommentCreateWithoutExerciseInput[] | CommentUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutExerciseInput | CommentCreateOrConnectWithoutExerciseInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutExerciseInput | CommentUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: CommentCreateManyExerciseInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutExerciseInput | CommentUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutExerciseInput | CommentUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ShopItemForSaleUncheckedUpdateOneWithoutExerciseNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutExerciseInput, ShopItemForSaleUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutExerciseInput
    upsert?: ShopItemForSaleUpsertWithoutExerciseInput
    disconnect?: ShopItemForSaleWhereInput | boolean
    delete?: ShopItemForSaleWhereInput | boolean
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutExerciseInput, ShopItemForSaleUpdateWithoutExerciseInput>, ShopItemForSaleUncheckedUpdateWithoutExerciseInput>
  }

  export type ShopItemForRentUncheckedUpdateOneWithoutExerciseNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutExerciseInput, ShopItemForRentUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutExerciseInput
    upsert?: ShopItemForRentUpsertWithoutExerciseInput
    disconnect?: ShopItemForRentWhereInput | boolean
    delete?: ShopItemForRentWhereInput | boolean
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutExerciseInput, ShopItemForRentUpdateWithoutExerciseInput>, ShopItemForRentUncheckedUpdateWithoutExerciseInput>
  }

  export type ModuleCreateNestedOneWithoutExamsInput = {
    create?: XOR<ModuleCreateWithoutExamsInput, ModuleUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutExamsInput
    connect?: ModuleWhereUniqueInput
  }

  export type ExamExerciseCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamExerciseCreateWithoutExamInput, ExamExerciseUncheckedCreateWithoutExamInput> | ExamExerciseCreateWithoutExamInput[] | ExamExerciseUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamExerciseCreateOrConnectWithoutExamInput | ExamExerciseCreateOrConnectWithoutExamInput[]
    createMany?: ExamExerciseCreateManyExamInputEnvelope
    connect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
  }

  export type TeacherCreateNestedOneWithoutCreatedExamsInput = {
    create?: XOR<TeacherCreateWithoutCreatedExamsInput, TeacherUncheckedCreateWithoutCreatedExamsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedExamsInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutOwnedExamsInput = {
    create?: XOR<TeacherCreateWithoutOwnedExamsInput, TeacherUncheckedCreateWithoutOwnedExamsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutOwnedExamsInput
    connect?: TeacherWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutExamInput = {
    create?: XOR<CommentCreateWithoutExamInput, CommentUncheckedCreateWithoutExamInput> | CommentCreateWithoutExamInput[] | CommentUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutExamInput | CommentCreateOrConnectWithoutExamInput[]
    createMany?: CommentCreateManyExamInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ShopItemForSaleCreateNestedOneWithoutExamInput = {
    create?: XOR<ShopItemForSaleCreateWithoutExamInput, ShopItemForSaleUncheckedCreateWithoutExamInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutExamInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type ShopItemForRentCreateNestedOneWithoutExamInput = {
    create?: XOR<ShopItemForRentCreateWithoutExamInput, ShopItemForRentUncheckedCreateWithoutExamInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutExamInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type ExamExerciseUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamExerciseCreateWithoutExamInput, ExamExerciseUncheckedCreateWithoutExamInput> | ExamExerciseCreateWithoutExamInput[] | ExamExerciseUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamExerciseCreateOrConnectWithoutExamInput | ExamExerciseCreateOrConnectWithoutExamInput[]
    createMany?: ExamExerciseCreateManyExamInputEnvelope
    connect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<CommentCreateWithoutExamInput, CommentUncheckedCreateWithoutExamInput> | CommentCreateWithoutExamInput[] | CommentUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutExamInput | CommentCreateOrConnectWithoutExamInput[]
    createMany?: CommentCreateManyExamInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ShopItemForSaleUncheckedCreateNestedOneWithoutExamInput = {
    create?: XOR<ShopItemForSaleCreateWithoutExamInput, ShopItemForSaleUncheckedCreateWithoutExamInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutExamInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type ShopItemForRentUncheckedCreateNestedOneWithoutExamInput = {
    create?: XOR<ShopItemForRentCreateWithoutExamInput, ShopItemForRentUncheckedCreateWithoutExamInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutExamInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type EnumExamTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.ExamTypeEnum
  }

  export type ModuleUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<ModuleCreateWithoutExamsInput, ModuleUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutExamsInput
    upsert?: ModuleUpsertWithoutExamsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutExamsInput, ModuleUpdateWithoutExamsInput>, ModuleUncheckedUpdateWithoutExamsInput>
  }

  export type ExamExerciseUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamExerciseCreateWithoutExamInput, ExamExerciseUncheckedCreateWithoutExamInput> | ExamExerciseCreateWithoutExamInput[] | ExamExerciseUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamExerciseCreateOrConnectWithoutExamInput | ExamExerciseCreateOrConnectWithoutExamInput[]
    upsert?: ExamExerciseUpsertWithWhereUniqueWithoutExamInput | ExamExerciseUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamExerciseCreateManyExamInputEnvelope
    set?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    disconnect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    delete?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    connect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    update?: ExamExerciseUpdateWithWhereUniqueWithoutExamInput | ExamExerciseUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamExerciseUpdateManyWithWhereWithoutExamInput | ExamExerciseUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamExerciseScalarWhereInput | ExamExerciseScalarWhereInput[]
  }

  export type TeacherUpdateOneRequiredWithoutCreatedExamsNestedInput = {
    create?: XOR<TeacherCreateWithoutCreatedExamsInput, TeacherUncheckedCreateWithoutCreatedExamsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedExamsInput
    upsert?: TeacherUpsertWithoutCreatedExamsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutCreatedExamsInput, TeacherUpdateWithoutCreatedExamsInput>, TeacherUncheckedUpdateWithoutCreatedExamsInput>
  }

  export type TeacherUpdateOneRequiredWithoutOwnedExamsNestedInput = {
    create?: XOR<TeacherCreateWithoutOwnedExamsInput, TeacherUncheckedCreateWithoutOwnedExamsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutOwnedExamsInput
    upsert?: TeacherUpsertWithoutOwnedExamsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutOwnedExamsInput, TeacherUpdateWithoutOwnedExamsInput>, TeacherUncheckedUpdateWithoutOwnedExamsInput>
  }

  export type CommentUpdateManyWithoutExamNestedInput = {
    create?: XOR<CommentCreateWithoutExamInput, CommentUncheckedCreateWithoutExamInput> | CommentCreateWithoutExamInput[] | CommentUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutExamInput | CommentCreateOrConnectWithoutExamInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutExamInput | CommentUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: CommentCreateManyExamInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutExamInput | CommentUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutExamInput | CommentUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ShopItemForSaleUpdateOneWithoutExamNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutExamInput, ShopItemForSaleUncheckedCreateWithoutExamInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutExamInput
    upsert?: ShopItemForSaleUpsertWithoutExamInput
    disconnect?: ShopItemForSaleWhereInput | boolean
    delete?: ShopItemForSaleWhereInput | boolean
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutExamInput, ShopItemForSaleUpdateWithoutExamInput>, ShopItemForSaleUncheckedUpdateWithoutExamInput>
  }

  export type ShopItemForRentUpdateOneWithoutExamNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutExamInput, ShopItemForRentUncheckedCreateWithoutExamInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutExamInput
    upsert?: ShopItemForRentUpsertWithoutExamInput
    disconnect?: ShopItemForRentWhereInput | boolean
    delete?: ShopItemForRentWhereInput | boolean
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutExamInput, ShopItemForRentUpdateWithoutExamInput>, ShopItemForRentUncheckedUpdateWithoutExamInput>
  }

  export type ExamExerciseUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamExerciseCreateWithoutExamInput, ExamExerciseUncheckedCreateWithoutExamInput> | ExamExerciseCreateWithoutExamInput[] | ExamExerciseUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamExerciseCreateOrConnectWithoutExamInput | ExamExerciseCreateOrConnectWithoutExamInput[]
    upsert?: ExamExerciseUpsertWithWhereUniqueWithoutExamInput | ExamExerciseUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamExerciseCreateManyExamInputEnvelope
    set?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    disconnect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    delete?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    connect?: ExamExerciseWhereUniqueInput | ExamExerciseWhereUniqueInput[]
    update?: ExamExerciseUpdateWithWhereUniqueWithoutExamInput | ExamExerciseUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamExerciseUpdateManyWithWhereWithoutExamInput | ExamExerciseUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamExerciseScalarWhereInput | ExamExerciseScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<CommentCreateWithoutExamInput, CommentUncheckedCreateWithoutExamInput> | CommentCreateWithoutExamInput[] | CommentUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutExamInput | CommentCreateOrConnectWithoutExamInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutExamInput | CommentUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: CommentCreateManyExamInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutExamInput | CommentUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutExamInput | CommentUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ShopItemForSaleUncheckedUpdateOneWithoutExamNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutExamInput, ShopItemForSaleUncheckedCreateWithoutExamInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutExamInput
    upsert?: ShopItemForSaleUpsertWithoutExamInput
    disconnect?: ShopItemForSaleWhereInput | boolean
    delete?: ShopItemForSaleWhereInput | boolean
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutExamInput, ShopItemForSaleUpdateWithoutExamInput>, ShopItemForSaleUncheckedUpdateWithoutExamInput>
  }

  export type ShopItemForRentUncheckedUpdateOneWithoutExamNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutExamInput, ShopItemForRentUncheckedCreateWithoutExamInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutExamInput
    upsert?: ShopItemForRentUpsertWithoutExamInput
    disconnect?: ShopItemForRentWhereInput | boolean
    delete?: ShopItemForRentWhereInput | boolean
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutExamInput, ShopItemForRentUpdateWithoutExamInput>, ShopItemForRentUncheckedUpdateWithoutExamInput>
  }

  export type ExamCreateNestedOneWithoutExercisesInput = {
    create?: XOR<ExamCreateWithoutExercisesInput, ExamUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: ExamCreateOrConnectWithoutExercisesInput
    connect?: ExamWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutExamExercisesInput = {
    create?: XOR<ExerciseCreateWithoutExamExercisesInput, ExerciseUncheckedCreateWithoutExamExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutExamExercisesInput
    connect?: ExerciseWhereUniqueInput
  }

  export type ExamUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<ExamCreateWithoutExercisesInput, ExamUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: ExamCreateOrConnectWithoutExercisesInput
    upsert?: ExamUpsertWithoutExercisesInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutExercisesInput, ExamUpdateWithoutExercisesInput>, ExamUncheckedUpdateWithoutExercisesInput>
  }

  export type ExerciseUpdateOneRequiredWithoutExamExercisesNestedInput = {
    create?: XOR<ExerciseCreateWithoutExamExercisesInput, ExerciseUncheckedCreateWithoutExamExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutExamExercisesInput
    upsert?: ExerciseUpsertWithoutExamExercisesInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutExamExercisesInput, ExerciseUpdateWithoutExamExercisesInput>, ExerciseUncheckedUpdateWithoutExamExercisesInput>
  }

  export type CourseCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<CourseCreateWithoutMaterialsInput, CourseUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutMaterialsInput
    connect?: CourseWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<ModuleCreateWithoutMaterialsInput, ModuleUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutMaterialsInput
    connect?: ModuleWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<TopicCreateWithoutMaterialsInput, TopicUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutMaterialsInput
    connect?: TopicWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutMaterialInput = {
    create?: XOR<CommentCreateWithoutMaterialInput, CommentUncheckedCreateWithoutMaterialInput> | CommentCreateWithoutMaterialInput[] | CommentUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMaterialInput | CommentCreateOrConnectWithoutMaterialInput[]
    createMany?: CommentCreateManyMaterialInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TeacherCreateNestedOneWithoutCreatedMaterialInput = {
    create?: XOR<TeacherCreateWithoutCreatedMaterialInput, TeacherUncheckedCreateWithoutCreatedMaterialInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedMaterialInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutOwnedMaterialInput = {
    create?: XOR<TeacherCreateWithoutOwnedMaterialInput, TeacherUncheckedCreateWithoutOwnedMaterialInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutOwnedMaterialInput
    connect?: TeacherWhereUniqueInput
  }

  export type ShopItemForSaleCreateNestedOneWithoutMaterialInput = {
    create?: XOR<ShopItemForSaleCreateWithoutMaterialInput, ShopItemForSaleUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutMaterialInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type ShopItemForRentCreateNestedOneWithoutMaterialInput = {
    create?: XOR<ShopItemForRentCreateWithoutMaterialInput, ShopItemForRentUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutMaterialInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<CommentCreateWithoutMaterialInput, CommentUncheckedCreateWithoutMaterialInput> | CommentCreateWithoutMaterialInput[] | CommentUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMaterialInput | CommentCreateOrConnectWithoutMaterialInput[]
    createMany?: CommentCreateManyMaterialInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ShopItemForSaleUncheckedCreateNestedOneWithoutMaterialInput = {
    create?: XOR<ShopItemForSaleCreateWithoutMaterialInput, ShopItemForSaleUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutMaterialInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type ShopItemForRentUncheckedCreateNestedOneWithoutMaterialInput = {
    create?: XOR<ShopItemForRentCreateWithoutMaterialInput, ShopItemForRentUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutMaterialInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type EnumMaterialTypeFieldUpdateOperationsInput = {
    set?: $Enums.MaterialType
  }

  export type CourseUpdateOneWithoutMaterialsNestedInput = {
    create?: XOR<CourseCreateWithoutMaterialsInput, CourseUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutMaterialsInput
    upsert?: CourseUpsertWithoutMaterialsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutMaterialsInput, CourseUpdateWithoutMaterialsInput>, CourseUncheckedUpdateWithoutMaterialsInput>
  }

  export type ModuleUpdateOneWithoutMaterialsNestedInput = {
    create?: XOR<ModuleCreateWithoutMaterialsInput, ModuleUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutMaterialsInput
    upsert?: ModuleUpsertWithoutMaterialsInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutMaterialsInput, ModuleUpdateWithoutMaterialsInput>, ModuleUncheckedUpdateWithoutMaterialsInput>
  }

  export type TopicUpdateOneWithoutMaterialsNestedInput = {
    create?: XOR<TopicCreateWithoutMaterialsInput, TopicUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutMaterialsInput
    upsert?: TopicUpsertWithoutMaterialsInput
    disconnect?: TopicWhereInput | boolean
    delete?: TopicWhereInput | boolean
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutMaterialsInput, TopicUpdateWithoutMaterialsInput>, TopicUncheckedUpdateWithoutMaterialsInput>
  }

  export type CommentUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<CommentCreateWithoutMaterialInput, CommentUncheckedCreateWithoutMaterialInput> | CommentCreateWithoutMaterialInput[] | CommentUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMaterialInput | CommentCreateOrConnectWithoutMaterialInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutMaterialInput | CommentUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: CommentCreateManyMaterialInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutMaterialInput | CommentUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutMaterialInput | CommentUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TeacherUpdateOneRequiredWithoutCreatedMaterialNestedInput = {
    create?: XOR<TeacherCreateWithoutCreatedMaterialInput, TeacherUncheckedCreateWithoutCreatedMaterialInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedMaterialInput
    upsert?: TeacherUpsertWithoutCreatedMaterialInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutCreatedMaterialInput, TeacherUpdateWithoutCreatedMaterialInput>, TeacherUncheckedUpdateWithoutCreatedMaterialInput>
  }

  export type TeacherUpdateOneRequiredWithoutOwnedMaterialNestedInput = {
    create?: XOR<TeacherCreateWithoutOwnedMaterialInput, TeacherUncheckedCreateWithoutOwnedMaterialInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutOwnedMaterialInput
    upsert?: TeacherUpsertWithoutOwnedMaterialInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutOwnedMaterialInput, TeacherUpdateWithoutOwnedMaterialInput>, TeacherUncheckedUpdateWithoutOwnedMaterialInput>
  }

  export type ShopItemForSaleUpdateOneWithoutMaterialNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutMaterialInput, ShopItemForSaleUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutMaterialInput
    upsert?: ShopItemForSaleUpsertWithoutMaterialInput
    disconnect?: ShopItemForSaleWhereInput | boolean
    delete?: ShopItemForSaleWhereInput | boolean
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutMaterialInput, ShopItemForSaleUpdateWithoutMaterialInput>, ShopItemForSaleUncheckedUpdateWithoutMaterialInput>
  }

  export type ShopItemForRentUpdateOneWithoutMaterialNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutMaterialInput, ShopItemForRentUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutMaterialInput
    upsert?: ShopItemForRentUpsertWithoutMaterialInput
    disconnect?: ShopItemForRentWhereInput | boolean
    delete?: ShopItemForRentWhereInput | boolean
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutMaterialInput, ShopItemForRentUpdateWithoutMaterialInput>, ShopItemForRentUncheckedUpdateWithoutMaterialInput>
  }

  export type CommentUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<CommentCreateWithoutMaterialInput, CommentUncheckedCreateWithoutMaterialInput> | CommentCreateWithoutMaterialInput[] | CommentUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMaterialInput | CommentCreateOrConnectWithoutMaterialInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutMaterialInput | CommentUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: CommentCreateManyMaterialInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutMaterialInput | CommentUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutMaterialInput | CommentUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ShopItemForSaleUncheckedUpdateOneWithoutMaterialNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutMaterialInput, ShopItemForSaleUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutMaterialInput
    upsert?: ShopItemForSaleUpsertWithoutMaterialInput
    disconnect?: ShopItemForSaleWhereInput | boolean
    delete?: ShopItemForSaleWhereInput | boolean
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutMaterialInput, ShopItemForSaleUpdateWithoutMaterialInput>, ShopItemForSaleUncheckedUpdateWithoutMaterialInput>
  }

  export type ShopItemForRentUncheckedUpdateOneWithoutMaterialNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutMaterialInput, ShopItemForRentUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutMaterialInput
    upsert?: ShopItemForRentUpsertWithoutMaterialInput
    disconnect?: ShopItemForRentWhereInput | boolean
    delete?: ShopItemForRentWhereInput | boolean
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutMaterialInput, ShopItemForRentUpdateWithoutMaterialInput>, ShopItemForRentUncheckedUpdateWithoutMaterialInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutCommentsInput = {
    create?: XOR<CourseCreateWithoutCommentsInput, CourseUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCommentsInput
    connect?: CourseWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ModuleCreateWithoutCommentsInput, ModuleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutCommentsInput
    connect?: ModuleWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TopicCreateWithoutCommentsInput, TopicUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutCommentsInput
    connect?: TopicWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutCommentsInput = {
    create?: XOR<MaterialCreateWithoutCommentsInput, MaterialUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutCommentsInput
    connect?: MaterialWhereUniqueInput
  }

  export type EnrollmentCreateNestedOneWithoutCommentsInput = {
    create?: XOR<EnrollmentCreateWithoutCommentsInput, EnrollmentUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCommentsInput
    connect?: EnrollmentWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ClassCreateWithoutCommentsInput, ClassUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutCommentsInput
    connect?: ClassWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TeamCreateWithoutCommentsInput, TeamUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutCommentsInput
    connect?: TeamWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutCommentsInput = {
    create?: XOR<EventCreateWithoutCommentsInput, EventUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: EventCreateOrConnectWithoutCommentsInput
    connect?: EventWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutCommentsInput = {
    create?: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCommentsInput
    connect?: LessonWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ExamCreateWithoutCommentsInput, ExamUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutCommentsInput
    connect?: ExamWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ExerciseCreateWithoutCommentsInput, ExerciseUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutCommentsInput
    connect?: ExerciseWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutCommentsInput = {
    create?: XOR<StudentCreateWithoutCommentsInput, StudentUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCommentsInput
    connect?: StudentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CourseUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<CourseCreateWithoutCommentsInput, CourseUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCommentsInput
    upsert?: CourseUpsertWithoutCommentsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCommentsInput, CourseUpdateWithoutCommentsInput>, CourseUncheckedUpdateWithoutCommentsInput>
  }

  export type ModuleUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<ModuleCreateWithoutCommentsInput, ModuleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutCommentsInput
    upsert?: ModuleUpsertWithoutCommentsInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutCommentsInput, ModuleUpdateWithoutCommentsInput>, ModuleUncheckedUpdateWithoutCommentsInput>
  }

  export type TopicUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<TopicCreateWithoutCommentsInput, TopicUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutCommentsInput
    upsert?: TopicUpsertWithoutCommentsInput
    disconnect?: TopicWhereInput | boolean
    delete?: TopicWhereInput | boolean
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutCommentsInput, TopicUpdateWithoutCommentsInput>, TopicUncheckedUpdateWithoutCommentsInput>
  }

  export type MaterialUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<MaterialCreateWithoutCommentsInput, MaterialUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutCommentsInput
    upsert?: MaterialUpsertWithoutCommentsInput
    disconnect?: MaterialWhereInput | boolean
    delete?: MaterialWhereInput | boolean
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutCommentsInput, MaterialUpdateWithoutCommentsInput>, MaterialUncheckedUpdateWithoutCommentsInput>
  }

  export type EnrollmentUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCommentsInput, EnrollmentUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCommentsInput
    upsert?: EnrollmentUpsertWithoutCommentsInput
    disconnect?: EnrollmentWhereInput | boolean
    delete?: EnrollmentWhereInput | boolean
    connect?: EnrollmentWhereUniqueInput
    update?: XOR<XOR<EnrollmentUpdateToOneWithWhereWithoutCommentsInput, EnrollmentUpdateWithoutCommentsInput>, EnrollmentUncheckedUpdateWithoutCommentsInput>
  }

  export type ClassUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<ClassCreateWithoutCommentsInput, ClassUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutCommentsInput
    upsert?: ClassUpsertWithoutCommentsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutCommentsInput, ClassUpdateWithoutCommentsInput>, ClassUncheckedUpdateWithoutCommentsInput>
  }

  export type TeamUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<TeamCreateWithoutCommentsInput, TeamUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutCommentsInput
    upsert?: TeamUpsertWithoutCommentsInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutCommentsInput, TeamUpdateWithoutCommentsInput>, TeamUncheckedUpdateWithoutCommentsInput>
  }

  export type EventUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<EventCreateWithoutCommentsInput, EventUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: EventCreateOrConnectWithoutCommentsInput
    upsert?: EventUpsertWithoutCommentsInput
    disconnect?: EventWhereInput | boolean
    delete?: EventWhereInput | boolean
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutCommentsInput, EventUpdateWithoutCommentsInput>, EventUncheckedUpdateWithoutCommentsInput>
  }

  export type LessonUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCommentsInput
    upsert?: LessonUpsertWithoutCommentsInput
    disconnect?: LessonWhereInput | boolean
    delete?: LessonWhereInput | boolean
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutCommentsInput, LessonUpdateWithoutCommentsInput>, LessonUncheckedUpdateWithoutCommentsInput>
  }

  export type ExamUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<ExamCreateWithoutCommentsInput, ExamUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutCommentsInput
    upsert?: ExamUpsertWithoutCommentsInput
    disconnect?: ExamWhereInput | boolean
    delete?: ExamWhereInput | boolean
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutCommentsInput, ExamUpdateWithoutCommentsInput>, ExamUncheckedUpdateWithoutCommentsInput>
  }

  export type ExerciseUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<ExerciseCreateWithoutCommentsInput, ExerciseUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutCommentsInput
    upsert?: ExerciseUpsertWithoutCommentsInput
    disconnect?: ExerciseWhereInput | boolean
    delete?: ExerciseWhereInput | boolean
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutCommentsInput, ExerciseUpdateWithoutCommentsInput>, ExerciseUncheckedUpdateWithoutCommentsInput>
  }

  export type StudentUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<StudentCreateWithoutCommentsInput, StudentUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCommentsInput
    upsert?: StudentUpsertWithoutCommentsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutCommentsInput, StudentUpdateWithoutCommentsInput>, StudentUncheckedUpdateWithoutCommentsInput>
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutEnrollmentsInput
    connect?: ClassWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<TeacherCreateWithoutEnrollmentsInput, TeacherUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutEnrollmentsInput
    connect?: TeacherWhereUniqueInput
  }

  export type HolidayCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<HolidayCreateWithoutEnrollmentInput, HolidayUncheckedCreateWithoutEnrollmentInput> | HolidayCreateWithoutEnrollmentInput[] | HolidayUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutEnrollmentInput | HolidayCreateOrConnectWithoutEnrollmentInput[]
    createMany?: HolidayCreateManyEnrollmentInputEnvelope
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<CommentCreateWithoutEnrollmentInput, CommentUncheckedCreateWithoutEnrollmentInput> | CommentCreateWithoutEnrollmentInput[] | CommentUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEnrollmentInput | CommentCreateOrConnectWithoutEnrollmentInput[]
    createMany?: CommentCreateManyEnrollmentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type HolidayUncheckedCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<HolidayCreateWithoutEnrollmentInput, HolidayUncheckedCreateWithoutEnrollmentInput> | HolidayCreateWithoutEnrollmentInput[] | HolidayUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutEnrollmentInput | HolidayCreateOrConnectWithoutEnrollmentInput[]
    createMany?: HolidayCreateManyEnrollmentInputEnvelope
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<CommentCreateWithoutEnrollmentInput, CommentUncheckedCreateWithoutEnrollmentInput> | CommentCreateWithoutEnrollmentInput[] | CommentUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEnrollmentInput | CommentCreateOrConnectWithoutEnrollmentInput[]
    createMany?: CommentCreateManyEnrollmentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumEnrollmentStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.EnrollmentStatusEnum
  }

  export type CourseUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ClassUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutEnrollmentsInput
    upsert?: ClassUpsertWithoutEnrollmentsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutEnrollmentsInput, ClassUpdateWithoutEnrollmentsInput>, ClassUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type TeacherUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<TeacherCreateWithoutEnrollmentsInput, TeacherUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutEnrollmentsInput
    upsert?: TeacherUpsertWithoutEnrollmentsInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutEnrollmentsInput, TeacherUpdateWithoutEnrollmentsInput>, TeacherUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type HolidayUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<HolidayCreateWithoutEnrollmentInput, HolidayUncheckedCreateWithoutEnrollmentInput> | HolidayCreateWithoutEnrollmentInput[] | HolidayUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutEnrollmentInput | HolidayCreateOrConnectWithoutEnrollmentInput[]
    upsert?: HolidayUpsertWithWhereUniqueWithoutEnrollmentInput | HolidayUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: HolidayCreateManyEnrollmentInputEnvelope
    set?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    disconnect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    delete?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    update?: HolidayUpdateWithWhereUniqueWithoutEnrollmentInput | HolidayUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: HolidayUpdateManyWithWhereWithoutEnrollmentInput | HolidayUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<CommentCreateWithoutEnrollmentInput, CommentUncheckedCreateWithoutEnrollmentInput> | CommentCreateWithoutEnrollmentInput[] | CommentUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEnrollmentInput | CommentCreateOrConnectWithoutEnrollmentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutEnrollmentInput | CommentUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: CommentCreateManyEnrollmentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutEnrollmentInput | CommentUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutEnrollmentInput | CommentUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type HolidayUncheckedUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<HolidayCreateWithoutEnrollmentInput, HolidayUncheckedCreateWithoutEnrollmentInput> | HolidayCreateWithoutEnrollmentInput[] | HolidayUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutEnrollmentInput | HolidayCreateOrConnectWithoutEnrollmentInput[]
    upsert?: HolidayUpsertWithWhereUniqueWithoutEnrollmentInput | HolidayUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: HolidayCreateManyEnrollmentInputEnvelope
    set?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    disconnect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    delete?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    update?: HolidayUpdateWithWhereUniqueWithoutEnrollmentInput | HolidayUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: HolidayUpdateManyWithWhereWithoutEnrollmentInput | HolidayUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<CommentCreateWithoutEnrollmentInput, CommentUncheckedCreateWithoutEnrollmentInput> | CommentCreateWithoutEnrollmentInput[] | CommentUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEnrollmentInput | CommentCreateOrConnectWithoutEnrollmentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutEnrollmentInput | CommentUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: CommentCreateManyEnrollmentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutEnrollmentInput | CommentUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutEnrollmentInput | CommentUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutClassesInput = {
    create?: XOR<CourseCreateWithoutClassesInput, CourseUncheckedCreateWithoutClassesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutClassesInput
    connect?: CourseWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutClassesInput = {
    create?: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassesInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutClassesInput = {
    create?: XOR<StudentCreateWithoutClassesInput, StudentUncheckedCreateWithoutClassesInput> | StudentCreateWithoutClassesInput[] | StudentUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassesInput | StudentCreateOrConnectWithoutClassesInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutClassInput = {
    create?: XOR<TeamCreateWithoutClassInput, TeamUncheckedCreateWithoutClassInput> | TeamCreateWithoutClassInput[] | TeamUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutClassInput | TeamCreateOrConnectWithoutClassInput[]
    createMany?: TeamCreateManyClassInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutClassInput = {
    create?: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput> | EnrollmentCreateWithoutClassInput[] | EnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutClassInput | EnrollmentCreateOrConnectWithoutClassInput[]
    createMany?: EnrollmentCreateManyClassInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutClassInput = {
    create?: XOR<CommentCreateWithoutClassInput, CommentUncheckedCreateWithoutClassInput> | CommentCreateWithoutClassInput[] | CommentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutClassInput | CommentCreateOrConnectWithoutClassInput[]
    createMany?: CommentCreateManyClassInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<StudentCreateWithoutClassesInput, StudentUncheckedCreateWithoutClassesInput> | StudentCreateWithoutClassesInput[] | StudentUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassesInput | StudentCreateOrConnectWithoutClassesInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<TeamCreateWithoutClassInput, TeamUncheckedCreateWithoutClassInput> | TeamCreateWithoutClassInput[] | TeamUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutClassInput | TeamCreateOrConnectWithoutClassInput[]
    createMany?: TeamCreateManyClassInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput> | EnrollmentCreateWithoutClassInput[] | EnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutClassInput | EnrollmentCreateOrConnectWithoutClassInput[]
    createMany?: EnrollmentCreateManyClassInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<CommentCreateWithoutClassInput, CommentUncheckedCreateWithoutClassInput> | CommentCreateWithoutClassInput[] | CommentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutClassInput | CommentCreateOrConnectWithoutClassInput[]
    createMany?: CommentCreateManyClassInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<CourseCreateWithoutClassesInput, CourseUncheckedCreateWithoutClassesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutClassesInput
    upsert?: CourseUpsertWithoutClassesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutClassesInput, CourseUpdateWithoutClassesInput>, CourseUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherUpdateOneWithoutClassesNestedInput = {
    create?: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassesInput
    upsert?: TeacherUpsertWithoutClassesInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutClassesInput, TeacherUpdateWithoutClassesInput>, TeacherUncheckedUpdateWithoutClassesInput>
  }

  export type StudentUpdateManyWithoutClassesNestedInput = {
    create?: XOR<StudentCreateWithoutClassesInput, StudentUncheckedCreateWithoutClassesInput> | StudentCreateWithoutClassesInput[] | StudentUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassesInput | StudentCreateOrConnectWithoutClassesInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassesInput | StudentUpsertWithWhereUniqueWithoutClassesInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassesInput | StudentUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassesInput | StudentUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutClassNestedInput = {
    create?: XOR<TeamCreateWithoutClassInput, TeamUncheckedCreateWithoutClassInput> | TeamCreateWithoutClassInput[] | TeamUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutClassInput | TeamCreateOrConnectWithoutClassInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutClassInput | TeamUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TeamCreateManyClassInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutClassInput | TeamUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutClassInput | TeamUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutClassNestedInput = {
    create?: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput> | EnrollmentCreateWithoutClassInput[] | EnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutClassInput | EnrollmentCreateOrConnectWithoutClassInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutClassInput | EnrollmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: EnrollmentCreateManyClassInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutClassInput | EnrollmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutClassInput | EnrollmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutClassNestedInput = {
    create?: XOR<CommentCreateWithoutClassInput, CommentUncheckedCreateWithoutClassInput> | CommentCreateWithoutClassInput[] | CommentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutClassInput | CommentCreateOrConnectWithoutClassInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutClassInput | CommentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: CommentCreateManyClassInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutClassInput | CommentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutClassInput | CommentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<StudentCreateWithoutClassesInput, StudentUncheckedCreateWithoutClassesInput> | StudentCreateWithoutClassesInput[] | StudentUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassesInput | StudentCreateOrConnectWithoutClassesInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassesInput | StudentUpsertWithWhereUniqueWithoutClassesInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassesInput | StudentUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassesInput | StudentUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<TeamCreateWithoutClassInput, TeamUncheckedCreateWithoutClassInput> | TeamCreateWithoutClassInput[] | TeamUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutClassInput | TeamCreateOrConnectWithoutClassInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutClassInput | TeamUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TeamCreateManyClassInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutClassInput | TeamUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutClassInput | TeamUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput> | EnrollmentCreateWithoutClassInput[] | EnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutClassInput | EnrollmentCreateOrConnectWithoutClassInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutClassInput | EnrollmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: EnrollmentCreateManyClassInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutClassInput | EnrollmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutClassInput | EnrollmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<CommentCreateWithoutClassInput, CommentUncheckedCreateWithoutClassInput> | CommentCreateWithoutClassInput[] | CommentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutClassInput | CommentCreateOrConnectWithoutClassInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutClassInput | CommentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: CommentCreateManyClassInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutClassInput | CommentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutClassInput | CommentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type EnrollmentCreateNestedOneWithoutHolidaysInput = {
    create?: XOR<EnrollmentCreateWithoutHolidaysInput, EnrollmentUncheckedCreateWithoutHolidaysInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutHolidaysInput
    connect?: EnrollmentWhereUniqueInput
  }

  export type EnrollmentUpdateOneRequiredWithoutHolidaysNestedInput = {
    create?: XOR<EnrollmentCreateWithoutHolidaysInput, EnrollmentUncheckedCreateWithoutHolidaysInput>
    connectOrCreate?: EnrollmentCreateOrConnectWithoutHolidaysInput
    upsert?: EnrollmentUpsertWithoutHolidaysInput
    connect?: EnrollmentWhereUniqueInput
    update?: XOR<XOR<EnrollmentUpdateToOneWithWhereWithoutHolidaysInput, EnrollmentUpdateWithoutHolidaysInput>, EnrollmentUncheckedUpdateWithoutHolidaysInput>
  }

  export type LessonCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<LessonCreateWithoutSchedulesInput, LessonUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutSchedulesInput
    connect?: LessonWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutLessonsScheduleInput = {
    create?: XOR<TeacherCreateWithoutLessonsScheduleInput, TeacherUncheckedCreateWithoutLessonsScheduleInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutLessonsScheduleInput
    connect?: TeacherWhereUniqueInput
  }

  export type LessonUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<LessonCreateWithoutSchedulesInput, LessonUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutSchedulesInput
    upsert?: LessonUpsertWithoutSchedulesInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutSchedulesInput, LessonUpdateWithoutSchedulesInput>, LessonUncheckedUpdateWithoutSchedulesInput>
  }

  export type TeacherUpdateOneWithoutLessonsScheduleNestedInput = {
    create?: XOR<TeacherCreateWithoutLessonsScheduleInput, TeacherUncheckedCreateWithoutLessonsScheduleInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutLessonsScheduleInput
    upsert?: TeacherUpsertWithoutLessonsScheduleInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutLessonsScheduleInput, TeacherUpdateWithoutLessonsScheduleInput>, TeacherUncheckedUpdateWithoutLessonsScheduleInput>
  }

  export type CourseCreateNestedOneWithoutEventsInput = {
    create?: XOR<CourseCreateWithoutEventsInput, CourseUncheckedCreateWithoutEventsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEventsInput
    connect?: CourseWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutEventsInput = {
    create?: XOR<ModuleCreateWithoutEventsInput, ModuleUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutEventsInput
    connect?: ModuleWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutEventInput = {
    create?: XOR<CommentCreateWithoutEventInput, CommentUncheckedCreateWithoutEventInput> | CommentCreateWithoutEventInput[] | CommentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEventInput | CommentCreateOrConnectWithoutEventInput[]
    createMany?: CommentCreateManyEventInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TeacherCreateNestedOneWithoutEventsInput = {
    create?: XOR<TeacherCreateWithoutEventsInput, TeacherUncheckedCreateWithoutEventsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutEventsInput
    connect?: TeacherWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<CommentCreateWithoutEventInput, CommentUncheckedCreateWithoutEventInput> | CommentCreateWithoutEventInput[] | CommentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEventInput | CommentCreateOrConnectWithoutEventInput[]
    createMany?: CommentCreateManyEventInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumEventTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.EventTypeEnum
  }

  export type CourseUpdateOneWithoutEventsNestedInput = {
    create?: XOR<CourseCreateWithoutEventsInput, CourseUncheckedCreateWithoutEventsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEventsInput
    upsert?: CourseUpsertWithoutEventsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEventsInput, CourseUpdateWithoutEventsInput>, CourseUncheckedUpdateWithoutEventsInput>
  }

  export type ModuleUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ModuleCreateWithoutEventsInput, ModuleUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutEventsInput
    upsert?: ModuleUpsertWithoutEventsInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutEventsInput, ModuleUpdateWithoutEventsInput>, ModuleUncheckedUpdateWithoutEventsInput>
  }

  export type CommentUpdateManyWithoutEventNestedInput = {
    create?: XOR<CommentCreateWithoutEventInput, CommentUncheckedCreateWithoutEventInput> | CommentCreateWithoutEventInput[] | CommentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEventInput | CommentCreateOrConnectWithoutEventInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutEventInput | CommentUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: CommentCreateManyEventInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutEventInput | CommentUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutEventInput | CommentUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TeacherUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<TeacherCreateWithoutEventsInput, TeacherUncheckedCreateWithoutEventsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutEventsInput
    upsert?: TeacherUpsertWithoutEventsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutEventsInput, TeacherUpdateWithoutEventsInput>, TeacherUncheckedUpdateWithoutEventsInput>
  }

  export type CommentUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<CommentCreateWithoutEventInput, CommentUncheckedCreateWithoutEventInput> | CommentCreateWithoutEventInput[] | CommentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEventInput | CommentCreateOrConnectWithoutEventInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutEventInput | CommentUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: CommentCreateManyEventInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutEventInput | CommentUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutEventInput | CommentUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutTeamsInput = {
    create?: XOR<ClassCreateWithoutTeamsInput, ClassUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTeamsInput
    connect?: ClassWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutTeamsInput = {
    create?: XOR<StudentCreateWithoutTeamsInput, StudentUncheckedCreateWithoutTeamsInput> | StudentCreateWithoutTeamsInput[] | StudentUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutTeamsInput | StudentCreateOrConnectWithoutTeamsInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ExerciseCreateNestedManyWithoutTeamsInput = {
    create?: XOR<ExerciseCreateWithoutTeamsInput, ExerciseUncheckedCreateWithoutTeamsInput> | ExerciseCreateWithoutTeamsInput[] | ExerciseUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutTeamsInput | ExerciseCreateOrConnectWithoutTeamsInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTeamInput = {
    create?: XOR<CommentCreateWithoutTeamInput, CommentUncheckedCreateWithoutTeamInput> | CommentCreateWithoutTeamInput[] | CommentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTeamInput | CommentCreateOrConnectWithoutTeamInput[]
    createMany?: CommentCreateManyTeamInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TeacherCreateNestedOneWithoutTeamsInput = {
    create?: XOR<TeacherCreateWithoutTeamsInput, TeacherUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeamsInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedManyWithoutTeamsInput = {
    create?: XOR<StudentCreateWithoutTeamsInput, StudentUncheckedCreateWithoutTeamsInput> | StudentCreateWithoutTeamsInput[] | StudentUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutTeamsInput | StudentCreateOrConnectWithoutTeamsInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutTeamsInput = {
    create?: XOR<ExerciseCreateWithoutTeamsInput, ExerciseUncheckedCreateWithoutTeamsInput> | ExerciseCreateWithoutTeamsInput[] | ExerciseUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutTeamsInput | ExerciseCreateOrConnectWithoutTeamsInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<CommentCreateWithoutTeamInput, CommentUncheckedCreateWithoutTeamInput> | CommentCreateWithoutTeamInput[] | CommentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTeamInput | CommentCreateOrConnectWithoutTeamInput[]
    createMany?: CommentCreateManyTeamInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ClassUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<ClassCreateWithoutTeamsInput, ClassUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTeamsInput
    upsert?: ClassUpsertWithoutTeamsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutTeamsInput, ClassUpdateWithoutTeamsInput>, ClassUncheckedUpdateWithoutTeamsInput>
  }

  export type StudentUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<StudentCreateWithoutTeamsInput, StudentUncheckedCreateWithoutTeamsInput> | StudentCreateWithoutTeamsInput[] | StudentUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutTeamsInput | StudentCreateOrConnectWithoutTeamsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutTeamsInput | StudentUpsertWithWhereUniqueWithoutTeamsInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutTeamsInput | StudentUpdateWithWhereUniqueWithoutTeamsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutTeamsInput | StudentUpdateManyWithWhereWithoutTeamsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ExerciseUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<ExerciseCreateWithoutTeamsInput, ExerciseUncheckedCreateWithoutTeamsInput> | ExerciseCreateWithoutTeamsInput[] | ExerciseUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutTeamsInput | ExerciseCreateOrConnectWithoutTeamsInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutTeamsInput | ExerciseUpsertWithWhereUniqueWithoutTeamsInput[]
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutTeamsInput | ExerciseUpdateWithWhereUniqueWithoutTeamsInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutTeamsInput | ExerciseUpdateManyWithWhereWithoutTeamsInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CommentCreateWithoutTeamInput, CommentUncheckedCreateWithoutTeamInput> | CommentCreateWithoutTeamInput[] | CommentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTeamInput | CommentCreateOrConnectWithoutTeamInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTeamInput | CommentUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CommentCreateManyTeamInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTeamInput | CommentUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTeamInput | CommentUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TeacherUpdateOneWithoutTeamsNestedInput = {
    create?: XOR<TeacherCreateWithoutTeamsInput, TeacherUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeamsInput
    upsert?: TeacherUpsertWithoutTeamsInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutTeamsInput, TeacherUpdateWithoutTeamsInput>, TeacherUncheckedUpdateWithoutTeamsInput>
  }

  export type StudentUncheckedUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<StudentCreateWithoutTeamsInput, StudentUncheckedCreateWithoutTeamsInput> | StudentCreateWithoutTeamsInput[] | StudentUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutTeamsInput | StudentCreateOrConnectWithoutTeamsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutTeamsInput | StudentUpsertWithWhereUniqueWithoutTeamsInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutTeamsInput | StudentUpdateWithWhereUniqueWithoutTeamsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutTeamsInput | StudentUpdateManyWithWhereWithoutTeamsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<ExerciseCreateWithoutTeamsInput, ExerciseUncheckedCreateWithoutTeamsInput> | ExerciseCreateWithoutTeamsInput[] | ExerciseUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutTeamsInput | ExerciseCreateOrConnectWithoutTeamsInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutTeamsInput | ExerciseUpsertWithWhereUniqueWithoutTeamsInput[]
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutTeamsInput | ExerciseUpdateWithWhereUniqueWithoutTeamsInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutTeamsInput | ExerciseUpdateManyWithWhereWithoutTeamsInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CommentCreateWithoutTeamInput, CommentUncheckedCreateWithoutTeamInput> | CommentCreateWithoutTeamInput[] | CommentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTeamInput | CommentCreateOrConnectWithoutTeamInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTeamInput | CommentUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CommentCreateManyTeamInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTeamInput | CommentUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTeamInput | CommentUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TeacherCreateNestedOneWithoutCreatedClientsInput = {
    create?: XOR<TeacherCreateWithoutCreatedClientsInput, TeacherUncheckedCreateWithoutCreatedClientsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedClientsInput
    connect?: TeacherWhereUniqueInput
  }

  export type ExerciseCreateNestedManyWithoutClientInput = {
    create?: XOR<ExerciseCreateWithoutClientInput, ExerciseUncheckedCreateWithoutClientInput> | ExerciseCreateWithoutClientInput[] | ExerciseUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutClientInput | ExerciseCreateOrConnectWithoutClientInput[]
    createMany?: ExerciseCreateManyClientInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ExerciseCreateWithoutClientInput, ExerciseUncheckedCreateWithoutClientInput> | ExerciseCreateWithoutClientInput[] | ExerciseUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutClientInput | ExerciseCreateOrConnectWithoutClientInput[]
    createMany?: ExerciseCreateManyClientInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type TeacherUpdateOneRequiredWithoutCreatedClientsNestedInput = {
    create?: XOR<TeacherCreateWithoutCreatedClientsInput, TeacherUncheckedCreateWithoutCreatedClientsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedClientsInput
    upsert?: TeacherUpsertWithoutCreatedClientsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutCreatedClientsInput, TeacherUpdateWithoutCreatedClientsInput>, TeacherUncheckedUpdateWithoutCreatedClientsInput>
  }

  export type ExerciseUpdateManyWithoutClientNestedInput = {
    create?: XOR<ExerciseCreateWithoutClientInput, ExerciseUncheckedCreateWithoutClientInput> | ExerciseCreateWithoutClientInput[] | ExerciseUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutClientInput | ExerciseCreateOrConnectWithoutClientInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutClientInput | ExerciseUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ExerciseCreateManyClientInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutClientInput | ExerciseUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutClientInput | ExerciseUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ExerciseCreateWithoutClientInput, ExerciseUncheckedCreateWithoutClientInput> | ExerciseCreateWithoutClientInput[] | ExerciseUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutClientInput | ExerciseCreateOrConnectWithoutClientInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutClientInput | ExerciseUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ExerciseCreateManyClientInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutClientInput | ExerciseUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutClientInput | ExerciseUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type TeacherCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TeacherCreateWithoutNotificationsInput, TeacherUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutNotificationsInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNotificationsInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumNotificationTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.NotificationTypeEnum
  }

  export type TeacherUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<TeacherCreateWithoutNotificationsInput, TeacherUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutNotificationsInput
    upsert?: TeacherUpsertWithoutNotificationsInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutNotificationsInput, TeacherUpdateWithoutNotificationsInput>, TeacherUncheckedUpdateWithoutNotificationsInput>
  }

  export type StudentUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNotificationsInput
    upsert?: StudentUpsertWithoutNotificationsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutNotificationsInput, StudentUpdateWithoutNotificationsInput>, StudentUncheckedUpdateWithoutNotificationsInput>
  }

  export type CourseCreateNestedOneWithoutForSaleInput = {
    create?: XOR<CourseCreateWithoutForSaleInput, CourseUncheckedCreateWithoutForSaleInput>
    connectOrCreate?: CourseCreateOrConnectWithoutForSaleInput
    connect?: CourseWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutForSaleInput = {
    create?: XOR<ModuleCreateWithoutForSaleInput, ModuleUncheckedCreateWithoutForSaleInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutForSaleInput
    connect?: ModuleWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutForSaleInput = {
    create?: XOR<ExerciseCreateWithoutForSaleInput, ExerciseUncheckedCreateWithoutForSaleInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutForSaleInput
    connect?: ExerciseWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutForSaleInput = {
    create?: XOR<ExamCreateWithoutForSaleInput, ExamUncheckedCreateWithoutForSaleInput>
    connectOrCreate?: ExamCreateOrConnectWithoutForSaleInput
    connect?: ExamWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutForSaleInput = {
    create?: XOR<MaterialCreateWithoutForSaleInput, MaterialUncheckedCreateWithoutForSaleInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutForSaleInput
    connect?: MaterialWhereUniqueInput
  }

  export type PurchasedItemCreateNestedManyWithoutShopItemInput = {
    create?: XOR<PurchasedItemCreateWithoutShopItemInput, PurchasedItemUncheckedCreateWithoutShopItemInput> | PurchasedItemCreateWithoutShopItemInput[] | PurchasedItemUncheckedCreateWithoutShopItemInput[]
    connectOrCreate?: PurchasedItemCreateOrConnectWithoutShopItemInput | PurchasedItemCreateOrConnectWithoutShopItemInput[]
    createMany?: PurchasedItemCreateManyShopItemInputEnvelope
    connect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
  }

  export type PurchasedItemUncheckedCreateNestedManyWithoutShopItemInput = {
    create?: XOR<PurchasedItemCreateWithoutShopItemInput, PurchasedItemUncheckedCreateWithoutShopItemInput> | PurchasedItemCreateWithoutShopItemInput[] | PurchasedItemUncheckedCreateWithoutShopItemInput[]
    connectOrCreate?: PurchasedItemCreateOrConnectWithoutShopItemInput | PurchasedItemCreateOrConnectWithoutShopItemInput[]
    createMany?: PurchasedItemCreateManyShopItemInputEnvelope
    connect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
  }

  export type EnumShopItemTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.ShopItemTypeEnum
  }

  export type CourseUpdateOneWithoutForSaleNestedInput = {
    create?: XOR<CourseCreateWithoutForSaleInput, CourseUncheckedCreateWithoutForSaleInput>
    connectOrCreate?: CourseCreateOrConnectWithoutForSaleInput
    upsert?: CourseUpsertWithoutForSaleInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutForSaleInput, CourseUpdateWithoutForSaleInput>, CourseUncheckedUpdateWithoutForSaleInput>
  }

  export type ModuleUpdateOneWithoutForSaleNestedInput = {
    create?: XOR<ModuleCreateWithoutForSaleInput, ModuleUncheckedCreateWithoutForSaleInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutForSaleInput
    upsert?: ModuleUpsertWithoutForSaleInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutForSaleInput, ModuleUpdateWithoutForSaleInput>, ModuleUncheckedUpdateWithoutForSaleInput>
  }

  export type ExerciseUpdateOneWithoutForSaleNestedInput = {
    create?: XOR<ExerciseCreateWithoutForSaleInput, ExerciseUncheckedCreateWithoutForSaleInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutForSaleInput
    upsert?: ExerciseUpsertWithoutForSaleInput
    disconnect?: ExerciseWhereInput | boolean
    delete?: ExerciseWhereInput | boolean
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutForSaleInput, ExerciseUpdateWithoutForSaleInput>, ExerciseUncheckedUpdateWithoutForSaleInput>
  }

  export type ExamUpdateOneWithoutForSaleNestedInput = {
    create?: XOR<ExamCreateWithoutForSaleInput, ExamUncheckedCreateWithoutForSaleInput>
    connectOrCreate?: ExamCreateOrConnectWithoutForSaleInput
    upsert?: ExamUpsertWithoutForSaleInput
    disconnect?: ExamWhereInput | boolean
    delete?: ExamWhereInput | boolean
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutForSaleInput, ExamUpdateWithoutForSaleInput>, ExamUncheckedUpdateWithoutForSaleInput>
  }

  export type MaterialUpdateOneWithoutForSaleNestedInput = {
    create?: XOR<MaterialCreateWithoutForSaleInput, MaterialUncheckedCreateWithoutForSaleInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutForSaleInput
    upsert?: MaterialUpsertWithoutForSaleInput
    disconnect?: MaterialWhereInput | boolean
    delete?: MaterialWhereInput | boolean
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutForSaleInput, MaterialUpdateWithoutForSaleInput>, MaterialUncheckedUpdateWithoutForSaleInput>
  }

  export type PurchasedItemUpdateManyWithoutShopItemNestedInput = {
    create?: XOR<PurchasedItemCreateWithoutShopItemInput, PurchasedItemUncheckedCreateWithoutShopItemInput> | PurchasedItemCreateWithoutShopItemInput[] | PurchasedItemUncheckedCreateWithoutShopItemInput[]
    connectOrCreate?: PurchasedItemCreateOrConnectWithoutShopItemInput | PurchasedItemCreateOrConnectWithoutShopItemInput[]
    upsert?: PurchasedItemUpsertWithWhereUniqueWithoutShopItemInput | PurchasedItemUpsertWithWhereUniqueWithoutShopItemInput[]
    createMany?: PurchasedItemCreateManyShopItemInputEnvelope
    set?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    disconnect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    delete?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    connect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    update?: PurchasedItemUpdateWithWhereUniqueWithoutShopItemInput | PurchasedItemUpdateWithWhereUniqueWithoutShopItemInput[]
    updateMany?: PurchasedItemUpdateManyWithWhereWithoutShopItemInput | PurchasedItemUpdateManyWithWhereWithoutShopItemInput[]
    deleteMany?: PurchasedItemScalarWhereInput | PurchasedItemScalarWhereInput[]
  }

  export type PurchasedItemUncheckedUpdateManyWithoutShopItemNestedInput = {
    create?: XOR<PurchasedItemCreateWithoutShopItemInput, PurchasedItemUncheckedCreateWithoutShopItemInput> | PurchasedItemCreateWithoutShopItemInput[] | PurchasedItemUncheckedCreateWithoutShopItemInput[]
    connectOrCreate?: PurchasedItemCreateOrConnectWithoutShopItemInput | PurchasedItemCreateOrConnectWithoutShopItemInput[]
    upsert?: PurchasedItemUpsertWithWhereUniqueWithoutShopItemInput | PurchasedItemUpsertWithWhereUniqueWithoutShopItemInput[]
    createMany?: PurchasedItemCreateManyShopItemInputEnvelope
    set?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    disconnect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    delete?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    connect?: PurchasedItemWhereUniqueInput | PurchasedItemWhereUniqueInput[]
    update?: PurchasedItemUpdateWithWhereUniqueWithoutShopItemInput | PurchasedItemUpdateWithWhereUniqueWithoutShopItemInput[]
    updateMany?: PurchasedItemUpdateManyWithWhereWithoutShopItemInput | PurchasedItemUpdateManyWithWhereWithoutShopItemInput[]
    deleteMany?: PurchasedItemScalarWhereInput | PurchasedItemScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutForRentInput = {
    create?: XOR<CourseCreateWithoutForRentInput, CourseUncheckedCreateWithoutForRentInput>
    connectOrCreate?: CourseCreateOrConnectWithoutForRentInput
    connect?: CourseWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutForRentInput = {
    create?: XOR<ModuleCreateWithoutForRentInput, ModuleUncheckedCreateWithoutForRentInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutForRentInput
    connect?: ModuleWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutForRentInput = {
    create?: XOR<ExerciseCreateWithoutForRentInput, ExerciseUncheckedCreateWithoutForRentInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutForRentInput
    connect?: ExerciseWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutForRentInput = {
    create?: XOR<ExamCreateWithoutForRentInput, ExamUncheckedCreateWithoutForRentInput>
    connectOrCreate?: ExamCreateOrConnectWithoutForRentInput
    connect?: ExamWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutForRentInput = {
    create?: XOR<MaterialCreateWithoutForRentInput, MaterialUncheckedCreateWithoutForRentInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutForRentInput
    connect?: MaterialWhereUniqueInput
  }

  export type RentalPeriodCreateNestedManyWithoutShopItemInput = {
    create?: XOR<RentalPeriodCreateWithoutShopItemInput, RentalPeriodUncheckedCreateWithoutShopItemInput> | RentalPeriodCreateWithoutShopItemInput[] | RentalPeriodUncheckedCreateWithoutShopItemInput[]
    connectOrCreate?: RentalPeriodCreateOrConnectWithoutShopItemInput | RentalPeriodCreateOrConnectWithoutShopItemInput[]
    createMany?: RentalPeriodCreateManyShopItemInputEnvelope
    connect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
  }

  export type RentalPeriodUncheckedCreateNestedManyWithoutShopItemInput = {
    create?: XOR<RentalPeriodCreateWithoutShopItemInput, RentalPeriodUncheckedCreateWithoutShopItemInput> | RentalPeriodCreateWithoutShopItemInput[] | RentalPeriodUncheckedCreateWithoutShopItemInput[]
    connectOrCreate?: RentalPeriodCreateOrConnectWithoutShopItemInput | RentalPeriodCreateOrConnectWithoutShopItemInput[]
    createMany?: RentalPeriodCreateManyShopItemInputEnvelope
    connect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
  }

  export type CourseUpdateOneWithoutForRentNestedInput = {
    create?: XOR<CourseCreateWithoutForRentInput, CourseUncheckedCreateWithoutForRentInput>
    connectOrCreate?: CourseCreateOrConnectWithoutForRentInput
    upsert?: CourseUpsertWithoutForRentInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutForRentInput, CourseUpdateWithoutForRentInput>, CourseUncheckedUpdateWithoutForRentInput>
  }

  export type ModuleUpdateOneWithoutForRentNestedInput = {
    create?: XOR<ModuleCreateWithoutForRentInput, ModuleUncheckedCreateWithoutForRentInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutForRentInput
    upsert?: ModuleUpsertWithoutForRentInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutForRentInput, ModuleUpdateWithoutForRentInput>, ModuleUncheckedUpdateWithoutForRentInput>
  }

  export type ExerciseUpdateOneWithoutForRentNestedInput = {
    create?: XOR<ExerciseCreateWithoutForRentInput, ExerciseUncheckedCreateWithoutForRentInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutForRentInput
    upsert?: ExerciseUpsertWithoutForRentInput
    disconnect?: ExerciseWhereInput | boolean
    delete?: ExerciseWhereInput | boolean
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutForRentInput, ExerciseUpdateWithoutForRentInput>, ExerciseUncheckedUpdateWithoutForRentInput>
  }

  export type ExamUpdateOneWithoutForRentNestedInput = {
    create?: XOR<ExamCreateWithoutForRentInput, ExamUncheckedCreateWithoutForRentInput>
    connectOrCreate?: ExamCreateOrConnectWithoutForRentInput
    upsert?: ExamUpsertWithoutForRentInput
    disconnect?: ExamWhereInput | boolean
    delete?: ExamWhereInput | boolean
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutForRentInput, ExamUpdateWithoutForRentInput>, ExamUncheckedUpdateWithoutForRentInput>
  }

  export type MaterialUpdateOneWithoutForRentNestedInput = {
    create?: XOR<MaterialCreateWithoutForRentInput, MaterialUncheckedCreateWithoutForRentInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutForRentInput
    upsert?: MaterialUpsertWithoutForRentInput
    disconnect?: MaterialWhereInput | boolean
    delete?: MaterialWhereInput | boolean
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutForRentInput, MaterialUpdateWithoutForRentInput>, MaterialUncheckedUpdateWithoutForRentInput>
  }

  export type RentalPeriodUpdateManyWithoutShopItemNestedInput = {
    create?: XOR<RentalPeriodCreateWithoutShopItemInput, RentalPeriodUncheckedCreateWithoutShopItemInput> | RentalPeriodCreateWithoutShopItemInput[] | RentalPeriodUncheckedCreateWithoutShopItemInput[]
    connectOrCreate?: RentalPeriodCreateOrConnectWithoutShopItemInput | RentalPeriodCreateOrConnectWithoutShopItemInput[]
    upsert?: RentalPeriodUpsertWithWhereUniqueWithoutShopItemInput | RentalPeriodUpsertWithWhereUniqueWithoutShopItemInput[]
    createMany?: RentalPeriodCreateManyShopItemInputEnvelope
    set?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    disconnect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    delete?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    connect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    update?: RentalPeriodUpdateWithWhereUniqueWithoutShopItemInput | RentalPeriodUpdateWithWhereUniqueWithoutShopItemInput[]
    updateMany?: RentalPeriodUpdateManyWithWhereWithoutShopItemInput | RentalPeriodUpdateManyWithWhereWithoutShopItemInput[]
    deleteMany?: RentalPeriodScalarWhereInput | RentalPeriodScalarWhereInput[]
  }

  export type RentalPeriodUncheckedUpdateManyWithoutShopItemNestedInput = {
    create?: XOR<RentalPeriodCreateWithoutShopItemInput, RentalPeriodUncheckedCreateWithoutShopItemInput> | RentalPeriodCreateWithoutShopItemInput[] | RentalPeriodUncheckedCreateWithoutShopItemInput[]
    connectOrCreate?: RentalPeriodCreateOrConnectWithoutShopItemInput | RentalPeriodCreateOrConnectWithoutShopItemInput[]
    upsert?: RentalPeriodUpsertWithWhereUniqueWithoutShopItemInput | RentalPeriodUpsertWithWhereUniqueWithoutShopItemInput[]
    createMany?: RentalPeriodCreateManyShopItemInputEnvelope
    set?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    disconnect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    delete?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    connect?: RentalPeriodWhereUniqueInput | RentalPeriodWhereUniqueInput[]
    update?: RentalPeriodUpdateWithWhereUniqueWithoutShopItemInput | RentalPeriodUpdateWithWhereUniqueWithoutShopItemInput[]
    updateMany?: RentalPeriodUpdateManyWithWhereWithoutShopItemInput | RentalPeriodUpdateManyWithWhereWithoutShopItemInput[]
    deleteMany?: RentalPeriodScalarWhereInput | RentalPeriodScalarWhereInput[]
  }

  export type TeacherCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<TeacherCreateWithoutPurchasesInput, TeacherUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutPurchasesInput
    connect?: TeacherWhereUniqueInput
  }

  export type ShopItemForSaleCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<ShopItemForSaleCreateWithoutPurchasesInput, ShopItemForSaleUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutPurchasesInput
    connect?: ShopItemForSaleWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<TeacherCreateWithoutPurchasesInput, TeacherUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutPurchasesInput
    upsert?: TeacherUpsertWithoutPurchasesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutPurchasesInput, TeacherUpdateWithoutPurchasesInput>, TeacherUncheckedUpdateWithoutPurchasesInput>
  }

  export type ShopItemForSaleUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<ShopItemForSaleCreateWithoutPurchasesInput, ShopItemForSaleUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ShopItemForSaleCreateOrConnectWithoutPurchasesInput
    upsert?: ShopItemForSaleUpsertWithoutPurchasesInput
    connect?: ShopItemForSaleWhereUniqueInput
    update?: XOR<XOR<ShopItemForSaleUpdateToOneWithWhereWithoutPurchasesInput, ShopItemForSaleUpdateWithoutPurchasesInput>, ShopItemForSaleUncheckedUpdateWithoutPurchasesInput>
  }

  export type TeacherCreateNestedOneWithoutRentalPeriodsInput = {
    create?: XOR<TeacherCreateWithoutRentalPeriodsInput, TeacherUncheckedCreateWithoutRentalPeriodsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutRentalPeriodsInput
    connect?: TeacherWhereUniqueInput
  }

  export type ShopItemForRentCreateNestedOneWithoutRentalPeriodsInput = {
    create?: XOR<ShopItemForRentCreateWithoutRentalPeriodsInput, ShopItemForRentUncheckedCreateWithoutRentalPeriodsInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutRentalPeriodsInput
    connect?: ShopItemForRentWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutRentalPeriodsNestedInput = {
    create?: XOR<TeacherCreateWithoutRentalPeriodsInput, TeacherUncheckedCreateWithoutRentalPeriodsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutRentalPeriodsInput
    upsert?: TeacherUpsertWithoutRentalPeriodsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutRentalPeriodsInput, TeacherUpdateWithoutRentalPeriodsInput>, TeacherUncheckedUpdateWithoutRentalPeriodsInput>
  }

  export type ShopItemForRentUpdateOneRequiredWithoutRentalPeriodsNestedInput = {
    create?: XOR<ShopItemForRentCreateWithoutRentalPeriodsInput, ShopItemForRentUncheckedCreateWithoutRentalPeriodsInput>
    connectOrCreate?: ShopItemForRentCreateOrConnectWithoutRentalPeriodsInput
    upsert?: ShopItemForRentUpsertWithoutRentalPeriodsInput
    connect?: ShopItemForRentWhereUniqueInput
    update?: XOR<XOR<ShopItemForRentUpdateToOneWithWhereWithoutRentalPeriodsInput, ShopItemForRentUpdateWithoutRentalPeriodsInput>, ShopItemForRentUncheckedUpdateWithoutRentalPeriodsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCourseStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatusEnum | EnumCourseStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatusEnum[] | ListEnumCourseStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatusEnum[] | ListEnumCourseStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusEnumFilter<$PrismaModel> | $Enums.CourseStatusEnum
  }

  export type NestedEnumPublishStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatusEnum | EnumPublishStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatusEnum[] | ListEnumPublishStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatusEnum[] | ListEnumPublishStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusEnumFilter<$PrismaModel> | $Enums.PublishStatusEnum
  }

  export type NestedEnumCourseStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatusEnum | EnumCourseStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatusEnum[] | ListEnumCourseStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatusEnum[] | ListEnumCourseStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusEnumFilter<$PrismaModel>
  }

  export type NestedEnumPublishStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatusEnum | EnumPublishStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatusEnum[] | ListEnumPublishStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatusEnum[] | ListEnumPublishStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.PublishStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublishStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumPublishStatusEnumFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyTypeEnum | EnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyTypeEnum[] | ListEnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyTypeEnum[] | ListEnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyTypeEnumFilter<$PrismaModel> | $Enums.CurrencyTypeEnum
  }

  export type NestedEnumCurrencyTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyTypeEnum | EnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyTypeEnum[] | ListEnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyTypeEnum[] | ListEnumCurrencyTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumCurrencyTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumExerciseTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseTypeEnum | EnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseTypeEnum[] | ListEnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseTypeEnum[] | ListEnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeEnumFilter<$PrismaModel> | $Enums.ExerciseTypeEnum
  }

  export type NestedEnumDifficultyLevelEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevelEnum | EnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevelEnum[] | ListEnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevelEnum[] | ListEnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelEnumFilter<$PrismaModel> | $Enums.DifficultyLevelEnum
  }

  export type NestedEnumExerciseTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseTypeEnum | EnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseTypeEnum[] | ListEnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseTypeEnum[] | ListEnumExerciseTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumExerciseTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumDifficultyLevelEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevelEnum | EnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevelEnum[] | ListEnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevelEnum[] | ListEnumDifficultyLevelEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelEnumWithAggregatesFilter<$PrismaModel> | $Enums.DifficultyLevelEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyLevelEnumFilter<$PrismaModel>
    _max?: NestedEnumDifficultyLevelEnumFilter<$PrismaModel>
  }

  export type NestedEnumExamTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamTypeEnum | EnumExamTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ExamTypeEnum[] | ListEnumExamTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamTypeEnum[] | ListEnumExamTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumExamTypeEnumFilter<$PrismaModel> | $Enums.ExamTypeEnum
  }

  export type NestedEnumExamTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamTypeEnum | EnumExamTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ExamTypeEnum[] | ListEnumExamTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamTypeEnum[] | ListEnumExamTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumExamTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.ExamTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumExamTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumMaterialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialType | EnumMaterialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialTypeFilter<$PrismaModel> | $Enums.MaterialType
  }

  export type NestedEnumMaterialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialType | EnumMaterialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialType[] | ListEnumMaterialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaterialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialTypeFilter<$PrismaModel>
    _max?: NestedEnumMaterialTypeFilter<$PrismaModel>
  }

  export type NestedEnumEnrollmentStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatusEnum | EnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatusEnum[] | ListEnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatusEnum[] | ListEnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusEnumFilter<$PrismaModel> | $Enums.EnrollmentStatusEnum
  }

  export type NestedEnumEnrollmentStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatusEnum | EnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatusEnum[] | ListEnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatusEnum[] | ListEnumEnrollmentStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.EnrollmentStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnrollmentStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumEnrollmentStatusEnumFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.EventTypeEnum | EnumEventTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EventTypeEnum[] | ListEnumEventTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventTypeEnum[] | ListEnumEventTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeEnumFilter<$PrismaModel> | $Enums.EventTypeEnum
  }

  export type NestedEnumEventTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventTypeEnum | EnumEventTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EventTypeEnum[] | ListEnumEventTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventTypeEnum[] | ListEnumEventTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.EventTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumEventTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTypeEnum | EnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTypeEnum[] | ListEnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationTypeEnum[] | ListEnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeEnumFilter<$PrismaModel> | $Enums.NotificationTypeEnum
  }

  export type NestedEnumNotificationTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTypeEnum | EnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTypeEnum[] | ListEnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationTypeEnum[] | ListEnumNotificationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.NotificationTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumShopItemTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopItemTypeEnum | EnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ShopItemTypeEnum[] | ListEnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopItemTypeEnum[] | ListEnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumShopItemTypeEnumFilter<$PrismaModel> | $Enums.ShopItemTypeEnum
  }

  export type NestedEnumShopItemTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopItemTypeEnum | EnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ShopItemTypeEnum[] | ListEnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopItemTypeEnum[] | ListEnumShopItemTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumShopItemTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.ShopItemTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShopItemTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumShopItemTypeEnumFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    displayName?: string | null
    bio?: string | null
    birthDate?: Date | string | null
    phoneNumber?: string | null
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutUserInput = {
    id?: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutStudentsInput
    teams?: TeamCreateNestedManyWithoutStudentsInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
    comments?: CommentCreateNestedManyWithoutStudentInput
    addedBy: TeacherCreateNestedOneWithoutAddedStudentsInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedById: string
    classes?: ClassUncheckedCreateNestedManyWithoutStudentsInput
    teams?: TeamUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
    comments?: CommentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    oauth_token_secret?: StringNullableFilter<"Account"> | string | null
    oauth_token?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    courseId?: StringNullableFilter<"Comment"> | string | null
    moduleId?: StringNullableFilter<"Comment"> | string | null
    topicId?: StringNullableFilter<"Comment"> | string | null
    materialId?: StringNullableFilter<"Comment"> | string | null
    enrollmentId?: StringNullableFilter<"Comment"> | string | null
    classId?: StringNullableFilter<"Comment"> | string | null
    teamId?: StringNullableFilter<"Comment"> | string | null
    eventId?: StringNullableFilter<"Comment"> | string | null
    lessonId?: StringNullableFilter<"Comment"> | string | null
    examId?: StringNullableFilter<"Comment"> | string | null
    exerciseId?: StringNullableFilter<"Comment"> | string | null
    studentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type TeacherUpsertWithoutUserInput = {
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutUserInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutStudentsNestedInput
    teams?: TeamUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
    comments?: CommentUpdateManyWithoutStudentNestedInput
    addedBy?: TeacherUpdateOneRequiredWithoutAddedStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: StringFieldUpdateOperationsInput | string
    classes?: ClassUncheckedUpdateManyWithoutStudentsNestedInput
    teams?: TeamUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutTeacherInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeacherInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
  }

  export type ModuleAssignmentCreateWithoutTeacherInput = {
    id?: string
    courseId: string
    hourlyRate: number
    currency?: $Enums.CurrencyTypeEnum
    startDate: Date | string
    endDate: Date | string
    module: ModuleCreateNestedOneWithoutAssignmentsInput
  }

  export type ModuleAssignmentUncheckedCreateWithoutTeacherInput = {
    id?: string
    moduleId: string
    courseId: string
    hourlyRate: number
    currency?: $Enums.CurrencyTypeEnum
    startDate: Date | string
    endDate: Date | string
  }

  export type ModuleAssignmentCreateOrConnectWithoutTeacherInput = {
    where: ModuleAssignmentWhereUniqueInput
    create: XOR<ModuleAssignmentCreateWithoutTeacherInput, ModuleAssignmentUncheckedCreateWithoutTeacherInput>
  }

  export type ModuleAssignmentCreateManyTeacherInputEnvelope = {
    data: ModuleAssignmentCreateManyTeacherInput | ModuleAssignmentCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutCreatorInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    owner: TeacherCreateNestedOneWithoutOwnedCoursesInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    materials?: MaterialCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    events?: EventCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutCourseInput
    comments?: CommentCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCreatorInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    materials?: MaterialUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    events?: EventUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutCourseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseCreateManyCreatorInputEnvelope = {
    data: CourseCreateManyCreatorInput | CourseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutOwnerInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedCoursesInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    materials?: MaterialCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    events?: EventCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutCourseInput
    comments?: CommentCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutOwnerInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    publishStatus?: $Enums.PublishStatusEnum
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    materials?: MaterialUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    events?: EventUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutCourseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutOwnerInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutOwnerInput, CourseUncheckedCreateWithoutOwnerInput>
  }

  export type CourseCreateManyOwnerInputEnvelope = {
    data: CourseCreateManyOwnerInput | CourseCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutCreatorInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCreatorInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCreatorInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCreatorInput, ModuleUncheckedCreateWithoutCreatorInput>
  }

  export type ModuleCreateManyCreatorInputEnvelope = {
    data: ModuleCreateManyCreatorInput | ModuleCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutOwnerInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutOwnerInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutOwnerInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutOwnerInput, ModuleUncheckedCreateWithoutOwnerInput>
  }

  export type ModuleCreateManyOwnerInputEnvelope = {
    data: ModuleCreateManyOwnerInput | ModuleCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    topic?: TopicCreateNestedOneWithoutExercisesInput
    examExercises?: ExamExerciseCreateNestedManyWithoutExerciseInput
    owner: TeacherCreateNestedOneWithoutOwnedExercisesInput
    teams?: TeamCreateNestedManyWithoutExercisesInput
    client?: ClientCreateNestedOneWithoutExercisesInput
    comments?: CommentCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedCreateNestedManyWithoutExerciseInput
    teams?: TeamUncheckedCreateNestedManyWithoutExercisesInput
    comments?: CommentUncheckedCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutCreatorInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput>
  }

  export type ExerciseCreateManyCreatorInputEnvelope = {
    data: ExerciseCreateManyCreatorInput | ExerciseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    topic?: TopicCreateNestedOneWithoutExercisesInput
    examExercises?: ExamExerciseCreateNestedManyWithoutExerciseInput
    creator: TeacherCreateNestedOneWithoutCreatedExercisesInput
    teams?: TeamCreateNestedManyWithoutExercisesInput
    client?: ClientCreateNestedOneWithoutExercisesInput
    comments?: CommentCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedCreateNestedManyWithoutExerciseInput
    teams?: TeamUncheckedCreateNestedManyWithoutExercisesInput
    comments?: CommentUncheckedCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutOwnerInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput>
  }

  export type ExerciseCreateManyOwnerInputEnvelope = {
    data: ExerciseCreateManyOwnerInput | ExerciseCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    date: Date | string
    duration: number
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    module: ModuleCreateNestedOneWithoutExamsInput
    exercises?: ExamExerciseCreateNestedManyWithoutExamInput
    owner: TeacherCreateNestedOneWithoutOwnedExamsInput
    comments?: CommentCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date | string
    duration: number
    maxScore: number
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedCreateNestedManyWithoutExamInput
    comments?: CommentUncheckedCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutCreatorInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput>
  }

  export type ExamCreateManyCreatorInputEnvelope = {
    data: ExamCreateManyCreatorInput | ExamCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    date: Date | string
    duration: number
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    module: ModuleCreateNestedOneWithoutExamsInput
    exercises?: ExamExerciseCreateNestedManyWithoutExamInput
    creator: TeacherCreateNestedOneWithoutCreatedExamsInput
    comments?: CommentCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date | string
    duration: number
    maxScore: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedCreateNestedManyWithoutExamInput
    comments?: CommentUncheckedCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutOwnerInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutOwnerInput, ExamUncheckedCreateWithoutOwnerInput>
  }

  export type ExamCreateManyOwnerInputEnvelope = {
    data: ExamCreateManyOwnerInput | ExamCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: ExerciseCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCreatorInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCreatorInput, ClientUncheckedCreateWithoutCreatorInput>
  }

  export type ClientCreateManyCreatorInputEnvelope = {
    data: ClientCreateManyCreatorInput | ClientCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutEventsInput
    module?: ModuleCreateNestedOneWithoutEventsInput
    comments?: CommentCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    courseId?: string | null
    moduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCreatorInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput>
  }

  export type EventCreateManyCreatorInputEnvelope = {
    data: EventCreateManyCreatorInput | EventCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutTeacherInput = {
    id?: string
    title?: string | null
    message?: string | null
    type: $Enums.NotificationTypeEnum
    seen?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTeacherInput = {
    id?: string
    title?: string | null
    message?: string | null
    type: $Enums.NotificationTypeEnum
    studentId?: string | null
    seen?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTeacherInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTeacherInput, NotificationUncheckedCreateWithoutTeacherInput>
  }

  export type NotificationCreateManyTeacherInputEnvelope = {
    data: NotificationCreateManyTeacherInput | NotificationCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type PurchasedItemCreateWithoutTeacherInput = {
    id?: string
    purchaseDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    shopItem: ShopItemForSaleCreateNestedOneWithoutPurchasesInput
  }

  export type PurchasedItemUncheckedCreateWithoutTeacherInput = {
    id?: string
    shopItemId: string
    purchaseDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasedItemCreateOrConnectWithoutTeacherInput = {
    where: PurchasedItemWhereUniqueInput
    create: XOR<PurchasedItemCreateWithoutTeacherInput, PurchasedItemUncheckedCreateWithoutTeacherInput>
  }

  export type PurchasedItemCreateManyTeacherInputEnvelope = {
    data: PurchasedItemCreateManyTeacherInput | PurchasedItemCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type RentalPeriodCreateWithoutTeacherInput = {
    id?: string
    rentStartDate: Date | string
    rentEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    shopItem: ShopItemForRentCreateNestedOneWithoutRentalPeriodsInput
  }

  export type RentalPeriodUncheckedCreateWithoutTeacherInput = {
    id?: string
    shopItemId: string
    rentStartDate: Date | string
    rentEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type RentalPeriodCreateOrConnectWithoutTeacherInput = {
    where: RentalPeriodWhereUniqueInput
    create: XOR<RentalPeriodCreateWithoutTeacherInput, RentalPeriodUncheckedCreateWithoutTeacherInput>
  }

  export type RentalPeriodCreateManyTeacherInputEnvelope = {
    data: RentalPeriodCreateManyTeacherInput | RentalPeriodCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    course?: CourseCreateNestedOneWithoutMaterialsInput
    module?: ModuleCreateNestedOneWithoutMaterialsInput
    topic?: TopicCreateNestedOneWithoutMaterialsInput
    comments?: CommentCreateNestedManyWithoutMaterialInput
    owner: TeacherCreateNestedOneWithoutOwnedMaterialInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    comments?: CommentUncheckedCreateNestedManyWithoutMaterialInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutCreatorInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutCreatorInput, MaterialUncheckedCreateWithoutCreatorInput>
  }

  export type MaterialCreateManyCreatorInputEnvelope = {
    data: MaterialCreateManyCreatorInput | MaterialCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    course?: CourseCreateNestedOneWithoutMaterialsInput
    module?: ModuleCreateNestedOneWithoutMaterialsInput
    topic?: TopicCreateNestedOneWithoutMaterialsInput
    comments?: CommentCreateNestedManyWithoutMaterialInput
    creator: TeacherCreateNestedOneWithoutCreatedMaterialInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    publishStatus?: $Enums.PublishStatusEnum
    comments?: CommentUncheckedCreateNestedManyWithoutMaterialInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutOwnerInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutOwnerInput, MaterialUncheckedCreateWithoutOwnerInput>
  }

  export type MaterialCreateManyOwnerInputEnvelope = {
    data: MaterialCreateManyOwnerInput | MaterialCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutAddedByInput = {
    id?: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    classes?: ClassCreateNestedManyWithoutStudentsInput
    teams?: TeamCreateNestedManyWithoutStudentsInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
    comments?: CommentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAddedByInput = {
    id?: string
    userId: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutStudentsInput
    teams?: TeamUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
    comments?: CommentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAddedByInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAddedByInput, StudentUncheckedCreateWithoutAddedByInput>
  }

  export type StudentCreateManyAddedByInputEnvelope = {
    data: StudentCreateManyAddedByInput | StudentCreateManyAddedByInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutTeacherInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassesInput
    teams?: TeamCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    comments?: CommentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTeacherInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    courseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassesInput
    teams?: TeamUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    comments?: CommentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTeacherInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput>
  }

  export type ClassCreateManyTeacherInputEnvelope = {
    data: ClassCreateManyTeacherInput | ClassCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type LessonScheduleCreateWithoutTeacherInput = {
    id?: string
    dateTime: Date | string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutSchedulesInput
  }

  export type LessonScheduleUncheckedCreateWithoutTeacherInput = {
    id?: string
    lessonId: string
    dateTime: Date | string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonScheduleCreateOrConnectWithoutTeacherInput = {
    where: LessonScheduleWhereUniqueInput
    create: XOR<LessonScheduleCreateWithoutTeacherInput, LessonScheduleUncheckedCreateWithoutTeacherInput>
  }

  export type LessonScheduleCreateManyTeacherInputEnvelope = {
    data: LessonScheduleCreateManyTeacherInput | LessonScheduleCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutTeacherInput = {
    id?: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    class: ClassCreateNestedOneWithoutEnrollmentsInput
    holidays?: HolidayCreateNestedManyWithoutEnrollmentInput
    comments?: CommentCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutTeacherInput = {
    id?: string
    courseId: string
    classId: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holidays?: HolidayUncheckedCreateNestedManyWithoutEnrollmentInput
    comments?: CommentUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutTeacherInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutTeacherInput, EnrollmentUncheckedCreateWithoutTeacherInput>
  }

  export type EnrollmentCreateManyTeacherInputEnvelope = {
    data: EnrollmentCreateManyTeacherInput | EnrollmentCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutTeacherInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTeamsInput
    students?: StudentCreateNestedManyWithoutTeamsInput
    exercises?: ExerciseCreateNestedManyWithoutTeamsInput
    comments?: CommentCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeacherInput = {
    id?: string
    name: string
    description?: string | null
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutTeamsInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutTeamsInput
    comments?: CommentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeacherInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeacherInput, TeamUncheckedCreateWithoutTeacherInput>
  }

  export type TeamCreateManyTeacherInputEnvelope = {
    data: TeamCreateManyTeacherInput | TeamCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTeacherInput = {
    update: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type UserUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ModuleAssignmentUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ModuleAssignmentWhereUniqueInput
    update: XOR<ModuleAssignmentUpdateWithoutTeacherInput, ModuleAssignmentUncheckedUpdateWithoutTeacherInput>
    create: XOR<ModuleAssignmentCreateWithoutTeacherInput, ModuleAssignmentUncheckedCreateWithoutTeacherInput>
  }

  export type ModuleAssignmentUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ModuleAssignmentWhereUniqueInput
    data: XOR<ModuleAssignmentUpdateWithoutTeacherInput, ModuleAssignmentUncheckedUpdateWithoutTeacherInput>
  }

  export type ModuleAssignmentUpdateManyWithWhereWithoutTeacherInput = {
    where: ModuleAssignmentScalarWhereInput
    data: XOR<ModuleAssignmentUpdateManyMutationInput, ModuleAssignmentUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ModuleAssignmentScalarWhereInput = {
    AND?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
    OR?: ModuleAssignmentScalarWhereInput[]
    NOT?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
    id?: StringFilter<"ModuleAssignment"> | string
    moduleId?: StringFilter<"ModuleAssignment"> | string
    teacherId?: StringFilter<"ModuleAssignment"> | string
    courseId?: StringFilter<"ModuleAssignment"> | string
    hourlyRate?: IntFilter<"ModuleAssignment"> | number
    currency?: EnumCurrencyTypeEnumFilter<"ModuleAssignment"> | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFilter<"ModuleAssignment"> | Date | string
    endDate?: DateTimeFilter<"ModuleAssignment"> | Date | string
  }

  export type CourseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
  }

  export type CourseUpdateManyWithWhereWithoutCreatorInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    slug?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    category?: StringFilter<"Course"> | string
    status?: EnumCourseStatusEnumFilter<"Course"> | $Enums.CourseStatusEnum
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    creatorId?: StringFilter<"Course"> | string
    ownerId?: StringFilter<"Course"> | string
    publishStatus?: EnumPublishStatusEnumFilter<"Course"> | $Enums.PublishStatusEnum
  }

  export type CourseUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutOwnerInput, CourseUncheckedUpdateWithoutOwnerInput>
    create: XOR<CourseCreateWithoutOwnerInput, CourseUncheckedCreateWithoutOwnerInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutOwnerInput, CourseUncheckedUpdateWithoutOwnerInput>
  }

  export type CourseUpdateManyWithWhereWithoutOwnerInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ModuleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutCreatorInput, ModuleUncheckedUpdateWithoutCreatorInput>
    create: XOR<ModuleCreateWithoutCreatorInput, ModuleUncheckedCreateWithoutCreatorInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutCreatorInput, ModuleUncheckedUpdateWithoutCreatorInput>
  }

  export type ModuleUpdateManyWithWhereWithoutCreatorInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    id?: StringFilter<"Module"> | string
    slug?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    category?: StringFilter<"Module"> | string
    totalHours?: IntFilter<"Module"> | number
    averageHoursPerLesson?: FloatFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    creatorId?: StringFilter<"Module"> | string
    ownerId?: StringFilter<"Module"> | string
    courseId?: StringFilter<"Module"> | string
    publishStatus?: EnumPublishStatusEnumFilter<"Module"> | $Enums.PublishStatusEnum
  }

  export type ModuleUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutOwnerInput, ModuleUncheckedUpdateWithoutOwnerInput>
    create: XOR<ModuleCreateWithoutOwnerInput, ModuleUncheckedCreateWithoutOwnerInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutOwnerInput, ModuleUncheckedUpdateWithoutOwnerInput>
  }

  export type ModuleUpdateManyWithWhereWithoutOwnerInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ExerciseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutCreatorInput, ExerciseUncheckedUpdateWithoutCreatorInput>
    create: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutCreatorInput, ExerciseUncheckedUpdateWithoutCreatorInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutCreatorInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ExerciseScalarWhereInput = {
    AND?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    OR?: ExerciseScalarWhereInput[]
    NOT?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    id?: StringFilter<"Exercise"> | string
    title?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    content?: StringFilter<"Exercise"> | string
    type?: EnumExerciseTypeEnumFilter<"Exercise"> | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFilter<"Exercise"> | $Enums.DifficultyLevelEnum
    points?: IntFilter<"Exercise"> | number
    timeLimit?: IntNullableFilter<"Exercise"> | number | null
    topicId?: StringNullableFilter<"Exercise"> | string | null
    isTeamExercise?: BoolFilter<"Exercise"> | boolean
    creatorId?: StringFilter<"Exercise"> | string
    ownerId?: StringFilter<"Exercise"> | string
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    clientId?: StringNullableFilter<"Exercise"> | string | null
    publishStatus?: EnumPublishStatusEnumFilter<"Exercise"> | $Enums.PublishStatusEnum
  }

  export type ExerciseUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutOwnerInput, ExerciseUncheckedUpdateWithoutOwnerInput>
    create: XOR<ExerciseCreateWithoutOwnerInput, ExerciseUncheckedCreateWithoutOwnerInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutOwnerInput, ExerciseUncheckedUpdateWithoutOwnerInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutOwnerInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ExamUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutCreatorInput, ExamUncheckedUpdateWithoutCreatorInput>
    create: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutCreatorInput, ExamUncheckedUpdateWithoutCreatorInput>
  }

  export type ExamUpdateManyWithWhereWithoutCreatorInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: StringFilter<"Exam"> | string
    name?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    type?: EnumExamTypeEnumFilter<"Exam"> | $Enums.ExamTypeEnum
    moduleId?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    duration?: IntFilter<"Exam"> | number
    maxScore?: FloatFilter<"Exam"> | number
    creatorId?: StringFilter<"Exam"> | string
    ownerId?: StringFilter<"Exam"> | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    publishStatus?: EnumPublishStatusEnumFilter<"Exam"> | $Enums.PublishStatusEnum
  }

  export type ExamUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutOwnerInput, ExamUncheckedUpdateWithoutOwnerInput>
    create: XOR<ExamCreateWithoutOwnerInput, ExamUncheckedCreateWithoutOwnerInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutOwnerInput, ExamUncheckedUpdateWithoutOwnerInput>
  }

  export type ExamUpdateManyWithWhereWithoutOwnerInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ClientUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutCreatorInput, ClientUncheckedUpdateWithoutCreatorInput>
    create: XOR<ClientCreateWithoutCreatorInput, ClientUncheckedCreateWithoutCreatorInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutCreatorInput, ClientUncheckedUpdateWithoutCreatorInput>
  }

  export type ClientUpdateManyWithWhereWithoutCreatorInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    description?: StringNullableFilter<"Client"> | string | null
    creatorId?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutCreatorInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCreatorInput, EventUncheckedUpdateWithoutCreatorInput>
    create: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCreatorInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCreatorInput, EventUncheckedUpdateWithoutCreatorInput>
  }

  export type EventUpdateManyWithWhereWithoutCreatorInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCreatorInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    type?: EnumEventTypeEnumFilter<"Event"> | $Enums.EventTypeEnum
    courseId?: StringNullableFilter<"Event"> | string | null
    moduleId?: StringNullableFilter<"Event"> | string | null
    creatorId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutTeacherInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTeacherInput, NotificationUncheckedUpdateWithoutTeacherInput>
    create: XOR<NotificationCreateWithoutTeacherInput, NotificationUncheckedCreateWithoutTeacherInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTeacherInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTeacherInput, NotificationUncheckedUpdateWithoutTeacherInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTeacherInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTeacherInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringNullableFilter<"Notification"> | string | null
    message?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeEnumFilter<"Notification"> | $Enums.NotificationTypeEnum
    teacherId?: StringNullableFilter<"Notification"> | string | null
    studentId?: StringNullableFilter<"Notification"> | string | null
    seen?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PurchasedItemUpsertWithWhereUniqueWithoutTeacherInput = {
    where: PurchasedItemWhereUniqueInput
    update: XOR<PurchasedItemUpdateWithoutTeacherInput, PurchasedItemUncheckedUpdateWithoutTeacherInput>
    create: XOR<PurchasedItemCreateWithoutTeacherInput, PurchasedItemUncheckedCreateWithoutTeacherInput>
  }

  export type PurchasedItemUpdateWithWhereUniqueWithoutTeacherInput = {
    where: PurchasedItemWhereUniqueInput
    data: XOR<PurchasedItemUpdateWithoutTeacherInput, PurchasedItemUncheckedUpdateWithoutTeacherInput>
  }

  export type PurchasedItemUpdateManyWithWhereWithoutTeacherInput = {
    where: PurchasedItemScalarWhereInput
    data: XOR<PurchasedItemUpdateManyMutationInput, PurchasedItemUncheckedUpdateManyWithoutTeacherInput>
  }

  export type PurchasedItemScalarWhereInput = {
    AND?: PurchasedItemScalarWhereInput | PurchasedItemScalarWhereInput[]
    OR?: PurchasedItemScalarWhereInput[]
    NOT?: PurchasedItemScalarWhereInput | PurchasedItemScalarWhereInput[]
    id?: StringFilter<"PurchasedItem"> | string
    teacherId?: StringFilter<"PurchasedItem"> | string
    shopItemId?: StringFilter<"PurchasedItem"> | string
    purchaseDate?: DateTimeFilter<"PurchasedItem"> | Date | string
    createdAt?: DateTimeFilter<"PurchasedItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasedItem"> | Date | string
  }

  export type RentalPeriodUpsertWithWhereUniqueWithoutTeacherInput = {
    where: RentalPeriodWhereUniqueInput
    update: XOR<RentalPeriodUpdateWithoutTeacherInput, RentalPeriodUncheckedUpdateWithoutTeacherInput>
    create: XOR<RentalPeriodCreateWithoutTeacherInput, RentalPeriodUncheckedCreateWithoutTeacherInput>
  }

  export type RentalPeriodUpdateWithWhereUniqueWithoutTeacherInput = {
    where: RentalPeriodWhereUniqueInput
    data: XOR<RentalPeriodUpdateWithoutTeacherInput, RentalPeriodUncheckedUpdateWithoutTeacherInput>
  }

  export type RentalPeriodUpdateManyWithWhereWithoutTeacherInput = {
    where: RentalPeriodScalarWhereInput
    data: XOR<RentalPeriodUpdateManyMutationInput, RentalPeriodUncheckedUpdateManyWithoutTeacherInput>
  }

  export type RentalPeriodScalarWhereInput = {
    AND?: RentalPeriodScalarWhereInput | RentalPeriodScalarWhereInput[]
    OR?: RentalPeriodScalarWhereInput[]
    NOT?: RentalPeriodScalarWhereInput | RentalPeriodScalarWhereInput[]
    id?: StringFilter<"RentalPeriod"> | string
    teacherId?: StringFilter<"RentalPeriod"> | string
    shopItemId?: StringFilter<"RentalPeriod"> | string
    rentStartDate?: DateTimeFilter<"RentalPeriod"> | Date | string
    rentEndDate?: DateTimeFilter<"RentalPeriod"> | Date | string
    createdAt?: DateTimeFilter<"RentalPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"RentalPeriod"> | Date | string
    isActive?: BoolFilter<"RentalPeriod"> | boolean
  }

  export type MaterialUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutCreatorInput, MaterialUncheckedUpdateWithoutCreatorInput>
    create: XOR<MaterialCreateWithoutCreatorInput, MaterialUncheckedCreateWithoutCreatorInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutCreatorInput, MaterialUncheckedUpdateWithoutCreatorInput>
  }

  export type MaterialUpdateManyWithWhereWithoutCreatorInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutCreatorInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    OR?: MaterialScalarWhereInput[]
    NOT?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    id?: StringFilter<"Material"> | string
    name?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    url?: StringNullableFilter<"Material"> | string | null
    type?: EnumMaterialTypeFilter<"Material"> | $Enums.MaterialType
    courseId?: StringNullableFilter<"Material"> | string | null
    moduleId?: StringNullableFilter<"Material"> | string | null
    topicId?: StringNullableFilter<"Material"> | string | null
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    creatorId?: StringFilter<"Material"> | string
    ownerId?: StringFilter<"Material"> | string
    publishStatus?: EnumPublishStatusEnumFilter<"Material"> | $Enums.PublishStatusEnum
  }

  export type MaterialUpsertWithWhereUniqueWithoutOwnerInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutOwnerInput, MaterialUncheckedUpdateWithoutOwnerInput>
    create: XOR<MaterialCreateWithoutOwnerInput, MaterialUncheckedCreateWithoutOwnerInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutOwnerInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutOwnerInput, MaterialUncheckedUpdateWithoutOwnerInput>
  }

  export type MaterialUpdateManyWithWhereWithoutOwnerInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutOwnerInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutAddedByInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutAddedByInput, StudentUncheckedUpdateWithoutAddedByInput>
    create: XOR<StudentCreateWithoutAddedByInput, StudentUncheckedCreateWithoutAddedByInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutAddedByInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutAddedByInput, StudentUncheckedUpdateWithoutAddedByInput>
  }

  export type StudentUpdateManyWithWhereWithoutAddedByInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutAddedByInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    enrollYear?: IntFilter<"Student"> | number
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    addedById?: StringFilter<"Student"> | string
  }

  export type ClassUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutTeacherInput, ClassUncheckedUpdateWithoutTeacherInput>
    create: XOR<ClassCreateWithoutTeacherInput, ClassUncheckedCreateWithoutTeacherInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutTeacherInput, ClassUncheckedUpdateWithoutTeacherInput>
  }

  export type ClassUpdateManyWithWhereWithoutTeacherInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    color?: StringNullableFilter<"Class"> | string | null
    courseId?: StringFilter<"Class"> | string
    teacherId?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type LessonScheduleUpsertWithWhereUniqueWithoutTeacherInput = {
    where: LessonScheduleWhereUniqueInput
    update: XOR<LessonScheduleUpdateWithoutTeacherInput, LessonScheduleUncheckedUpdateWithoutTeacherInput>
    create: XOR<LessonScheduleCreateWithoutTeacherInput, LessonScheduleUncheckedCreateWithoutTeacherInput>
  }

  export type LessonScheduleUpdateWithWhereUniqueWithoutTeacherInput = {
    where: LessonScheduleWhereUniqueInput
    data: XOR<LessonScheduleUpdateWithoutTeacherInput, LessonScheduleUncheckedUpdateWithoutTeacherInput>
  }

  export type LessonScheduleUpdateManyWithWhereWithoutTeacherInput = {
    where: LessonScheduleScalarWhereInput
    data: XOR<LessonScheduleUpdateManyMutationInput, LessonScheduleUncheckedUpdateManyWithoutTeacherInput>
  }

  export type LessonScheduleScalarWhereInput = {
    AND?: LessonScheduleScalarWhereInput | LessonScheduleScalarWhereInput[]
    OR?: LessonScheduleScalarWhereInput[]
    NOT?: LessonScheduleScalarWhereInput | LessonScheduleScalarWhereInput[]
    id?: StringFilter<"LessonSchedule"> | string
    lessonId?: StringFilter<"LessonSchedule"> | string
    dateTime?: DateTimeFilter<"LessonSchedule"> | Date | string
    duration?: IntFilter<"LessonSchedule"> | number
    createdAt?: DateTimeFilter<"LessonSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"LessonSchedule"> | Date | string
    teacherId?: StringNullableFilter<"LessonSchedule"> | string | null
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutTeacherInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutTeacherInput, EnrollmentUncheckedUpdateWithoutTeacherInput>
    create: XOR<EnrollmentCreateWithoutTeacherInput, EnrollmentUncheckedCreateWithoutTeacherInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutTeacherInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutTeacherInput, EnrollmentUncheckedUpdateWithoutTeacherInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutTeacherInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutTeacherInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    classId?: StringFilter<"Enrollment"> | string
    status?: EnumEnrollmentStatusEnumFilter<"Enrollment"> | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFilter<"Enrollment"> | Date | string
    endDate?: DateTimeFilter<"Enrollment"> | Date | string
    totalPrice?: IntNullableFilter<"Enrollment"> | number | null
    currency?: EnumCurrencyTypeEnumFilter<"Enrollment"> | $Enums.CurrencyTypeEnum
    teacherId?: StringNullableFilter<"Enrollment"> | string | null
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
  }

  export type TeamUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutTeacherInput, TeamUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeamCreateWithoutTeacherInput, TeamUncheckedCreateWithoutTeacherInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutTeacherInput, TeamUncheckedUpdateWithoutTeacherInput>
  }

  export type TeamUpdateManyWithWhereWithoutTeacherInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    classId?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    teacherId?: StringNullableFilter<"Team"> | string | null
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type ClassCreateWithoutStudentsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutClassesInput
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    teams?: TeamCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    comments?: CommentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    courseId: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    comments?: CommentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStudentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
  }

  export type TeamCreateWithoutStudentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTeamsInput
    exercises?: ExerciseCreateNestedManyWithoutTeamsInput
    comments?: CommentCreateNestedManyWithoutTeamInput
    teacher?: TeacherCreateNestedOneWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    description?: string | null
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
    exercises?: ExerciseUncheckedCreateNestedManyWithoutTeamsInput
    comments?: CommentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutStudentsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutStudentsInput, TeamUncheckedCreateWithoutStudentsInput>
  }

  export type NotificationCreateWithoutStudentInput = {
    id?: string
    title?: string | null
    message?: string | null
    type: $Enums.NotificationTypeEnum
    seen?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutStudentInput = {
    id?: string
    title?: string | null
    message?: string | null
    type: $Enums.NotificationTypeEnum
    teacherId?: string | null
    seen?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutStudentInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput>
  }

  export type NotificationCreateManyStudentInputEnvelope = {
    data: NotificationCreateManyStudentInput | NotificationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutStudentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutStudentInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutStudentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutStudentInput, CommentUncheckedCreateWithoutStudentInput>
  }

  export type CommentCreateManyStudentInputEnvelope = {
    data: CommentCreateManyStudentInput | CommentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutAddedStudentsInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutAddedStudentsInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutAddedStudentsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutAddedStudentsInput, TeacherUncheckedCreateWithoutAddedStudentsInput>
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ClassUpsertWithWhereUniqueWithoutStudentsInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutStudentsInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateManyWithWhereWithoutStudentsInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutStudentsInput>
  }

  export type TeamUpsertWithWhereUniqueWithoutStudentsInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutStudentsInput, TeamUncheckedUpdateWithoutStudentsInput>
    create: XOR<TeamCreateWithoutStudentsInput, TeamUncheckedCreateWithoutStudentsInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutStudentsInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutStudentsInput, TeamUncheckedUpdateWithoutStudentsInput>
  }

  export type TeamUpdateManyWithWhereWithoutStudentsInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutStudentsInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutStudentInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutStudentInput, NotificationUncheckedUpdateWithoutStudentInput>
    create: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutStudentInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutStudentInput, NotificationUncheckedUpdateWithoutStudentInput>
  }

  export type NotificationUpdateManyWithWhereWithoutStudentInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutStudentInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutStudentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutStudentInput, CommentUncheckedUpdateWithoutStudentInput>
    create: XOR<CommentCreateWithoutStudentInput, CommentUncheckedCreateWithoutStudentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutStudentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutStudentInput, CommentUncheckedUpdateWithoutStudentInput>
  }

  export type CommentUpdateManyWithWhereWithoutStudentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutStudentInput>
  }

  export type TeacherUpsertWithoutAddedStudentsInput = {
    update: XOR<TeacherUpdateWithoutAddedStudentsInput, TeacherUncheckedUpdateWithoutAddedStudentsInput>
    create: XOR<TeacherCreateWithoutAddedStudentsInput, TeacherUncheckedCreateWithoutAddedStudentsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutAddedStudentsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutAddedStudentsInput, TeacherUncheckedUpdateWithoutAddedStudentsInput>
  }

  export type TeacherUpdateWithoutAddedStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutAddedStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateWithoutCreatedCoursesInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutCreatedCoursesInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutCreatedCoursesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutCreatedCoursesInput, TeacherUncheckedCreateWithoutCreatedCoursesInput>
  }

  export type TeacherCreateWithoutOwnedCoursesInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutOwnedCoursesInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutOwnedCoursesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutOwnedCoursesInput, TeacherUncheckedCreateWithoutOwnedCoursesInput>
  }

  export type ModuleCreateWithoutCourseInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCourseInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput>
  }

  export type ModuleCreateManyCourseInputEnvelope = {
    data: ModuleCreateManyCourseInput | ModuleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutCourseInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    module?: ModuleCreateNestedOneWithoutMaterialsInput
    topic?: TopicCreateNestedOneWithoutMaterialsInput
    comments?: CommentCreateNestedManyWithoutMaterialInput
    creator: TeacherCreateNestedOneWithoutCreatedMaterialInput
    owner: TeacherCreateNestedOneWithoutOwnedMaterialInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutCourseInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    comments?: CommentUncheckedCreateNestedManyWithoutMaterialInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutCourseInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutCourseInput, MaterialUncheckedCreateWithoutCourseInput>
  }

  export type MaterialCreateManyCourseInputEnvelope = {
    data: MaterialCreateManyCourseInput | MaterialCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutCourseInput = {
    id?: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutEnrollmentsInput
    teacher?: TeacherCreateNestedOneWithoutEnrollmentsInput
    holidays?: HolidayCreateNestedManyWithoutEnrollmentInput
    comments?: CommentCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutCourseInput = {
    id?: string
    classId: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    holidays?: HolidayUncheckedCreateNestedManyWithoutEnrollmentInput
    comments?: CommentUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentCreateManyCourseInputEnvelope = {
    data: EnrollmentCreateManyCourseInput | EnrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    module?: ModuleCreateNestedOneWithoutEventsInput
    comments?: CommentCreateNestedManyWithoutEventInput
    creator: TeacherCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    moduleId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCourseInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCourseInput, EventUncheckedCreateWithoutCourseInput>
  }

  export type EventCreateManyCourseInputEnvelope = {
    data: EventCreateManyCourseInput | EventCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutCourseInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassesInput
    teams?: TeamCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    comments?: CommentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutCourseInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassesInput
    teams?: TeamUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    comments?: CommentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutCourseInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutCourseInput, ClassUncheckedCreateWithoutCourseInput>
  }

  export type ClassCreateManyCourseInputEnvelope = {
    data: ClassCreateManyCourseInput | ClassCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutCourseInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutCourseInput = {
    id?: string
    content: string
    userId: string
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutCourseInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCourseInput, CommentUncheckedCreateWithoutCourseInput>
  }

  export type CommentCreateManyCourseInputEnvelope = {
    data: CommentCreateManyCourseInput | CommentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ShopItemForSaleCreateWithoutCourseInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    module?: ModuleCreateNestedOneWithoutForSaleInput
    exercise?: ExerciseCreateNestedOneWithoutForSaleInput
    exam?: ExamCreateNestedOneWithoutForSaleInput
    material?: MaterialCreateNestedOneWithoutForSaleInput
    purchases?: PurchasedItemCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleUncheckedCreateWithoutCourseInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleCreateOrConnectWithoutCourseInput = {
    where: ShopItemForSaleWhereUniqueInput
    create: XOR<ShopItemForSaleCreateWithoutCourseInput, ShopItemForSaleUncheckedCreateWithoutCourseInput>
  }

  export type ShopItemForRentCreateWithoutCourseInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    module?: ModuleCreateNestedOneWithoutForRentInput
    exercise?: ExerciseCreateNestedOneWithoutForRentInput
    exam?: ExamCreateNestedOneWithoutForRentInput
    material?: MaterialCreateNestedOneWithoutForRentInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentUncheckedCreateWithoutCourseInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentCreateOrConnectWithoutCourseInput = {
    where: ShopItemForRentWhereUniqueInput
    create: XOR<ShopItemForRentCreateWithoutCourseInput, ShopItemForRentUncheckedCreateWithoutCourseInput>
  }

  export type TeacherUpsertWithoutCreatedCoursesInput = {
    update: XOR<TeacherUpdateWithoutCreatedCoursesInput, TeacherUncheckedUpdateWithoutCreatedCoursesInput>
    create: XOR<TeacherCreateWithoutCreatedCoursesInput, TeacherUncheckedCreateWithoutCreatedCoursesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutCreatedCoursesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutCreatedCoursesInput, TeacherUncheckedUpdateWithoutCreatedCoursesInput>
  }

  export type TeacherUpdateWithoutCreatedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutCreatedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUpsertWithoutOwnedCoursesInput = {
    update: XOR<TeacherUpdateWithoutOwnedCoursesInput, TeacherUncheckedUpdateWithoutOwnedCoursesInput>
    create: XOR<TeacherCreateWithoutOwnedCoursesInput, TeacherUncheckedCreateWithoutOwnedCoursesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutOwnedCoursesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutOwnedCoursesInput, TeacherUncheckedUpdateWithoutOwnedCoursesInput>
  }

  export type TeacherUpdateWithoutOwnedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutOwnedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ModuleUpsertWithWhereUniqueWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutCourseInput, ModuleUncheckedUpdateWithoutCourseInput>
    create: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutCourseInput, ModuleUncheckedUpdateWithoutCourseInput>
  }

  export type ModuleUpdateManyWithWhereWithoutCourseInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutCourseInput>
  }

  export type MaterialUpsertWithWhereUniqueWithoutCourseInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutCourseInput, MaterialUncheckedUpdateWithoutCourseInput>
    create: XOR<MaterialCreateWithoutCourseInput, MaterialUncheckedCreateWithoutCourseInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutCourseInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutCourseInput, MaterialUncheckedUpdateWithoutCourseInput>
  }

  export type MaterialUpdateManyWithWhereWithoutCourseInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutCourseInput>
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type EventUpsertWithWhereUniqueWithoutCourseInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCourseInput, EventUncheckedUpdateWithoutCourseInput>
    create: XOR<EventCreateWithoutCourseInput, EventUncheckedCreateWithoutCourseInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCourseInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCourseInput, EventUncheckedUpdateWithoutCourseInput>
  }

  export type EventUpdateManyWithWhereWithoutCourseInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCourseInput>
  }

  export type ClassUpsertWithWhereUniqueWithoutCourseInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutCourseInput, ClassUncheckedUpdateWithoutCourseInput>
    create: XOR<ClassCreateWithoutCourseInput, ClassUncheckedCreateWithoutCourseInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutCourseInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutCourseInput, ClassUncheckedUpdateWithoutCourseInput>
  }

  export type ClassUpdateManyWithWhereWithoutCourseInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutCourseInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutCourseInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCourseInput, CommentUncheckedUpdateWithoutCourseInput>
    create: XOR<CommentCreateWithoutCourseInput, CommentUncheckedCreateWithoutCourseInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCourseInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCourseInput, CommentUncheckedUpdateWithoutCourseInput>
  }

  export type CommentUpdateManyWithWhereWithoutCourseInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCourseInput>
  }

  export type ShopItemForSaleUpsertWithoutCourseInput = {
    update: XOR<ShopItemForSaleUpdateWithoutCourseInput, ShopItemForSaleUncheckedUpdateWithoutCourseInput>
    create: XOR<ShopItemForSaleCreateWithoutCourseInput, ShopItemForSaleUncheckedCreateWithoutCourseInput>
    where?: ShopItemForSaleWhereInput
  }

  export type ShopItemForSaleUpdateToOneWithWhereWithoutCourseInput = {
    where?: ShopItemForSaleWhereInput
    data: XOR<ShopItemForSaleUpdateWithoutCourseInput, ShopItemForSaleUncheckedUpdateWithoutCourseInput>
  }

  export type ShopItemForSaleUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneWithoutForSaleNestedInput
    exercise?: ExerciseUpdateOneWithoutForSaleNestedInput
    exam?: ExamUpdateOneWithoutForSaleNestedInput
    material?: MaterialUpdateOneWithoutForSaleNestedInput
    purchases?: PurchasedItemUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForSaleUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchasedItemUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUpsertWithoutCourseInput = {
    update: XOR<ShopItemForRentUpdateWithoutCourseInput, ShopItemForRentUncheckedUpdateWithoutCourseInput>
    create: XOR<ShopItemForRentCreateWithoutCourseInput, ShopItemForRentUncheckedCreateWithoutCourseInput>
    where?: ShopItemForRentWhereInput
  }

  export type ShopItemForRentUpdateToOneWithWhereWithoutCourseInput = {
    where?: ShopItemForRentWhereInput
    data: XOR<ShopItemForRentUpdateWithoutCourseInput, ShopItemForRentUncheckedUpdateWithoutCourseInput>
  }

  export type ShopItemForRentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    module?: ModuleUpdateOneWithoutForRentNestedInput
    exercise?: ExerciseUpdateOneWithoutForRentNestedInput
    exam?: ExamUpdateOneWithoutForRentNestedInput
    material?: MaterialUpdateOneWithoutForRentNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type TeacherCreateWithoutCreatedModulesInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutCreatedModulesInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutCreatedModulesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutCreatedModulesInput, TeacherUncheckedCreateWithoutCreatedModulesInput>
  }

  export type TeacherCreateWithoutOwnedModulesInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutOwnedModulesInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutOwnedModulesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutOwnedModulesInput, TeacherUncheckedCreateWithoutOwnedModulesInput>
  }

  export type CourseCreateWithoutModulesInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedCoursesInput
    owner: TeacherCreateNestedOneWithoutOwnedCoursesInput
    materials?: MaterialCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    events?: EventCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutCourseInput
    comments?: CommentCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutModulesInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    materials?: MaterialUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    events?: EventUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutCourseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutModulesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
  }

  export type TopicCreateWithoutModuleInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    materials?: MaterialCreateNestedManyWithoutTopicInput
    exercises?: ExerciseCreateNestedManyWithoutTopicInput
    objectives?: ObjectiveCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutModuleInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    materials?: MaterialUncheckedCreateNestedManyWithoutTopicInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutTopicInput
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutModuleInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutModuleInput, TopicUncheckedCreateWithoutModuleInput>
  }

  export type TopicCreateManyModuleInputEnvelope = {
    data: TopicCreateManyModuleInput | TopicCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutModuleInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    course?: CourseCreateNestedOneWithoutMaterialsInput
    topic?: TopicCreateNestedOneWithoutMaterialsInput
    comments?: CommentCreateNestedManyWithoutMaterialInput
    creator: TeacherCreateNestedOneWithoutCreatedMaterialInput
    owner: TeacherCreateNestedOneWithoutOwnedMaterialInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutModuleInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    comments?: CommentUncheckedCreateNestedManyWithoutMaterialInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutModuleInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutModuleInput, MaterialUncheckedCreateWithoutModuleInput>
  }

  export type MaterialCreateManyModuleInputEnvelope = {
    data: MaterialCreateManyModuleInput | MaterialCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleAssignmentCreateWithoutModuleInput = {
    id?: string
    courseId: string
    hourlyRate: number
    currency?: $Enums.CurrencyTypeEnum
    startDate: Date | string
    endDate: Date | string
    teacher: TeacherCreateNestedOneWithoutModuleAssignmentsInput
  }

  export type ModuleAssignmentUncheckedCreateWithoutModuleInput = {
    id?: string
    teacherId: string
    courseId: string
    hourlyRate: number
    currency?: $Enums.CurrencyTypeEnum
    startDate: Date | string
    endDate: Date | string
  }

  export type ModuleAssignmentCreateOrConnectWithoutModuleInput = {
    where: ModuleAssignmentWhereUniqueInput
    create: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput>
  }

  export type ModuleAssignmentCreateManyModuleInputEnvelope = {
    data: ModuleAssignmentCreateManyModuleInput | ModuleAssignmentCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutModuleInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    date: Date | string
    duration: number
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    exercises?: ExamExerciseCreateNestedManyWithoutExamInput
    creator: TeacherCreateNestedOneWithoutCreatedExamsInput
    owner: TeacherCreateNestedOneWithoutOwnedExamsInput
    comments?: CommentCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutModuleInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    date: Date | string
    duration: number
    maxScore: number
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedCreateNestedManyWithoutExamInput
    comments?: CommentUncheckedCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutModuleInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutModuleInput, ExamUncheckedCreateWithoutModuleInput>
  }

  export type ExamCreateManyModuleInputEnvelope = {
    data: ExamCreateManyModuleInput | ExamCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutModuleInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: LessonScheduleCreateNestedManyWithoutLessonInput
    comments?: CommentCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutModuleInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: LessonScheduleUncheckedCreateNestedManyWithoutLessonInput
    comments?: CommentUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutModuleInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput>
  }

  export type LessonCreateManyModuleInputEnvelope = {
    data: LessonCreateManyModuleInput | LessonCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutModuleInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutEventsInput
    comments?: CommentCreateNestedManyWithoutEventInput
    creator: TeacherCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutModuleInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    courseId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutModuleInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutModuleInput, EventUncheckedCreateWithoutModuleInput>
  }

  export type EventCreateManyModuleInputEnvelope = {
    data: EventCreateManyModuleInput | EventCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutModuleInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutModuleInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutModuleInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutModuleInput, CommentUncheckedCreateWithoutModuleInput>
  }

  export type CommentCreateManyModuleInputEnvelope = {
    data: CommentCreateManyModuleInput | CommentCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ShopItemForSaleCreateWithoutModuleInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutForSaleInput
    exercise?: ExerciseCreateNestedOneWithoutForSaleInput
    exam?: ExamCreateNestedOneWithoutForSaleInput
    material?: MaterialCreateNestedOneWithoutForSaleInput
    purchases?: PurchasedItemCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleUncheckedCreateWithoutModuleInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleCreateOrConnectWithoutModuleInput = {
    where: ShopItemForSaleWhereUniqueInput
    create: XOR<ShopItemForSaleCreateWithoutModuleInput, ShopItemForSaleUncheckedCreateWithoutModuleInput>
  }

  export type ShopItemForRentCreateWithoutModuleInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    course?: CourseCreateNestedOneWithoutForRentInput
    exercise?: ExerciseCreateNestedOneWithoutForRentInput
    exam?: ExamCreateNestedOneWithoutForRentInput
    material?: MaterialCreateNestedOneWithoutForRentInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentUncheckedCreateWithoutModuleInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentCreateOrConnectWithoutModuleInput = {
    where: ShopItemForRentWhereUniqueInput
    create: XOR<ShopItemForRentCreateWithoutModuleInput, ShopItemForRentUncheckedCreateWithoutModuleInput>
  }

  export type TeacherUpsertWithoutCreatedModulesInput = {
    update: XOR<TeacherUpdateWithoutCreatedModulesInput, TeacherUncheckedUpdateWithoutCreatedModulesInput>
    create: XOR<TeacherCreateWithoutCreatedModulesInput, TeacherUncheckedCreateWithoutCreatedModulesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutCreatedModulesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutCreatedModulesInput, TeacherUncheckedUpdateWithoutCreatedModulesInput>
  }

  export type TeacherUpdateWithoutCreatedModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutCreatedModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUpsertWithoutOwnedModulesInput = {
    update: XOR<TeacherUpdateWithoutOwnedModulesInput, TeacherUncheckedUpdateWithoutOwnedModulesInput>
    create: XOR<TeacherCreateWithoutOwnedModulesInput, TeacherUncheckedCreateWithoutOwnedModulesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutOwnedModulesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutOwnedModulesInput, TeacherUncheckedUpdateWithoutOwnedModulesInput>
  }

  export type TeacherUpdateWithoutOwnedModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutOwnedModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type CourseUpsertWithoutModulesInput = {
    update: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutModulesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type CourseUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput
    materials?: MaterialUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    events?: EventUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutCourseNestedInput
    comments?: CommentUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    materials?: MaterialUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    events?: EventUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCourseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type TopicUpsertWithWhereUniqueWithoutModuleInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutModuleInput, TopicUncheckedUpdateWithoutModuleInput>
    create: XOR<TopicCreateWithoutModuleInput, TopicUncheckedCreateWithoutModuleInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutModuleInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutModuleInput, TopicUncheckedUpdateWithoutModuleInput>
  }

  export type TopicUpdateManyWithWhereWithoutModuleInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutModuleInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: StringFilter<"Topic"> | string
    name?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    order?: IntFilter<"Topic"> | number
    moduleId?: StringFilter<"Topic"> | string
  }

  export type MaterialUpsertWithWhereUniqueWithoutModuleInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutModuleInput, MaterialUncheckedUpdateWithoutModuleInput>
    create: XOR<MaterialCreateWithoutModuleInput, MaterialUncheckedCreateWithoutModuleInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutModuleInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutModuleInput, MaterialUncheckedUpdateWithoutModuleInput>
  }

  export type MaterialUpdateManyWithWhereWithoutModuleInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleAssignmentUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleAssignmentWhereUniqueInput
    update: XOR<ModuleAssignmentUpdateWithoutModuleInput, ModuleAssignmentUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput>
  }

  export type ModuleAssignmentUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleAssignmentWhereUniqueInput
    data: XOR<ModuleAssignmentUpdateWithoutModuleInput, ModuleAssignmentUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleAssignmentUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleAssignmentScalarWhereInput
    data: XOR<ModuleAssignmentUpdateManyMutationInput, ModuleAssignmentUncheckedUpdateManyWithoutModuleInput>
  }

  export type ExamUpsertWithWhereUniqueWithoutModuleInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutModuleInput, ExamUncheckedUpdateWithoutModuleInput>
    create: XOR<ExamCreateWithoutModuleInput, ExamUncheckedCreateWithoutModuleInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutModuleInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutModuleInput, ExamUncheckedUpdateWithoutModuleInput>
  }

  export type ExamUpdateManyWithWhereWithoutModuleInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutModuleInput>
  }

  export type LessonUpsertWithWhereUniqueWithoutModuleInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutModuleInput, LessonUncheckedUpdateWithoutModuleInput>
    create: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutModuleInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutModuleInput, LessonUncheckedUpdateWithoutModuleInput>
  }

  export type LessonUpdateManyWithWhereWithoutModuleInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutModuleInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    name?: StringFilter<"Lesson"> | string
    description?: StringNullableFilter<"Lesson"> | string | null
    duration?: FloatFilter<"Lesson"> | number
    order?: IntFilter<"Lesson"> | number
    moduleId?: StringFilter<"Lesson"> | string
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutModuleInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutModuleInput, EventUncheckedUpdateWithoutModuleInput>
    create: XOR<EventCreateWithoutModuleInput, EventUncheckedCreateWithoutModuleInput>
  }

  export type EventUpdateWithWhereUniqueWithoutModuleInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutModuleInput, EventUncheckedUpdateWithoutModuleInput>
  }

  export type EventUpdateManyWithWhereWithoutModuleInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutModuleInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutModuleInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutModuleInput, CommentUncheckedUpdateWithoutModuleInput>
    create: XOR<CommentCreateWithoutModuleInput, CommentUncheckedCreateWithoutModuleInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutModuleInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutModuleInput, CommentUncheckedUpdateWithoutModuleInput>
  }

  export type CommentUpdateManyWithWhereWithoutModuleInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutModuleInput>
  }

  export type ShopItemForSaleUpsertWithoutModuleInput = {
    update: XOR<ShopItemForSaleUpdateWithoutModuleInput, ShopItemForSaleUncheckedUpdateWithoutModuleInput>
    create: XOR<ShopItemForSaleCreateWithoutModuleInput, ShopItemForSaleUncheckedCreateWithoutModuleInput>
    where?: ShopItemForSaleWhereInput
  }

  export type ShopItemForSaleUpdateToOneWithWhereWithoutModuleInput = {
    where?: ShopItemForSaleWhereInput
    data: XOR<ShopItemForSaleUpdateWithoutModuleInput, ShopItemForSaleUncheckedUpdateWithoutModuleInput>
  }

  export type ShopItemForSaleUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutForSaleNestedInput
    exercise?: ExerciseUpdateOneWithoutForSaleNestedInput
    exam?: ExamUpdateOneWithoutForSaleNestedInput
    material?: MaterialUpdateOneWithoutForSaleNestedInput
    purchases?: PurchasedItemUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForSaleUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchasedItemUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUpsertWithoutModuleInput = {
    update: XOR<ShopItemForRentUpdateWithoutModuleInput, ShopItemForRentUncheckedUpdateWithoutModuleInput>
    create: XOR<ShopItemForRentCreateWithoutModuleInput, ShopItemForRentUncheckedCreateWithoutModuleInput>
    where?: ShopItemForRentWhereInput
  }

  export type ShopItemForRentUpdateToOneWithWhereWithoutModuleInput = {
    where?: ShopItemForRentWhereInput
    data: XOR<ShopItemForRentUpdateWithoutModuleInput, ShopItemForRentUncheckedUpdateWithoutModuleInput>
  }

  export type ShopItemForRentUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutForRentNestedInput
    exercise?: ExerciseUpdateOneWithoutForRentNestedInput
    exam?: ExamUpdateOneWithoutForRentNestedInput
    material?: MaterialUpdateOneWithoutForRentNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type ModuleCreateWithoutLessonsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutLessonsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutLessonsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
  }

  export type LessonScheduleCreateWithoutLessonInput = {
    id?: string
    dateTime: Date | string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutLessonsScheduleInput
  }

  export type LessonScheduleUncheckedCreateWithoutLessonInput = {
    id?: string
    dateTime: Date | string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
  }

  export type LessonScheduleCreateOrConnectWithoutLessonInput = {
    where: LessonScheduleWhereUniqueInput
    create: XOR<LessonScheduleCreateWithoutLessonInput, LessonScheduleUncheckedCreateWithoutLessonInput>
  }

  export type LessonScheduleCreateManyLessonInputEnvelope = {
    data: LessonScheduleCreateManyLessonInput | LessonScheduleCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutLessonInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutLessonInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutLessonInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutLessonInput, CommentUncheckedCreateWithoutLessonInput>
  }

  export type CommentCreateManyLessonInputEnvelope = {
    data: CommentCreateManyLessonInput | CommentCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type ModuleUpsertWithoutLessonsInput = {
    update: XOR<ModuleUpdateWithoutLessonsInput, ModuleUncheckedUpdateWithoutLessonsInput>
    create: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutLessonsInput, ModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type ModuleUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type LessonScheduleUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonScheduleWhereUniqueInput
    update: XOR<LessonScheduleUpdateWithoutLessonInput, LessonScheduleUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonScheduleCreateWithoutLessonInput, LessonScheduleUncheckedCreateWithoutLessonInput>
  }

  export type LessonScheduleUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonScheduleWhereUniqueInput
    data: XOR<LessonScheduleUpdateWithoutLessonInput, LessonScheduleUncheckedUpdateWithoutLessonInput>
  }

  export type LessonScheduleUpdateManyWithWhereWithoutLessonInput = {
    where: LessonScheduleScalarWhereInput
    data: XOR<LessonScheduleUpdateManyMutationInput, LessonScheduleUncheckedUpdateManyWithoutLessonInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutLessonInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutLessonInput, CommentUncheckedUpdateWithoutLessonInput>
    create: XOR<CommentCreateWithoutLessonInput, CommentUncheckedCreateWithoutLessonInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutLessonInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutLessonInput, CommentUncheckedUpdateWithoutLessonInput>
  }

  export type CommentUpdateManyWithWhereWithoutLessonInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutLessonInput>
  }

  export type ModuleCreateWithoutTopicsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutTopicsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutTopicsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutTopicsInput, ModuleUncheckedCreateWithoutTopicsInput>
  }

  export type MaterialCreateWithoutTopicInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    course?: CourseCreateNestedOneWithoutMaterialsInput
    module?: ModuleCreateNestedOneWithoutMaterialsInput
    comments?: CommentCreateNestedManyWithoutMaterialInput
    creator: TeacherCreateNestedOneWithoutCreatedMaterialInput
    owner: TeacherCreateNestedOneWithoutOwnedMaterialInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutTopicInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    comments?: CommentUncheckedCreateNestedManyWithoutMaterialInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutTopicInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutTopicInput, MaterialUncheckedCreateWithoutTopicInput>
  }

  export type MaterialCreateManyTopicInputEnvelope = {
    data: MaterialCreateManyTopicInput | MaterialCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    examExercises?: ExamExerciseCreateNestedManyWithoutExerciseInput
    creator: TeacherCreateNestedOneWithoutCreatedExercisesInput
    owner: TeacherCreateNestedOneWithoutOwnedExercisesInput
    teams?: TeamCreateNestedManyWithoutExercisesInput
    client?: ClientCreateNestedOneWithoutExercisesInput
    comments?: CommentCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedCreateNestedManyWithoutExerciseInput
    teams?: TeamUncheckedCreateNestedManyWithoutExercisesInput
    comments?: CommentUncheckedCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutTopicInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutTopicInput, ExerciseUncheckedCreateWithoutTopicInput>
  }

  export type ExerciseCreateManyTopicInputEnvelope = {
    data: ExerciseCreateManyTopicInput | ExerciseCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ObjectiveCreateWithoutTopicInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObjectiveUncheckedCreateWithoutTopicInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObjectiveCreateOrConnectWithoutTopicInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutTopicInput, ObjectiveUncheckedCreateWithoutTopicInput>
  }

  export type ObjectiveCreateManyTopicInputEnvelope = {
    data: ObjectiveCreateManyTopicInput | ObjectiveCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutTopicInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutTopicInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutTopicInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput>
  }

  export type CommentCreateManyTopicInputEnvelope = {
    data: CommentCreateManyTopicInput | CommentCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ModuleUpsertWithoutTopicsInput = {
    update: XOR<ModuleUpdateWithoutTopicsInput, ModuleUncheckedUpdateWithoutTopicsInput>
    create: XOR<ModuleCreateWithoutTopicsInput, ModuleUncheckedCreateWithoutTopicsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutTopicsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutTopicsInput, ModuleUncheckedUpdateWithoutTopicsInput>
  }

  export type ModuleUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type MaterialUpsertWithWhereUniqueWithoutTopicInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutTopicInput, MaterialUncheckedUpdateWithoutTopicInput>
    create: XOR<MaterialCreateWithoutTopicInput, MaterialUncheckedCreateWithoutTopicInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutTopicInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutTopicInput, MaterialUncheckedUpdateWithoutTopicInput>
  }

  export type MaterialUpdateManyWithWhereWithoutTopicInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutTopicInput>
  }

  export type ExerciseUpsertWithWhereUniqueWithoutTopicInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutTopicInput, ExerciseUncheckedUpdateWithoutTopicInput>
    create: XOR<ExerciseCreateWithoutTopicInput, ExerciseUncheckedCreateWithoutTopicInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutTopicInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutTopicInput, ExerciseUncheckedUpdateWithoutTopicInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutTopicInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutTopicInput>
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutTopicInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutTopicInput, ObjectiveUncheckedUpdateWithoutTopicInput>
    create: XOR<ObjectiveCreateWithoutTopicInput, ObjectiveUncheckedCreateWithoutTopicInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutTopicInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutTopicInput, ObjectiveUncheckedUpdateWithoutTopicInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutTopicInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutTopicInput>
  }

  export type ObjectiveScalarWhereInput = {
    AND?: ObjectiveScalarWhereInput | ObjectiveScalarWhereInput[]
    OR?: ObjectiveScalarWhereInput[]
    NOT?: ObjectiveScalarWhereInput | ObjectiveScalarWhereInput[]
    id?: StringFilter<"Objective"> | string
    description?: StringFilter<"Objective"> | string
    topicId?: StringFilter<"Objective"> | string
    createdAt?: DateTimeFilter<"Objective"> | Date | string
    updatedAt?: DateTimeFilter<"Objective"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutTopicInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTopicInput, CommentUncheckedUpdateWithoutTopicInput>
    create: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTopicInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTopicInput, CommentUncheckedUpdateWithoutTopicInput>
  }

  export type CommentUpdateManyWithWhereWithoutTopicInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTopicInput>
  }

  export type TopicCreateWithoutObjectivesInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    module: ModuleCreateNestedOneWithoutTopicsInput
    materials?: MaterialCreateNestedManyWithoutTopicInput
    exercises?: ExerciseCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutObjectivesInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    moduleId: string
    materials?: MaterialUncheckedCreateNestedManyWithoutTopicInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutObjectivesInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutObjectivesInput, TopicUncheckedCreateWithoutObjectivesInput>
  }

  export type TopicUpsertWithoutObjectivesInput = {
    update: XOR<TopicUpdateWithoutObjectivesInput, TopicUncheckedUpdateWithoutObjectivesInput>
    create: XOR<TopicCreateWithoutObjectivesInput, TopicUncheckedCreateWithoutObjectivesInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutObjectivesInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutObjectivesInput, TopicUncheckedUpdateWithoutObjectivesInput>
  }

  export type TopicUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    module?: ModuleUpdateOneRequiredWithoutTopicsNestedInput
    materials?: MaterialUpdateManyWithoutTopicNestedInput
    exercises?: ExerciseUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    moduleId?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUncheckedUpdateManyWithoutTopicNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ModuleCreateWithoutAssignmentsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutAssignmentsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutAssignmentsInput, ModuleUncheckedCreateWithoutAssignmentsInput>
  }

  export type TeacherCreateWithoutModuleAssignmentsInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutModuleAssignmentsInput = {
    id?: string
    userId: string
    specialization?: string | null
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutModuleAssignmentsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutModuleAssignmentsInput, TeacherUncheckedCreateWithoutModuleAssignmentsInput>
  }

  export type ModuleUpsertWithoutAssignmentsInput = {
    update: XOR<ModuleUpdateWithoutAssignmentsInput, ModuleUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ModuleCreateWithoutAssignmentsInput, ModuleUncheckedCreateWithoutAssignmentsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutAssignmentsInput, ModuleUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ModuleUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type TeacherUpsertWithoutModuleAssignmentsInput = {
    update: XOR<TeacherUpdateWithoutModuleAssignmentsInput, TeacherUncheckedUpdateWithoutModuleAssignmentsInput>
    create: XOR<TeacherCreateWithoutModuleAssignmentsInput, TeacherUncheckedCreateWithoutModuleAssignmentsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutModuleAssignmentsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutModuleAssignmentsInput, TeacherUncheckedUpdateWithoutModuleAssignmentsInput>
  }

  export type TeacherUpdateWithoutModuleAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutModuleAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TopicCreateWithoutExercisesInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    module: ModuleCreateNestedOneWithoutTopicsInput
    materials?: MaterialCreateNestedManyWithoutTopicInput
    objectives?: ObjectiveCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutExercisesInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    moduleId: string
    materials?: MaterialUncheckedCreateNestedManyWithoutTopicInput
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutExercisesInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutExercisesInput, TopicUncheckedCreateWithoutExercisesInput>
  }

  export type ExamExerciseCreateWithoutExerciseInput = {
    order: number
    exam: ExamCreateNestedOneWithoutExercisesInput
  }

  export type ExamExerciseUncheckedCreateWithoutExerciseInput = {
    examId: string
    order: number
  }

  export type ExamExerciseCreateOrConnectWithoutExerciseInput = {
    where: ExamExerciseWhereUniqueInput
    create: XOR<ExamExerciseCreateWithoutExerciseInput, ExamExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type ExamExerciseCreateManyExerciseInputEnvelope = {
    data: ExamExerciseCreateManyExerciseInput | ExamExerciseCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutCreatedExercisesInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutCreatedExercisesInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutCreatedExercisesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutCreatedExercisesInput, TeacherUncheckedCreateWithoutCreatedExercisesInput>
  }

  export type TeacherCreateWithoutOwnedExercisesInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutOwnedExercisesInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutOwnedExercisesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutOwnedExercisesInput, TeacherUncheckedCreateWithoutOwnedExercisesInput>
  }

  export type TeamCreateWithoutExercisesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTeamsInput
    students?: StudentCreateNestedManyWithoutTeamsInput
    comments?: CommentCreateNestedManyWithoutTeamInput
    teacher?: TeacherCreateNestedOneWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutExercisesInput = {
    id?: string
    name: string
    description?: string | null
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
    students?: StudentUncheckedCreateNestedManyWithoutTeamsInput
    comments?: CommentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutExercisesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutExercisesInput, TeamUncheckedCreateWithoutExercisesInput>
  }

  export type ClientCreateWithoutExercisesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: TeacherCreateNestedOneWithoutCreatedClientsInput
  }

  export type ClientUncheckedCreateWithoutExercisesInput = {
    id?: string
    name: string
    description?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateOrConnectWithoutExercisesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutExercisesInput, ClientUncheckedCreateWithoutExercisesInput>
  }

  export type CommentCreateWithoutExerciseInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutExerciseInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutExerciseInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutExerciseInput, CommentUncheckedCreateWithoutExerciseInput>
  }

  export type CommentCreateManyExerciseInputEnvelope = {
    data: CommentCreateManyExerciseInput | CommentCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type ShopItemForSaleCreateWithoutExerciseInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutForSaleInput
    module?: ModuleCreateNestedOneWithoutForSaleInput
    exam?: ExamCreateNestedOneWithoutForSaleInput
    material?: MaterialCreateNestedOneWithoutForSaleInput
    purchases?: PurchasedItemCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleUncheckedCreateWithoutExerciseInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleCreateOrConnectWithoutExerciseInput = {
    where: ShopItemForSaleWhereUniqueInput
    create: XOR<ShopItemForSaleCreateWithoutExerciseInput, ShopItemForSaleUncheckedCreateWithoutExerciseInput>
  }

  export type ShopItemForRentCreateWithoutExerciseInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    course?: CourseCreateNestedOneWithoutForRentInput
    module?: ModuleCreateNestedOneWithoutForRentInput
    exam?: ExamCreateNestedOneWithoutForRentInput
    material?: MaterialCreateNestedOneWithoutForRentInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentUncheckedCreateWithoutExerciseInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentCreateOrConnectWithoutExerciseInput = {
    where: ShopItemForRentWhereUniqueInput
    create: XOR<ShopItemForRentCreateWithoutExerciseInput, ShopItemForRentUncheckedCreateWithoutExerciseInput>
  }

  export type TopicUpsertWithoutExercisesInput = {
    update: XOR<TopicUpdateWithoutExercisesInput, TopicUncheckedUpdateWithoutExercisesInput>
    create: XOR<TopicCreateWithoutExercisesInput, TopicUncheckedCreateWithoutExercisesInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutExercisesInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutExercisesInput, TopicUncheckedUpdateWithoutExercisesInput>
  }

  export type TopicUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    module?: ModuleUpdateOneRequiredWithoutTopicsNestedInput
    materials?: MaterialUpdateManyWithoutTopicNestedInput
    objectives?: ObjectiveUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    moduleId?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUncheckedUpdateManyWithoutTopicNestedInput
    objectives?: ObjectiveUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ExamExerciseUpsertWithWhereUniqueWithoutExerciseInput = {
    where: ExamExerciseWhereUniqueInput
    update: XOR<ExamExerciseUpdateWithoutExerciseInput, ExamExerciseUncheckedUpdateWithoutExerciseInput>
    create: XOR<ExamExerciseCreateWithoutExerciseInput, ExamExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type ExamExerciseUpdateWithWhereUniqueWithoutExerciseInput = {
    where: ExamExerciseWhereUniqueInput
    data: XOR<ExamExerciseUpdateWithoutExerciseInput, ExamExerciseUncheckedUpdateWithoutExerciseInput>
  }

  export type ExamExerciseUpdateManyWithWhereWithoutExerciseInput = {
    where: ExamExerciseScalarWhereInput
    data: XOR<ExamExerciseUpdateManyMutationInput, ExamExerciseUncheckedUpdateManyWithoutExerciseInput>
  }

  export type ExamExerciseScalarWhereInput = {
    AND?: ExamExerciseScalarWhereInput | ExamExerciseScalarWhereInput[]
    OR?: ExamExerciseScalarWhereInput[]
    NOT?: ExamExerciseScalarWhereInput | ExamExerciseScalarWhereInput[]
    examId?: StringFilter<"ExamExercise"> | string
    exerciseId?: StringFilter<"ExamExercise"> | string
    order?: IntFilter<"ExamExercise"> | number
  }

  export type TeacherUpsertWithoutCreatedExercisesInput = {
    update: XOR<TeacherUpdateWithoutCreatedExercisesInput, TeacherUncheckedUpdateWithoutCreatedExercisesInput>
    create: XOR<TeacherCreateWithoutCreatedExercisesInput, TeacherUncheckedCreateWithoutCreatedExercisesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutCreatedExercisesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutCreatedExercisesInput, TeacherUncheckedUpdateWithoutCreatedExercisesInput>
  }

  export type TeacherUpdateWithoutCreatedExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutCreatedExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUpsertWithoutOwnedExercisesInput = {
    update: XOR<TeacherUpdateWithoutOwnedExercisesInput, TeacherUncheckedUpdateWithoutOwnedExercisesInput>
    create: XOR<TeacherCreateWithoutOwnedExercisesInput, TeacherUncheckedCreateWithoutOwnedExercisesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutOwnedExercisesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutOwnedExercisesInput, TeacherUncheckedUpdateWithoutOwnedExercisesInput>
  }

  export type TeacherUpdateWithoutOwnedExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutOwnedExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeamUpsertWithWhereUniqueWithoutExercisesInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutExercisesInput, TeamUncheckedUpdateWithoutExercisesInput>
    create: XOR<TeamCreateWithoutExercisesInput, TeamUncheckedCreateWithoutExercisesInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutExercisesInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutExercisesInput, TeamUncheckedUpdateWithoutExercisesInput>
  }

  export type TeamUpdateManyWithWhereWithoutExercisesInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutExercisesInput>
  }

  export type ClientUpsertWithoutExercisesInput = {
    update: XOR<ClientUpdateWithoutExercisesInput, ClientUncheckedUpdateWithoutExercisesInput>
    create: XOR<ClientCreateWithoutExercisesInput, ClientUncheckedCreateWithoutExercisesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutExercisesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutExercisesInput, ClientUncheckedUpdateWithoutExercisesInput>
  }

  export type ClientUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: TeacherUpdateOneRequiredWithoutCreatedClientsNestedInput
  }

  export type ClientUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutExerciseInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutExerciseInput, CommentUncheckedUpdateWithoutExerciseInput>
    create: XOR<CommentCreateWithoutExerciseInput, CommentUncheckedCreateWithoutExerciseInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutExerciseInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutExerciseInput, CommentUncheckedUpdateWithoutExerciseInput>
  }

  export type CommentUpdateManyWithWhereWithoutExerciseInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutExerciseInput>
  }

  export type ShopItemForSaleUpsertWithoutExerciseInput = {
    update: XOR<ShopItemForSaleUpdateWithoutExerciseInput, ShopItemForSaleUncheckedUpdateWithoutExerciseInput>
    create: XOR<ShopItemForSaleCreateWithoutExerciseInput, ShopItemForSaleUncheckedCreateWithoutExerciseInput>
    where?: ShopItemForSaleWhereInput
  }

  export type ShopItemForSaleUpdateToOneWithWhereWithoutExerciseInput = {
    where?: ShopItemForSaleWhereInput
    data: XOR<ShopItemForSaleUpdateWithoutExerciseInput, ShopItemForSaleUncheckedUpdateWithoutExerciseInput>
  }

  export type ShopItemForSaleUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutForSaleNestedInput
    module?: ModuleUpdateOneWithoutForSaleNestedInput
    exam?: ExamUpdateOneWithoutForSaleNestedInput
    material?: MaterialUpdateOneWithoutForSaleNestedInput
    purchases?: PurchasedItemUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForSaleUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchasedItemUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUpsertWithoutExerciseInput = {
    update: XOR<ShopItemForRentUpdateWithoutExerciseInput, ShopItemForRentUncheckedUpdateWithoutExerciseInput>
    create: XOR<ShopItemForRentCreateWithoutExerciseInput, ShopItemForRentUncheckedCreateWithoutExerciseInput>
    where?: ShopItemForRentWhereInput
  }

  export type ShopItemForRentUpdateToOneWithWhereWithoutExerciseInput = {
    where?: ShopItemForRentWhereInput
    data: XOR<ShopItemForRentUpdateWithoutExerciseInput, ShopItemForRentUncheckedUpdateWithoutExerciseInput>
  }

  export type ShopItemForRentUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutForRentNestedInput
    module?: ModuleUpdateOneWithoutForRentNestedInput
    exam?: ExamUpdateOneWithoutForRentNestedInput
    material?: MaterialUpdateOneWithoutForRentNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type ModuleCreateWithoutExamsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutExamsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutExamsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutExamsInput, ModuleUncheckedCreateWithoutExamsInput>
  }

  export type ExamExerciseCreateWithoutExamInput = {
    order: number
    exercise: ExerciseCreateNestedOneWithoutExamExercisesInput
  }

  export type ExamExerciseUncheckedCreateWithoutExamInput = {
    exerciseId: string
    order: number
  }

  export type ExamExerciseCreateOrConnectWithoutExamInput = {
    where: ExamExerciseWhereUniqueInput
    create: XOR<ExamExerciseCreateWithoutExamInput, ExamExerciseUncheckedCreateWithoutExamInput>
  }

  export type ExamExerciseCreateManyExamInputEnvelope = {
    data: ExamExerciseCreateManyExamInput | ExamExerciseCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutCreatedExamsInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutCreatedExamsInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutCreatedExamsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutCreatedExamsInput, TeacherUncheckedCreateWithoutCreatedExamsInput>
  }

  export type TeacherCreateWithoutOwnedExamsInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutOwnedExamsInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutOwnedExamsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutOwnedExamsInput, TeacherUncheckedCreateWithoutOwnedExamsInput>
  }

  export type CommentCreateWithoutExamInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutExamInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutExamInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutExamInput, CommentUncheckedCreateWithoutExamInput>
  }

  export type CommentCreateManyExamInputEnvelope = {
    data: CommentCreateManyExamInput | CommentCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ShopItemForSaleCreateWithoutExamInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutForSaleInput
    module?: ModuleCreateNestedOneWithoutForSaleInput
    exercise?: ExerciseCreateNestedOneWithoutForSaleInput
    material?: MaterialCreateNestedOneWithoutForSaleInput
    purchases?: PurchasedItemCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleUncheckedCreateWithoutExamInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleCreateOrConnectWithoutExamInput = {
    where: ShopItemForSaleWhereUniqueInput
    create: XOR<ShopItemForSaleCreateWithoutExamInput, ShopItemForSaleUncheckedCreateWithoutExamInput>
  }

  export type ShopItemForRentCreateWithoutExamInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    course?: CourseCreateNestedOneWithoutForRentInput
    module?: ModuleCreateNestedOneWithoutForRentInput
    exercise?: ExerciseCreateNestedOneWithoutForRentInput
    material?: MaterialCreateNestedOneWithoutForRentInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentUncheckedCreateWithoutExamInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentCreateOrConnectWithoutExamInput = {
    where: ShopItemForRentWhereUniqueInput
    create: XOR<ShopItemForRentCreateWithoutExamInput, ShopItemForRentUncheckedCreateWithoutExamInput>
  }

  export type ModuleUpsertWithoutExamsInput = {
    update: XOR<ModuleUpdateWithoutExamsInput, ModuleUncheckedUpdateWithoutExamsInput>
    create: XOR<ModuleCreateWithoutExamsInput, ModuleUncheckedCreateWithoutExamsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutExamsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutExamsInput, ModuleUncheckedUpdateWithoutExamsInput>
  }

  export type ModuleUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type ExamExerciseUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamExerciseWhereUniqueInput
    update: XOR<ExamExerciseUpdateWithoutExamInput, ExamExerciseUncheckedUpdateWithoutExamInput>
    create: XOR<ExamExerciseCreateWithoutExamInput, ExamExerciseUncheckedCreateWithoutExamInput>
  }

  export type ExamExerciseUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamExerciseWhereUniqueInput
    data: XOR<ExamExerciseUpdateWithoutExamInput, ExamExerciseUncheckedUpdateWithoutExamInput>
  }

  export type ExamExerciseUpdateManyWithWhereWithoutExamInput = {
    where: ExamExerciseScalarWhereInput
    data: XOR<ExamExerciseUpdateManyMutationInput, ExamExerciseUncheckedUpdateManyWithoutExamInput>
  }

  export type TeacherUpsertWithoutCreatedExamsInput = {
    update: XOR<TeacherUpdateWithoutCreatedExamsInput, TeacherUncheckedUpdateWithoutCreatedExamsInput>
    create: XOR<TeacherCreateWithoutCreatedExamsInput, TeacherUncheckedCreateWithoutCreatedExamsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutCreatedExamsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutCreatedExamsInput, TeacherUncheckedUpdateWithoutCreatedExamsInput>
  }

  export type TeacherUpdateWithoutCreatedExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutCreatedExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUpsertWithoutOwnedExamsInput = {
    update: XOR<TeacherUpdateWithoutOwnedExamsInput, TeacherUncheckedUpdateWithoutOwnedExamsInput>
    create: XOR<TeacherCreateWithoutOwnedExamsInput, TeacherUncheckedCreateWithoutOwnedExamsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutOwnedExamsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutOwnedExamsInput, TeacherUncheckedUpdateWithoutOwnedExamsInput>
  }

  export type TeacherUpdateWithoutOwnedExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutOwnedExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutExamInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutExamInput, CommentUncheckedUpdateWithoutExamInput>
    create: XOR<CommentCreateWithoutExamInput, CommentUncheckedCreateWithoutExamInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutExamInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutExamInput, CommentUncheckedUpdateWithoutExamInput>
  }

  export type CommentUpdateManyWithWhereWithoutExamInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutExamInput>
  }

  export type ShopItemForSaleUpsertWithoutExamInput = {
    update: XOR<ShopItemForSaleUpdateWithoutExamInput, ShopItemForSaleUncheckedUpdateWithoutExamInput>
    create: XOR<ShopItemForSaleCreateWithoutExamInput, ShopItemForSaleUncheckedCreateWithoutExamInput>
    where?: ShopItemForSaleWhereInput
  }

  export type ShopItemForSaleUpdateToOneWithWhereWithoutExamInput = {
    where?: ShopItemForSaleWhereInput
    data: XOR<ShopItemForSaleUpdateWithoutExamInput, ShopItemForSaleUncheckedUpdateWithoutExamInput>
  }

  export type ShopItemForSaleUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutForSaleNestedInput
    module?: ModuleUpdateOneWithoutForSaleNestedInput
    exercise?: ExerciseUpdateOneWithoutForSaleNestedInput
    material?: MaterialUpdateOneWithoutForSaleNestedInput
    purchases?: PurchasedItemUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForSaleUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchasedItemUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUpsertWithoutExamInput = {
    update: XOR<ShopItemForRentUpdateWithoutExamInput, ShopItemForRentUncheckedUpdateWithoutExamInput>
    create: XOR<ShopItemForRentCreateWithoutExamInput, ShopItemForRentUncheckedCreateWithoutExamInput>
    where?: ShopItemForRentWhereInput
  }

  export type ShopItemForRentUpdateToOneWithWhereWithoutExamInput = {
    where?: ShopItemForRentWhereInput
    data: XOR<ShopItemForRentUpdateWithoutExamInput, ShopItemForRentUncheckedUpdateWithoutExamInput>
  }

  export type ShopItemForRentUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutForRentNestedInput
    module?: ModuleUpdateOneWithoutForRentNestedInput
    exercise?: ExerciseUpdateOneWithoutForRentNestedInput
    material?: MaterialUpdateOneWithoutForRentNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type ExamCreateWithoutExercisesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    date: Date | string
    duration: number
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    module: ModuleCreateNestedOneWithoutExamsInput
    creator: TeacherCreateNestedOneWithoutCreatedExamsInput
    owner: TeacherCreateNestedOneWithoutOwnedExamsInput
    comments?: CommentCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutExercisesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date | string
    duration: number
    maxScore: number
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    comments?: CommentUncheckedCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutExercisesInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutExercisesInput, ExamUncheckedCreateWithoutExercisesInput>
  }

  export type ExerciseCreateWithoutExamExercisesInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    topic?: TopicCreateNestedOneWithoutExercisesInput
    creator: TeacherCreateNestedOneWithoutCreatedExercisesInput
    owner: TeacherCreateNestedOneWithoutOwnedExercisesInput
    teams?: TeamCreateNestedManyWithoutExercisesInput
    client?: ClientCreateNestedOneWithoutExercisesInput
    comments?: CommentCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutExamExercisesInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
    teams?: TeamUncheckedCreateNestedManyWithoutExercisesInput
    comments?: CommentUncheckedCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutExamExercisesInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutExamExercisesInput, ExerciseUncheckedCreateWithoutExamExercisesInput>
  }

  export type ExamUpsertWithoutExercisesInput = {
    update: XOR<ExamUpdateWithoutExercisesInput, ExamUncheckedUpdateWithoutExercisesInput>
    create: XOR<ExamCreateWithoutExercisesInput, ExamUncheckedCreateWithoutExercisesInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutExercisesInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutExercisesInput, ExamUncheckedUpdateWithoutExercisesInput>
  }

  export type ExamUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    module?: ModuleUpdateOneRequiredWithoutExamsNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExamsNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExamsNestedInput
    comments?: CommentUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    moduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    comments?: CommentUncheckedUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExamNestedInput
  }

  export type ExerciseUpsertWithoutExamExercisesInput = {
    update: XOR<ExerciseUpdateWithoutExamExercisesInput, ExerciseUncheckedUpdateWithoutExamExercisesInput>
    create: XOR<ExerciseCreateWithoutExamExercisesInput, ExerciseUncheckedCreateWithoutExamExercisesInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutExamExercisesInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutExamExercisesInput, ExerciseUncheckedUpdateWithoutExamExercisesInput>
  }

  export type ExerciseUpdateWithoutExamExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topic?: TopicUpdateOneWithoutExercisesNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExercisesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExercisesNestedInput
    teams?: TeamUpdateManyWithoutExercisesNestedInput
    client?: ClientUpdateOneWithoutExercisesNestedInput
    comments?: CommentUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutExamExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    teams?: TeamUncheckedUpdateManyWithoutExercisesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExerciseNestedInput
  }

  export type CourseCreateWithoutMaterialsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedCoursesInput
    owner: TeacherCreateNestedOneWithoutOwnedCoursesInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    events?: EventCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutCourseInput
    comments?: CommentCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutMaterialsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    events?: EventUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutCourseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutMaterialsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutMaterialsInput, CourseUncheckedCreateWithoutMaterialsInput>
  }

  export type ModuleCreateWithoutMaterialsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutMaterialsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutMaterialsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutMaterialsInput, ModuleUncheckedCreateWithoutMaterialsInput>
  }

  export type TopicCreateWithoutMaterialsInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    module: ModuleCreateNestedOneWithoutTopicsInput
    exercises?: ExerciseCreateNestedManyWithoutTopicInput
    objectives?: ObjectiveCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutMaterialsInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    moduleId: string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutTopicInput
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutMaterialsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutMaterialsInput, TopicUncheckedCreateWithoutMaterialsInput>
  }

  export type CommentCreateWithoutMaterialInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutMaterialInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutMaterialInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutMaterialInput, CommentUncheckedCreateWithoutMaterialInput>
  }

  export type CommentCreateManyMaterialInputEnvelope = {
    data: CommentCreateManyMaterialInput | CommentCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutCreatedMaterialInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutCreatedMaterialInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutCreatedMaterialInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutCreatedMaterialInput, TeacherUncheckedCreateWithoutCreatedMaterialInput>
  }

  export type TeacherCreateWithoutOwnedMaterialInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutOwnedMaterialInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutOwnedMaterialInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutOwnedMaterialInput, TeacherUncheckedCreateWithoutOwnedMaterialInput>
  }

  export type ShopItemForSaleCreateWithoutMaterialInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutForSaleInput
    module?: ModuleCreateNestedOneWithoutForSaleInput
    exercise?: ExerciseCreateNestedOneWithoutForSaleInput
    exam?: ExamCreateNestedOneWithoutForSaleInput
    purchases?: PurchasedItemCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleUncheckedCreateWithoutMaterialInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForSaleCreateOrConnectWithoutMaterialInput = {
    where: ShopItemForSaleWhereUniqueInput
    create: XOR<ShopItemForSaleCreateWithoutMaterialInput, ShopItemForSaleUncheckedCreateWithoutMaterialInput>
  }

  export type ShopItemForRentCreateWithoutMaterialInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    course?: CourseCreateNestedOneWithoutForRentInput
    module?: ModuleCreateNestedOneWithoutForRentInput
    exercise?: ExerciseCreateNestedOneWithoutForRentInput
    exam?: ExamCreateNestedOneWithoutForRentInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentUncheckedCreateWithoutMaterialInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutShopItemInput
  }

  export type ShopItemForRentCreateOrConnectWithoutMaterialInput = {
    where: ShopItemForRentWhereUniqueInput
    create: XOR<ShopItemForRentCreateWithoutMaterialInput, ShopItemForRentUncheckedCreateWithoutMaterialInput>
  }

  export type CourseUpsertWithoutMaterialsInput = {
    update: XOR<CourseUpdateWithoutMaterialsInput, CourseUncheckedUpdateWithoutMaterialsInput>
    create: XOR<CourseCreateWithoutMaterialsInput, CourseUncheckedCreateWithoutMaterialsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutMaterialsInput, CourseUncheckedUpdateWithoutMaterialsInput>
  }

  export type CourseUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    events?: EventUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutCourseNestedInput
    comments?: CommentUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    events?: EventUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCourseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type ModuleUpsertWithoutMaterialsInput = {
    update: XOR<ModuleUpdateWithoutMaterialsInput, ModuleUncheckedUpdateWithoutMaterialsInput>
    create: XOR<ModuleCreateWithoutMaterialsInput, ModuleUncheckedCreateWithoutMaterialsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutMaterialsInput, ModuleUncheckedUpdateWithoutMaterialsInput>
  }

  export type ModuleUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type TopicUpsertWithoutMaterialsInput = {
    update: XOR<TopicUpdateWithoutMaterialsInput, TopicUncheckedUpdateWithoutMaterialsInput>
    create: XOR<TopicCreateWithoutMaterialsInput, TopicUncheckedCreateWithoutMaterialsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutMaterialsInput, TopicUncheckedUpdateWithoutMaterialsInput>
  }

  export type TopicUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    module?: ModuleUpdateOneRequiredWithoutTopicsNestedInput
    exercises?: ExerciseUpdateManyWithoutTopicNestedInput
    objectives?: ObjectiveUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    moduleId?: StringFieldUpdateOperationsInput | string
    exercises?: ExerciseUncheckedUpdateManyWithoutTopicNestedInput
    objectives?: ObjectiveUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutMaterialInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutMaterialInput, CommentUncheckedUpdateWithoutMaterialInput>
    create: XOR<CommentCreateWithoutMaterialInput, CommentUncheckedCreateWithoutMaterialInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutMaterialInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutMaterialInput, CommentUncheckedUpdateWithoutMaterialInput>
  }

  export type CommentUpdateManyWithWhereWithoutMaterialInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutMaterialInput>
  }

  export type TeacherUpsertWithoutCreatedMaterialInput = {
    update: XOR<TeacherUpdateWithoutCreatedMaterialInput, TeacherUncheckedUpdateWithoutCreatedMaterialInput>
    create: XOR<TeacherCreateWithoutCreatedMaterialInput, TeacherUncheckedCreateWithoutCreatedMaterialInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutCreatedMaterialInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutCreatedMaterialInput, TeacherUncheckedUpdateWithoutCreatedMaterialInput>
  }

  export type TeacherUpdateWithoutCreatedMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutCreatedMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUpsertWithoutOwnedMaterialInput = {
    update: XOR<TeacherUpdateWithoutOwnedMaterialInput, TeacherUncheckedUpdateWithoutOwnedMaterialInput>
    create: XOR<TeacherCreateWithoutOwnedMaterialInput, TeacherUncheckedCreateWithoutOwnedMaterialInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutOwnedMaterialInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutOwnedMaterialInput, TeacherUncheckedUpdateWithoutOwnedMaterialInput>
  }

  export type TeacherUpdateWithoutOwnedMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutOwnedMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ShopItemForSaleUpsertWithoutMaterialInput = {
    update: XOR<ShopItemForSaleUpdateWithoutMaterialInput, ShopItemForSaleUncheckedUpdateWithoutMaterialInput>
    create: XOR<ShopItemForSaleCreateWithoutMaterialInput, ShopItemForSaleUncheckedCreateWithoutMaterialInput>
    where?: ShopItemForSaleWhereInput
  }

  export type ShopItemForSaleUpdateToOneWithWhereWithoutMaterialInput = {
    where?: ShopItemForSaleWhereInput
    data: XOR<ShopItemForSaleUpdateWithoutMaterialInput, ShopItemForSaleUncheckedUpdateWithoutMaterialInput>
  }

  export type ShopItemForSaleUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutForSaleNestedInput
    module?: ModuleUpdateOneWithoutForSaleNestedInput
    exercise?: ExerciseUpdateOneWithoutForSaleNestedInput
    exam?: ExamUpdateOneWithoutForSaleNestedInput
    purchases?: PurchasedItemUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForSaleUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchasedItemUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUpsertWithoutMaterialInput = {
    update: XOR<ShopItemForRentUpdateWithoutMaterialInput, ShopItemForRentUncheckedUpdateWithoutMaterialInput>
    create: XOR<ShopItemForRentCreateWithoutMaterialInput, ShopItemForRentUncheckedCreateWithoutMaterialInput>
    where?: ShopItemForRentWhereInput
  }

  export type ShopItemForRentUpdateToOneWithWhereWithoutMaterialInput = {
    where?: ShopItemForRentWhereInput
    data: XOR<ShopItemForRentUpdateWithoutMaterialInput, ShopItemForRentUncheckedUpdateWithoutMaterialInput>
  }

  export type ShopItemForRentUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutForRentNestedInput
    module?: ModuleUpdateOneWithoutForRentNestedInput
    exercise?: ExerciseUpdateOneWithoutForRentNestedInput
    exam?: ExamUpdateOneWithoutForRentNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutShopItemNestedInput
  }

  export type ShopItemForRentUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutShopItemNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    userApiToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastAccessedAt?: Date | string | null
    isActive?: boolean
    isDeleted?: boolean
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CourseCreateWithoutCommentsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedCoursesInput
    owner: TeacherCreateNestedOneWithoutOwnedCoursesInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    materials?: MaterialCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    events?: EventCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCommentsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    materials?: MaterialUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    events?: EventUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCommentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCommentsInput, CourseUncheckedCreateWithoutCommentsInput>
  }

  export type ModuleCreateWithoutCommentsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCommentsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCommentsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCommentsInput, ModuleUncheckedCreateWithoutCommentsInput>
  }

  export type TopicCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    module: ModuleCreateNestedOneWithoutTopicsInput
    materials?: MaterialCreateNestedManyWithoutTopicInput
    exercises?: ExerciseCreateNestedManyWithoutTopicInput
    objectives?: ObjectiveCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    moduleId: string
    materials?: MaterialUncheckedCreateNestedManyWithoutTopicInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutTopicInput
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutCommentsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutCommentsInput, TopicUncheckedCreateWithoutCommentsInput>
  }

  export type MaterialCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    course?: CourseCreateNestedOneWithoutMaterialsInput
    module?: ModuleCreateNestedOneWithoutMaterialsInput
    topic?: TopicCreateNestedOneWithoutMaterialsInput
    creator: TeacherCreateNestedOneWithoutCreatedMaterialInput
    owner: TeacherCreateNestedOneWithoutOwnedMaterialInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutMaterialInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutCommentsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutCommentsInput, MaterialUncheckedCreateWithoutCommentsInput>
  }

  export type EnrollmentCreateWithoutCommentsInput = {
    id?: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    class: ClassCreateNestedOneWithoutEnrollmentsInput
    teacher?: TeacherCreateNestedOneWithoutEnrollmentsInput
    holidays?: HolidayCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutCommentsInput = {
    id?: string
    courseId: string
    classId: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    holidays?: HolidayUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutCommentsInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutCommentsInput, EnrollmentUncheckedCreateWithoutCommentsInput>
  }

  export type ClassCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutClassesInput
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassesInput
    teams?: TeamCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    courseId: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassesInput
    teams?: TeamUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutCommentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutCommentsInput, ClassUncheckedCreateWithoutCommentsInput>
  }

  export type TeamCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTeamsInput
    students?: StudentCreateNestedManyWithoutTeamsInput
    exercises?: ExerciseCreateNestedManyWithoutTeamsInput
    teacher?: TeacherCreateNestedOneWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
    students?: StudentUncheckedCreateNestedManyWithoutTeamsInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamCreateOrConnectWithoutCommentsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCommentsInput, TeamUncheckedCreateWithoutCommentsInput>
  }

  export type EventCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutEventsInput
    module?: ModuleCreateNestedOneWithoutEventsInput
    creator: TeacherCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    courseId?: string | null
    moduleId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutCommentsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCommentsInput, EventUncheckedCreateWithoutCommentsInput>
  }

  export type LessonCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutLessonsInput
    schedules?: LessonScheduleCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    order: number
    moduleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: LessonScheduleUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCommentsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
  }

  export type ExamCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    date: Date | string
    duration: number
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    module: ModuleCreateNestedOneWithoutExamsInput
    exercises?: ExamExerciseCreateNestedManyWithoutExamInput
    creator: TeacherCreateNestedOneWithoutCreatedExamsInput
    owner: TeacherCreateNestedOneWithoutOwnedExamsInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date | string
    duration: number
    maxScore: number
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExamInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutCommentsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutCommentsInput, ExamUncheckedCreateWithoutCommentsInput>
  }

  export type ExerciseCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    topic?: TopicCreateNestedOneWithoutExercisesInput
    examExercises?: ExamExerciseCreateNestedManyWithoutExerciseInput
    creator: TeacherCreateNestedOneWithoutCreatedExercisesInput
    owner: TeacherCreateNestedOneWithoutOwnedExercisesInput
    teams?: TeamCreateNestedManyWithoutExercisesInput
    client?: ClientCreateNestedOneWithoutExercisesInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedCreateNestedManyWithoutExerciseInput
    teams?: TeamUncheckedCreateNestedManyWithoutExercisesInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutCommentsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutCommentsInput, ExerciseUncheckedCreateWithoutCommentsInput>
  }

  export type StudentCreateWithoutCommentsInput = {
    id?: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    classes?: ClassCreateNestedManyWithoutStudentsInput
    teams?: TeamCreateNestedManyWithoutStudentsInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
    addedBy: TeacherCreateNestedOneWithoutAddedStudentsInput
  }

  export type StudentUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedById: string
    classes?: ClassUncheckedCreateNestedManyWithoutStudentsInput
    teams?: TeamUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCommentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCommentsInput, StudentUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userApiToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CourseUpsertWithoutCommentsInput = {
    update: XOR<CourseUpdateWithoutCommentsInput, CourseUncheckedUpdateWithoutCommentsInput>
    create: XOR<CourseCreateWithoutCommentsInput, CourseUncheckedCreateWithoutCommentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCommentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCommentsInput, CourseUncheckedUpdateWithoutCommentsInput>
  }

  export type CourseUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    materials?: MaterialUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    events?: EventUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    events?: EventUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type ModuleUpsertWithoutCommentsInput = {
    update: XOR<ModuleUpdateWithoutCommentsInput, ModuleUncheckedUpdateWithoutCommentsInput>
    create: XOR<ModuleCreateWithoutCommentsInput, ModuleUncheckedCreateWithoutCommentsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutCommentsInput, ModuleUncheckedUpdateWithoutCommentsInput>
  }

  export type ModuleUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type TopicUpsertWithoutCommentsInput = {
    update: XOR<TopicUpdateWithoutCommentsInput, TopicUncheckedUpdateWithoutCommentsInput>
    create: XOR<TopicCreateWithoutCommentsInput, TopicUncheckedCreateWithoutCommentsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutCommentsInput, TopicUncheckedUpdateWithoutCommentsInput>
  }

  export type TopicUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    module?: ModuleUpdateOneRequiredWithoutTopicsNestedInput
    materials?: MaterialUpdateManyWithoutTopicNestedInput
    exercises?: ExerciseUpdateManyWithoutTopicNestedInput
    objectives?: ObjectiveUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    moduleId?: StringFieldUpdateOperationsInput | string
    materials?: MaterialUncheckedUpdateManyWithoutTopicNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutTopicNestedInput
    objectives?: ObjectiveUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type MaterialUpsertWithoutCommentsInput = {
    update: XOR<MaterialUpdateWithoutCommentsInput, MaterialUncheckedUpdateWithoutCommentsInput>
    create: XOR<MaterialCreateWithoutCommentsInput, MaterialUncheckedCreateWithoutCommentsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutCommentsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutCommentsInput, MaterialUncheckedUpdateWithoutCommentsInput>
  }

  export type MaterialUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    course?: CourseUpdateOneWithoutMaterialsNestedInput
    module?: ModuleUpdateOneWithoutMaterialsNestedInput
    topic?: TopicUpdateOneWithoutMaterialsNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedMaterialNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedMaterialNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutMaterialNestedInput
  }

  export type EnrollmentUpsertWithoutCommentsInput = {
    update: XOR<EnrollmentUpdateWithoutCommentsInput, EnrollmentUncheckedUpdateWithoutCommentsInput>
    create: XOR<EnrollmentCreateWithoutCommentsInput, EnrollmentUncheckedCreateWithoutCommentsInput>
    where?: EnrollmentWhereInput
  }

  export type EnrollmentUpdateToOneWithWhereWithoutCommentsInput = {
    where?: EnrollmentWhereInput
    data: XOR<EnrollmentUpdateWithoutCommentsInput, EnrollmentUncheckedUpdateWithoutCommentsInput>
  }

  export type EnrollmentUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    class?: ClassUpdateOneRequiredWithoutEnrollmentsNestedInput
    teacher?: TeacherUpdateOneWithoutEnrollmentsNestedInput
    holidays?: HolidayUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holidays?: HolidayUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type ClassUpsertWithoutCommentsInput = {
    update: XOR<ClassUpdateWithoutCommentsInput, ClassUncheckedUpdateWithoutCommentsInput>
    create: XOR<ClassCreateWithoutCommentsInput, ClassUncheckedCreateWithoutCommentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutCommentsInput, ClassUncheckedUpdateWithoutCommentsInput>
  }

  export type ClassUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassesNestedInput
    teams?: TeamUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassesNestedInput
    teams?: TeamUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type TeamUpsertWithoutCommentsInput = {
    update: XOR<TeamUpdateWithoutCommentsInput, TeamUncheckedUpdateWithoutCommentsInput>
    create: XOR<TeamCreateWithoutCommentsInput, TeamUncheckedCreateWithoutCommentsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutCommentsInput, TeamUncheckedUpdateWithoutCommentsInput>
  }

  export type TeamUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTeamsNestedInput
    students?: StudentUpdateManyWithoutTeamsNestedInput
    exercises?: ExerciseUpdateManyWithoutTeamsNestedInput
    teacher?: TeacherUpdateOneWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateManyWithoutTeamsNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type EventUpsertWithoutCommentsInput = {
    update: XOR<EventUpdateWithoutCommentsInput, EventUncheckedUpdateWithoutCommentsInput>
    create: XOR<EventCreateWithoutCommentsInput, EventUncheckedCreateWithoutCommentsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutCommentsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutCommentsInput, EventUncheckedUpdateWithoutCommentsInput>
  }

  export type EventUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutEventsNestedInput
    module?: ModuleUpdateOneWithoutEventsNestedInput
    creator?: TeacherUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUpsertWithoutCommentsInput = {
    update: XOR<LessonUpdateWithoutCommentsInput, LessonUncheckedUpdateWithoutCommentsInput>
    create: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutCommentsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutCommentsInput, LessonUncheckedUpdateWithoutCommentsInput>
  }

  export type LessonUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    schedules?: LessonScheduleUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    moduleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: LessonScheduleUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type ExamUpsertWithoutCommentsInput = {
    update: XOR<ExamUpdateWithoutCommentsInput, ExamUncheckedUpdateWithoutCommentsInput>
    create: XOR<ExamCreateWithoutCommentsInput, ExamUncheckedCreateWithoutCommentsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutCommentsInput, ExamUncheckedUpdateWithoutCommentsInput>
  }

  export type ExamUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    module?: ModuleUpdateOneRequiredWithoutExamsNestedInput
    exercises?: ExamExerciseUpdateManyWithoutExamNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExamsNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExamsNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    moduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExamNestedInput
  }

  export type ExerciseUpsertWithoutCommentsInput = {
    update: XOR<ExerciseUpdateWithoutCommentsInput, ExerciseUncheckedUpdateWithoutCommentsInput>
    create: XOR<ExerciseCreateWithoutCommentsInput, ExerciseUncheckedCreateWithoutCommentsInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutCommentsInput, ExerciseUncheckedUpdateWithoutCommentsInput>
  }

  export type ExerciseUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topic?: TopicUpdateOneWithoutExercisesNestedInput
    examExercises?: ExamExerciseUpdateManyWithoutExerciseNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExercisesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExercisesNestedInput
    teams?: TeamUpdateManyWithoutExercisesNestedInput
    client?: ClientUpdateOneWithoutExercisesNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    teams?: TeamUncheckedUpdateManyWithoutExercisesNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExerciseNestedInput
  }

  export type StudentUpsertWithoutCommentsInput = {
    update: XOR<StudentUpdateWithoutCommentsInput, StudentUncheckedUpdateWithoutCommentsInput>
    create: XOR<StudentCreateWithoutCommentsInput, StudentUncheckedCreateWithoutCommentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutCommentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutCommentsInput, StudentUncheckedUpdateWithoutCommentsInput>
  }

  export type StudentUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: ClassUpdateManyWithoutStudentsNestedInput
    teams?: TeamUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
    addedBy?: TeacherUpdateOneRequiredWithoutAddedStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: StringFieldUpdateOperationsInput | string
    classes?: ClassUncheckedUpdateManyWithoutStudentsNestedInput
    teams?: TeamUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedCoursesInput
    owner: TeacherCreateNestedOneWithoutOwnedCoursesInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    materials?: MaterialCreateNestedManyWithoutCourseInput
    events?: EventCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutCourseInput
    comments?: CommentCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    materials?: MaterialUncheckedCreateNestedManyWithoutCourseInput
    events?: EventUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutCourseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type ClassCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutClassesInput
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassesInput
    teams?: TeamCreateNestedManyWithoutClassInput
    comments?: CommentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    courseId: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassesInput
    teams?: TeamUncheckedCreateNestedManyWithoutClassInput
    comments?: CommentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutEnrollmentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
  }

  export type TeacherCreateWithoutEnrollmentsInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutEnrollmentsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutEnrollmentsInput, TeacherUncheckedCreateWithoutEnrollmentsInput>
  }

  export type HolidayCreateWithoutEnrollmentInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUncheckedCreateWithoutEnrollmentInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayCreateOrConnectWithoutEnrollmentInput = {
    where: HolidayWhereUniqueInput
    create: XOR<HolidayCreateWithoutEnrollmentInput, HolidayUncheckedCreateWithoutEnrollmentInput>
  }

  export type HolidayCreateManyEnrollmentInputEnvelope = {
    data: HolidayCreateManyEnrollmentInput | HolidayCreateManyEnrollmentInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutEnrollmentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutEnrollmentInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutEnrollmentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutEnrollmentInput, CommentUncheckedCreateWithoutEnrollmentInput>
  }

  export type CommentCreateManyEnrollmentInputEnvelope = {
    data: CommentCreateManyEnrollmentInput | CommentCreateManyEnrollmentInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    materials?: MaterialUpdateManyWithoutCourseNestedInput
    events?: EventUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutCourseNestedInput
    comments?: CommentUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutCourseNestedInput
    events?: EventUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCourseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type ClassUpsertWithoutEnrollmentsInput = {
    update: XOR<ClassUpdateWithoutEnrollmentsInput, ClassUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutEnrollmentsInput, ClassUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ClassUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassesNestedInput
    teams?: TeamUpdateManyWithoutClassNestedInput
    comments?: CommentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassesNestedInput
    teams?: TeamUncheckedUpdateManyWithoutClassNestedInput
    comments?: CommentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type TeacherUpsertWithoutEnrollmentsInput = {
    update: XOR<TeacherUpdateWithoutEnrollmentsInput, TeacherUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<TeacherCreateWithoutEnrollmentsInput, TeacherUncheckedCreateWithoutEnrollmentsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutEnrollmentsInput, TeacherUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type TeacherUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type HolidayUpsertWithWhereUniqueWithoutEnrollmentInput = {
    where: HolidayWhereUniqueInput
    update: XOR<HolidayUpdateWithoutEnrollmentInput, HolidayUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<HolidayCreateWithoutEnrollmentInput, HolidayUncheckedCreateWithoutEnrollmentInput>
  }

  export type HolidayUpdateWithWhereUniqueWithoutEnrollmentInput = {
    where: HolidayWhereUniqueInput
    data: XOR<HolidayUpdateWithoutEnrollmentInput, HolidayUncheckedUpdateWithoutEnrollmentInput>
  }

  export type HolidayUpdateManyWithWhereWithoutEnrollmentInput = {
    where: HolidayScalarWhereInput
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type HolidayScalarWhereInput = {
    AND?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
    OR?: HolidayScalarWhereInput[]
    NOT?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
    id?: StringFilter<"Holiday"> | string
    name?: StringFilter<"Holiday"> | string
    startDate?: DateTimeFilter<"Holiday"> | Date | string
    endDate?: DateTimeFilter<"Holiday"> | Date | string
    enrollmentId?: StringFilter<"Holiday"> | string
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutEnrollmentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutEnrollmentInput, CommentUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<CommentCreateWithoutEnrollmentInput, CommentUncheckedCreateWithoutEnrollmentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutEnrollmentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutEnrollmentInput, CommentUncheckedUpdateWithoutEnrollmentInput>
  }

  export type CommentUpdateManyWithWhereWithoutEnrollmentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type CourseCreateWithoutClassesInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedCoursesInput
    owner: TeacherCreateNestedOneWithoutOwnedCoursesInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    materials?: MaterialCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    events?: EventCreateNestedManyWithoutCourseInput
    comments?: CommentCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutClassesInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    materials?: MaterialUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    events?: EventUncheckedCreateNestedManyWithoutCourseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutClassesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutClassesInput, CourseUncheckedCreateWithoutClassesInput>
  }

  export type TeacherCreateWithoutClassesInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutClassesInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutClassesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
  }

  export type StudentCreateWithoutClassesInput = {
    id?: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    teams?: TeamCreateNestedManyWithoutStudentsInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
    comments?: CommentCreateNestedManyWithoutStudentInput
    addedBy: TeacherCreateNestedOneWithoutAddedStudentsInput
  }

  export type StudentUncheckedCreateWithoutClassesInput = {
    id?: string
    userId: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedById: string
    teams?: TeamUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
    comments?: CommentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassesInput, StudentUncheckedCreateWithoutClassesInput>
  }

  export type TeamCreateWithoutClassInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutTeamsInput
    exercises?: ExerciseCreateNestedManyWithoutTeamsInput
    comments?: CommentCreateNestedManyWithoutTeamInput
    teacher?: TeacherCreateNestedOneWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutClassInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
    students?: StudentUncheckedCreateNestedManyWithoutTeamsInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutTeamsInput
    comments?: CommentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutClassInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutClassInput, TeamUncheckedCreateWithoutClassInput>
  }

  export type TeamCreateManyClassInputEnvelope = {
    data: TeamCreateManyClassInput | TeamCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutClassInput = {
    id?: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    teacher?: TeacherCreateNestedOneWithoutEnrollmentsInput
    holidays?: HolidayCreateNestedManyWithoutEnrollmentInput
    comments?: CommentCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutClassInput = {
    id?: string
    courseId: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    holidays?: HolidayUncheckedCreateNestedManyWithoutEnrollmentInput
    comments?: CommentUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutClassInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput>
  }

  export type EnrollmentCreateManyClassInputEnvelope = {
    data: EnrollmentCreateManyClassInput | EnrollmentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutClassInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutClassInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutClassInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutClassInput, CommentUncheckedCreateWithoutClassInput>
  }

  export type CommentCreateManyClassInputEnvelope = {
    data: CommentCreateManyClassInput | CommentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutClassesInput = {
    update: XOR<CourseUpdateWithoutClassesInput, CourseUncheckedUpdateWithoutClassesInput>
    create: XOR<CourseCreateWithoutClassesInput, CourseUncheckedCreateWithoutClassesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutClassesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutClassesInput, CourseUncheckedUpdateWithoutClassesInput>
  }

  export type CourseUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    materials?: MaterialUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    events?: EventUpdateManyWithoutCourseNestedInput
    comments?: CommentUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    events?: EventUncheckedUpdateManyWithoutCourseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type TeacherUpsertWithoutClassesInput = {
    update: XOR<TeacherUpdateWithoutClassesInput, TeacherUncheckedUpdateWithoutClassesInput>
    create: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutClassesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutClassesInput, TeacherUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutClassesInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassesInput, StudentUncheckedUpdateWithoutClassesInput>
    create: XOR<StudentCreateWithoutClassesInput, StudentUncheckedCreateWithoutClassesInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassesInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassesInput, StudentUncheckedUpdateWithoutClassesInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassesInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClassesInput>
  }

  export type TeamUpsertWithWhereUniqueWithoutClassInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutClassInput, TeamUncheckedUpdateWithoutClassInput>
    create: XOR<TeamCreateWithoutClassInput, TeamUncheckedCreateWithoutClassInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutClassInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutClassInput, TeamUncheckedUpdateWithoutClassInput>
  }

  export type TeamUpdateManyWithWhereWithoutClassInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutClassInput>
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutClassInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutClassInput, EnrollmentUncheckedUpdateWithoutClassInput>
    create: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutClassInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutClassInput, EnrollmentUncheckedUpdateWithoutClassInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutClassInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutClassInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutClassInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutClassInput, CommentUncheckedUpdateWithoutClassInput>
    create: XOR<CommentCreateWithoutClassInput, CommentUncheckedCreateWithoutClassInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutClassInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutClassInput, CommentUncheckedUpdateWithoutClassInput>
  }

  export type CommentUpdateManyWithWhereWithoutClassInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutClassInput>
  }

  export type EnrollmentCreateWithoutHolidaysInput = {
    id?: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    class: ClassCreateNestedOneWithoutEnrollmentsInput
    teacher?: TeacherCreateNestedOneWithoutEnrollmentsInput
    comments?: CommentCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentUncheckedCreateWithoutHolidaysInput = {
    id?: string
    courseId: string
    classId: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type EnrollmentCreateOrConnectWithoutHolidaysInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutHolidaysInput, EnrollmentUncheckedCreateWithoutHolidaysInput>
  }

  export type EnrollmentUpsertWithoutHolidaysInput = {
    update: XOR<EnrollmentUpdateWithoutHolidaysInput, EnrollmentUncheckedUpdateWithoutHolidaysInput>
    create: XOR<EnrollmentCreateWithoutHolidaysInput, EnrollmentUncheckedCreateWithoutHolidaysInput>
    where?: EnrollmentWhereInput
  }

  export type EnrollmentUpdateToOneWithWhereWithoutHolidaysInput = {
    where?: EnrollmentWhereInput
    data: XOR<EnrollmentUpdateWithoutHolidaysInput, EnrollmentUncheckedUpdateWithoutHolidaysInput>
  }

  export type EnrollmentUpdateWithoutHolidaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    class?: ClassUpdateOneRequiredWithoutEnrollmentsNestedInput
    teacher?: TeacherUpdateOneWithoutEnrollmentsNestedInput
    comments?: CommentUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutHolidaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type LessonCreateWithoutSchedulesInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutLessonsInput
    comments?: CommentCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutSchedulesInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    order: number
    moduleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutSchedulesInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutSchedulesInput, LessonUncheckedCreateWithoutSchedulesInput>
  }

  export type TeacherCreateWithoutLessonsScheduleInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutLessonsScheduleInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutLessonsScheduleInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutLessonsScheduleInput, TeacherUncheckedCreateWithoutLessonsScheduleInput>
  }

  export type LessonUpsertWithoutSchedulesInput = {
    update: XOR<LessonUpdateWithoutSchedulesInput, LessonUncheckedUpdateWithoutSchedulesInput>
    create: XOR<LessonCreateWithoutSchedulesInput, LessonUncheckedCreateWithoutSchedulesInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutSchedulesInput, LessonUncheckedUpdateWithoutSchedulesInput>
  }

  export type LessonUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    comments?: CommentUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    moduleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type TeacherUpsertWithoutLessonsScheduleInput = {
    update: XOR<TeacherUpdateWithoutLessonsScheduleInput, TeacherUncheckedUpdateWithoutLessonsScheduleInput>
    create: XOR<TeacherCreateWithoutLessonsScheduleInput, TeacherUncheckedCreateWithoutLessonsScheduleInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutLessonsScheduleInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutLessonsScheduleInput, TeacherUncheckedUpdateWithoutLessonsScheduleInput>
  }

  export type TeacherUpdateWithoutLessonsScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutLessonsScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type CourseCreateWithoutEventsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedCoursesInput
    owner: TeacherCreateNestedOneWithoutOwnedCoursesInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    materials?: MaterialCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutCourseInput
    comments?: CommentCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutEventsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    materials?: MaterialUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutCourseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEventsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEventsInput, CourseUncheckedCreateWithoutEventsInput>
  }

  export type ModuleCreateWithoutEventsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutEventsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutEventsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutEventsInput, ModuleUncheckedCreateWithoutEventsInput>
  }

  export type CommentCreateWithoutEventInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    team?: TeamCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutEventInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutEventInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutEventInput, CommentUncheckedCreateWithoutEventInput>
  }

  export type CommentCreateManyEventInputEnvelope = {
    data: CommentCreateManyEventInput | CommentCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutEventsInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutEventsInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutEventsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutEventsInput, TeacherUncheckedCreateWithoutEventsInput>
  }

  export type CourseUpsertWithoutEventsInput = {
    update: XOR<CourseUpdateWithoutEventsInput, CourseUncheckedUpdateWithoutEventsInput>
    create: XOR<CourseCreateWithoutEventsInput, CourseUncheckedCreateWithoutEventsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEventsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEventsInput, CourseUncheckedUpdateWithoutEventsInput>
  }

  export type CourseUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    materials?: MaterialUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutCourseNestedInput
    comments?: CommentUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCourseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type ModuleUpsertWithoutEventsInput = {
    update: XOR<ModuleUpdateWithoutEventsInput, ModuleUncheckedUpdateWithoutEventsInput>
    create: XOR<ModuleCreateWithoutEventsInput, ModuleUncheckedCreateWithoutEventsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutEventsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutEventsInput, ModuleUncheckedUpdateWithoutEventsInput>
  }

  export type ModuleUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutEventInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutEventInput, CommentUncheckedUpdateWithoutEventInput>
    create: XOR<CommentCreateWithoutEventInput, CommentUncheckedCreateWithoutEventInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutEventInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutEventInput, CommentUncheckedUpdateWithoutEventInput>
  }

  export type CommentUpdateManyWithWhereWithoutEventInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutEventInput>
  }

  export type TeacherUpsertWithoutEventsInput = {
    update: XOR<TeacherUpdateWithoutEventsInput, TeacherUncheckedUpdateWithoutEventsInput>
    create: XOR<TeacherCreateWithoutEventsInput, TeacherUncheckedCreateWithoutEventsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutEventsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutEventsInput, TeacherUncheckedUpdateWithoutEventsInput>
  }

  export type TeacherUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassCreateWithoutTeamsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutClassesInput
    teacher?: TeacherCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassesInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    comments?: CommentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTeamsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    courseId: string
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassesInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    comments?: CommentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTeamsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTeamsInput, ClassUncheckedCreateWithoutTeamsInput>
  }

  export type StudentCreateWithoutTeamsInput = {
    id?: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    classes?: ClassCreateNestedManyWithoutStudentsInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
    comments?: CommentCreateNestedManyWithoutStudentInput
    addedBy: TeacherCreateNestedOneWithoutAddedStudentsInput
  }

  export type StudentUncheckedCreateWithoutTeamsInput = {
    id?: string
    userId: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedById: string
    classes?: ClassUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
    comments?: CommentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutTeamsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutTeamsInput, StudentUncheckedCreateWithoutTeamsInput>
  }

  export type ExerciseCreateWithoutTeamsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    topic?: TopicCreateNestedOneWithoutExercisesInput
    examExercises?: ExamExerciseCreateNestedManyWithoutExerciseInput
    creator: TeacherCreateNestedOneWithoutCreatedExercisesInput
    owner: TeacherCreateNestedOneWithoutOwnedExercisesInput
    client?: ClientCreateNestedOneWithoutExercisesInput
    comments?: CommentCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutTeamsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedCreateNestedManyWithoutExerciseInput
    comments?: CommentUncheckedCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutTeamsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutTeamsInput, ExerciseUncheckedCreateWithoutTeamsInput>
  }

  export type CommentCreateWithoutTeamInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    course?: CourseCreateNestedOneWithoutCommentsInput
    module?: ModuleCreateNestedOneWithoutCommentsInput
    topic?: TopicCreateNestedOneWithoutCommentsInput
    material?: MaterialCreateNestedOneWithoutCommentsInput
    enrollment?: EnrollmentCreateNestedOneWithoutCommentsInput
    class?: ClassCreateNestedOneWithoutCommentsInput
    event?: EventCreateNestedOneWithoutCommentsInput
    lesson?: LessonCreateNestedOneWithoutCommentsInput
    exam?: ExamCreateNestedOneWithoutCommentsInput
    exercise?: ExerciseCreateNestedOneWithoutCommentsInput
    student?: StudentCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutTeamInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutTeamInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTeamInput, CommentUncheckedCreateWithoutTeamInput>
  }

  export type CommentCreateManyTeamInputEnvelope = {
    data: CommentCreateManyTeamInput | CommentCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutTeamsInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTeamsInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTeamsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTeamsInput, TeacherUncheckedCreateWithoutTeamsInput>
  }

  export type ClassUpsertWithoutTeamsInput = {
    update: XOR<ClassUpdateWithoutTeamsInput, ClassUncheckedUpdateWithoutTeamsInput>
    create: XOR<ClassCreateWithoutTeamsInput, ClassUncheckedCreateWithoutTeamsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutTeamsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutTeamsInput, ClassUncheckedUpdateWithoutTeamsInput>
  }

  export type ClassUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    comments?: CommentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassesNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    comments?: CommentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutTeamsInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutTeamsInput, StudentUncheckedUpdateWithoutTeamsInput>
    create: XOR<StudentCreateWithoutTeamsInput, StudentUncheckedCreateWithoutTeamsInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutTeamsInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutTeamsInput, StudentUncheckedUpdateWithoutTeamsInput>
  }

  export type StudentUpdateManyWithWhereWithoutTeamsInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutTeamsInput>
  }

  export type ExerciseUpsertWithWhereUniqueWithoutTeamsInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutTeamsInput, ExerciseUncheckedUpdateWithoutTeamsInput>
    create: XOR<ExerciseCreateWithoutTeamsInput, ExerciseUncheckedCreateWithoutTeamsInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutTeamsInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutTeamsInput, ExerciseUncheckedUpdateWithoutTeamsInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutTeamsInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutTeamsInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutTeamInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTeamInput, CommentUncheckedUpdateWithoutTeamInput>
    create: XOR<CommentCreateWithoutTeamInput, CommentUncheckedCreateWithoutTeamInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTeamInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTeamInput, CommentUncheckedUpdateWithoutTeamInput>
  }

  export type CommentUpdateManyWithWhereWithoutTeamInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeacherUpsertWithoutTeamsInput = {
    update: XOR<TeacherUpdateWithoutTeamsInput, TeacherUncheckedUpdateWithoutTeamsInput>
    create: XOR<TeacherCreateWithoutTeamsInput, TeacherUncheckedCreateWithoutTeamsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutTeamsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutTeamsInput, TeacherUncheckedUpdateWithoutTeamsInput>
  }

  export type TeacherUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateWithoutCreatedClientsInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutCreatedClientsInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutCreatedClientsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutCreatedClientsInput, TeacherUncheckedCreateWithoutCreatedClientsInput>
  }

  export type ExerciseCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    topic?: TopicCreateNestedOneWithoutExercisesInput
    examExercises?: ExamExerciseCreateNestedManyWithoutExerciseInput
    creator: TeacherCreateNestedOneWithoutCreatedExercisesInput
    owner: TeacherCreateNestedOneWithoutOwnedExercisesInput
    teams?: TeamCreateNestedManyWithoutExercisesInput
    comments?: CommentCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedCreateNestedManyWithoutExerciseInput
    teams?: TeamUncheckedCreateNestedManyWithoutExercisesInput
    comments?: CommentUncheckedCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExerciseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutClientInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutClientInput, ExerciseUncheckedCreateWithoutClientInput>
  }

  export type ExerciseCreateManyClientInputEnvelope = {
    data: ExerciseCreateManyClientInput | ExerciseCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type TeacherUpsertWithoutCreatedClientsInput = {
    update: XOR<TeacherUpdateWithoutCreatedClientsInput, TeacherUncheckedUpdateWithoutCreatedClientsInput>
    create: XOR<TeacherCreateWithoutCreatedClientsInput, TeacherUncheckedCreateWithoutCreatedClientsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutCreatedClientsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutCreatedClientsInput, TeacherUncheckedUpdateWithoutCreatedClientsInput>
  }

  export type TeacherUpdateWithoutCreatedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutCreatedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ExerciseUpsertWithWhereUniqueWithoutClientInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutClientInput, ExerciseUncheckedUpdateWithoutClientInput>
    create: XOR<ExerciseCreateWithoutClientInput, ExerciseUncheckedCreateWithoutClientInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutClientInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutClientInput, ExerciseUncheckedUpdateWithoutClientInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutClientInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutClientInput>
  }

  export type TeacherCreateWithoutNotificationsInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutNotificationsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutNotificationsInput, TeacherUncheckedCreateWithoutNotificationsInput>
  }

  export type StudentCreateWithoutNotificationsInput = {
    id?: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    classes?: ClassCreateNestedManyWithoutStudentsInput
    teams?: TeamCreateNestedManyWithoutStudentsInput
    comments?: CommentCreateNestedManyWithoutStudentInput
    addedBy: TeacherCreateNestedOneWithoutAddedStudentsInput
  }

  export type StudentUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedById: string
    classes?: ClassUncheckedCreateNestedManyWithoutStudentsInput
    teams?: TeamUncheckedCreateNestedManyWithoutStudentsInput
    comments?: CommentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutNotificationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
  }

  export type TeacherUpsertWithoutNotificationsInput = {
    update: XOR<TeacherUpdateWithoutNotificationsInput, TeacherUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TeacherCreateWithoutNotificationsInput, TeacherUncheckedCreateWithoutNotificationsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutNotificationsInput, TeacherUncheckedUpdateWithoutNotificationsInput>
  }

  export type TeacherUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentUpsertWithoutNotificationsInput = {
    update: XOR<StudentUpdateWithoutNotificationsInput, StudentUncheckedUpdateWithoutNotificationsInput>
    create: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutNotificationsInput, StudentUncheckedUpdateWithoutNotificationsInput>
  }

  export type StudentUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: ClassUpdateManyWithoutStudentsNestedInput
    teams?: TeamUpdateManyWithoutStudentsNestedInput
    comments?: CommentUpdateManyWithoutStudentNestedInput
    addedBy?: TeacherUpdateOneRequiredWithoutAddedStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: StringFieldUpdateOperationsInput | string
    classes?: ClassUncheckedUpdateManyWithoutStudentsNestedInput
    teams?: TeamUncheckedUpdateManyWithoutStudentsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseCreateWithoutForSaleInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedCoursesInput
    owner: TeacherCreateNestedOneWithoutOwnedCoursesInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    materials?: MaterialCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    events?: EventCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutCourseInput
    comments?: CommentCreateNestedManyWithoutCourseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutForSaleInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    materials?: MaterialUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    events?: EventUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutCourseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCourseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutForSaleInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutForSaleInput, CourseUncheckedCreateWithoutForSaleInput>
  }

  export type ModuleCreateWithoutForSaleInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forRent?: ShopItemForRentCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutForSaleInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutForSaleInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutForSaleInput, ModuleUncheckedCreateWithoutForSaleInput>
  }

  export type ExerciseCreateWithoutForSaleInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    topic?: TopicCreateNestedOneWithoutExercisesInput
    examExercises?: ExamExerciseCreateNestedManyWithoutExerciseInput
    creator: TeacherCreateNestedOneWithoutCreatedExercisesInput
    owner: TeacherCreateNestedOneWithoutOwnedExercisesInput
    teams?: TeamCreateNestedManyWithoutExercisesInput
    client?: ClientCreateNestedOneWithoutExercisesInput
    comments?: CommentCreateNestedManyWithoutExerciseInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutForSaleInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedCreateNestedManyWithoutExerciseInput
    teams?: TeamUncheckedCreateNestedManyWithoutExercisesInput
    comments?: CommentUncheckedCreateNestedManyWithoutExerciseInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutForSaleInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutForSaleInput, ExerciseUncheckedCreateWithoutForSaleInput>
  }

  export type ExamCreateWithoutForSaleInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    date: Date | string
    duration: number
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    module: ModuleCreateNestedOneWithoutExamsInput
    exercises?: ExamExerciseCreateNestedManyWithoutExamInput
    creator: TeacherCreateNestedOneWithoutCreatedExamsInput
    owner: TeacherCreateNestedOneWithoutOwnedExamsInput
    comments?: CommentCreateNestedManyWithoutExamInput
    forRent?: ShopItemForRentCreateNestedOneWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutForSaleInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date | string
    duration: number
    maxScore: number
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedCreateNestedManyWithoutExamInput
    comments?: CommentUncheckedCreateNestedManyWithoutExamInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutForSaleInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutForSaleInput, ExamUncheckedCreateWithoutForSaleInput>
  }

  export type MaterialCreateWithoutForSaleInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    course?: CourseCreateNestedOneWithoutMaterialsInput
    module?: ModuleCreateNestedOneWithoutMaterialsInput
    topic?: TopicCreateNestedOneWithoutMaterialsInput
    comments?: CommentCreateNestedManyWithoutMaterialInput
    creator: TeacherCreateNestedOneWithoutCreatedMaterialInput
    owner: TeacherCreateNestedOneWithoutOwnedMaterialInput
    forRent?: ShopItemForRentCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutForSaleInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    comments?: CommentUncheckedCreateNestedManyWithoutMaterialInput
    forRent?: ShopItemForRentUncheckedCreateNestedOneWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutForSaleInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutForSaleInput, MaterialUncheckedCreateWithoutForSaleInput>
  }

  export type PurchasedItemCreateWithoutShopItemInput = {
    id?: string
    purchaseDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutPurchasesInput
  }

  export type PurchasedItemUncheckedCreateWithoutShopItemInput = {
    id?: string
    teacherId: string
    purchaseDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasedItemCreateOrConnectWithoutShopItemInput = {
    where: PurchasedItemWhereUniqueInput
    create: XOR<PurchasedItemCreateWithoutShopItemInput, PurchasedItemUncheckedCreateWithoutShopItemInput>
  }

  export type PurchasedItemCreateManyShopItemInputEnvelope = {
    data: PurchasedItemCreateManyShopItemInput | PurchasedItemCreateManyShopItemInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutForSaleInput = {
    update: XOR<CourseUpdateWithoutForSaleInput, CourseUncheckedUpdateWithoutForSaleInput>
    create: XOR<CourseCreateWithoutForSaleInput, CourseUncheckedCreateWithoutForSaleInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutForSaleInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutForSaleInput, CourseUncheckedUpdateWithoutForSaleInput>
  }

  export type CourseUpdateWithoutForSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    materials?: MaterialUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    events?: EventUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutCourseNestedInput
    comments?: CommentUpdateManyWithoutCourseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutForSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    events?: EventUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCourseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCourseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type ModuleUpsertWithoutForSaleInput = {
    update: XOR<ModuleUpdateWithoutForSaleInput, ModuleUncheckedUpdateWithoutForSaleInput>
    create: XOR<ModuleCreateWithoutForSaleInput, ModuleUncheckedCreateWithoutForSaleInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutForSaleInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutForSaleInput, ModuleUncheckedUpdateWithoutForSaleInput>
  }

  export type ModuleUpdateWithoutForSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutForSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type ExerciseUpsertWithoutForSaleInput = {
    update: XOR<ExerciseUpdateWithoutForSaleInput, ExerciseUncheckedUpdateWithoutForSaleInput>
    create: XOR<ExerciseCreateWithoutForSaleInput, ExerciseUncheckedCreateWithoutForSaleInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutForSaleInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutForSaleInput, ExerciseUncheckedUpdateWithoutForSaleInput>
  }

  export type ExerciseUpdateWithoutForSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topic?: TopicUpdateOneWithoutExercisesNestedInput
    examExercises?: ExamExerciseUpdateManyWithoutExerciseNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExercisesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExercisesNestedInput
    teams?: TeamUpdateManyWithoutExercisesNestedInput
    client?: ClientUpdateOneWithoutExercisesNestedInput
    comments?: CommentUpdateManyWithoutExerciseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutForSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    teams?: TeamUncheckedUpdateManyWithoutExercisesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExerciseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExerciseNestedInput
  }

  export type ExamUpsertWithoutForSaleInput = {
    update: XOR<ExamUpdateWithoutForSaleInput, ExamUncheckedUpdateWithoutForSaleInput>
    create: XOR<ExamCreateWithoutForSaleInput, ExamUncheckedCreateWithoutForSaleInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutForSaleInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutForSaleInput, ExamUncheckedUpdateWithoutForSaleInput>
  }

  export type ExamUpdateWithoutForSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    module?: ModuleUpdateOneRequiredWithoutExamsNestedInput
    exercises?: ExamExerciseUpdateManyWithoutExamNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExamsNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExamsNestedInput
    comments?: CommentUpdateManyWithoutExamNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutForSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    moduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedUpdateManyWithoutExamNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExamNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExamNestedInput
  }

  export type MaterialUpsertWithoutForSaleInput = {
    update: XOR<MaterialUpdateWithoutForSaleInput, MaterialUncheckedUpdateWithoutForSaleInput>
    create: XOR<MaterialCreateWithoutForSaleInput, MaterialUncheckedCreateWithoutForSaleInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutForSaleInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutForSaleInput, MaterialUncheckedUpdateWithoutForSaleInput>
  }

  export type MaterialUpdateWithoutForSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    course?: CourseUpdateOneWithoutMaterialsNestedInput
    module?: ModuleUpdateOneWithoutMaterialsNestedInput
    topic?: TopicUpdateOneWithoutMaterialsNestedInput
    comments?: CommentUpdateManyWithoutMaterialNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedMaterialNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedMaterialNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutForSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    comments?: CommentUncheckedUpdateManyWithoutMaterialNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutMaterialNestedInput
  }

  export type PurchasedItemUpsertWithWhereUniqueWithoutShopItemInput = {
    where: PurchasedItemWhereUniqueInput
    update: XOR<PurchasedItemUpdateWithoutShopItemInput, PurchasedItemUncheckedUpdateWithoutShopItemInput>
    create: XOR<PurchasedItemCreateWithoutShopItemInput, PurchasedItemUncheckedCreateWithoutShopItemInput>
  }

  export type PurchasedItemUpdateWithWhereUniqueWithoutShopItemInput = {
    where: PurchasedItemWhereUniqueInput
    data: XOR<PurchasedItemUpdateWithoutShopItemInput, PurchasedItemUncheckedUpdateWithoutShopItemInput>
  }

  export type PurchasedItemUpdateManyWithWhereWithoutShopItemInput = {
    where: PurchasedItemScalarWhereInput
    data: XOR<PurchasedItemUpdateManyMutationInput, PurchasedItemUncheckedUpdateManyWithoutShopItemInput>
  }

  export type CourseCreateWithoutForRentInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedCoursesInput
    owner: TeacherCreateNestedOneWithoutOwnedCoursesInput
    modules?: ModuleCreateNestedManyWithoutCourseInput
    materials?: MaterialCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    events?: EventCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutCourseInput
    comments?: CommentCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutForRentInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    materials?: MaterialUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    events?: EventUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutCourseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCourseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutForRentInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutForRentInput, CourseUncheckedCreateWithoutForRentInput>
  }

  export type ModuleCreateWithoutForRentInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    creator: TeacherCreateNestedOneWithoutCreatedModulesInput
    owner: TeacherCreateNestedOneWithoutOwnedModulesInput
    course: CourseCreateNestedOneWithoutModulesInput
    topics?: TopicCreateNestedManyWithoutModuleInput
    materials?: MaterialCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    exams?: ExamCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    events?: EventCreateNestedManyWithoutModuleInput
    comments?: CommentCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutForRentInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
    topics?: TopicUncheckedCreateNestedManyWithoutModuleInput
    materials?: MaterialUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    exams?: ExamUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    events?: EventUncheckedCreateNestedManyWithoutModuleInput
    comments?: CommentUncheckedCreateNestedManyWithoutModuleInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutForRentInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutForRentInput, ModuleUncheckedCreateWithoutForRentInput>
  }

  export type ExerciseCreateWithoutForRentInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    topic?: TopicCreateNestedOneWithoutExercisesInput
    examExercises?: ExamExerciseCreateNestedManyWithoutExerciseInput
    creator: TeacherCreateNestedOneWithoutCreatedExercisesInput
    owner: TeacherCreateNestedOneWithoutOwnedExercisesInput
    teams?: TeamCreateNestedManyWithoutExercisesInput
    client?: ClientCreateNestedOneWithoutExercisesInput
    comments?: CommentCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutForRentInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedCreateNestedManyWithoutExerciseInput
    teams?: TeamUncheckedCreateNestedManyWithoutExercisesInput
    comments?: CommentUncheckedCreateNestedManyWithoutExerciseInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutForRentInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutForRentInput, ExerciseUncheckedCreateWithoutForRentInput>
  }

  export type ExamCreateWithoutForRentInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    date: Date | string
    duration: number
    maxScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    module: ModuleCreateNestedOneWithoutExamsInput
    exercises?: ExamExerciseCreateNestedManyWithoutExamInput
    creator: TeacherCreateNestedOneWithoutCreatedExamsInput
    owner: TeacherCreateNestedOneWithoutOwnedExamsInput
    comments?: CommentCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutForRentInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date | string
    duration: number
    maxScore: number
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedCreateNestedManyWithoutExamInput
    comments?: CommentUncheckedCreateNestedManyWithoutExamInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutForRentInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutForRentInput, ExamUncheckedCreateWithoutForRentInput>
  }

  export type MaterialCreateWithoutForRentInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
    course?: CourseCreateNestedOneWithoutMaterialsInput
    module?: ModuleCreateNestedOneWithoutMaterialsInput
    topic?: TopicCreateNestedOneWithoutMaterialsInput
    comments?: CommentCreateNestedManyWithoutMaterialInput
    creator: TeacherCreateNestedOneWithoutCreatedMaterialInput
    owner: TeacherCreateNestedOneWithoutOwnedMaterialInput
    forSale?: ShopItemForSaleCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutForRentInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
    comments?: CommentUncheckedCreateNestedManyWithoutMaterialInput
    forSale?: ShopItemForSaleUncheckedCreateNestedOneWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutForRentInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutForRentInput, MaterialUncheckedCreateWithoutForRentInput>
  }

  export type RentalPeriodCreateWithoutShopItemInput = {
    id?: string
    rentStartDate: Date | string
    rentEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    teacher: TeacherCreateNestedOneWithoutRentalPeriodsInput
  }

  export type RentalPeriodUncheckedCreateWithoutShopItemInput = {
    id?: string
    teacherId: string
    rentStartDate: Date | string
    rentEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type RentalPeriodCreateOrConnectWithoutShopItemInput = {
    where: RentalPeriodWhereUniqueInput
    create: XOR<RentalPeriodCreateWithoutShopItemInput, RentalPeriodUncheckedCreateWithoutShopItemInput>
  }

  export type RentalPeriodCreateManyShopItemInputEnvelope = {
    data: RentalPeriodCreateManyShopItemInput | RentalPeriodCreateManyShopItemInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutForRentInput = {
    update: XOR<CourseUpdateWithoutForRentInput, CourseUncheckedUpdateWithoutForRentInput>
    create: XOR<CourseCreateWithoutForRentInput, CourseUncheckedCreateWithoutForRentInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutForRentInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutForRentInput, CourseUncheckedUpdateWithoutForRentInput>
  }

  export type CourseUpdateWithoutForRentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    materials?: MaterialUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    events?: EventUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutCourseNestedInput
    comments?: CommentUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutForRentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    events?: EventUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCourseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type ModuleUpsertWithoutForRentInput = {
    update: XOR<ModuleUpdateWithoutForRentInput, ModuleUncheckedUpdateWithoutForRentInput>
    create: XOR<ModuleCreateWithoutForRentInput, ModuleUncheckedCreateWithoutForRentInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutForRentInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutForRentInput, ModuleUncheckedUpdateWithoutForRentInput>
  }

  export type ModuleUpdateWithoutForRentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutForRentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type ExerciseUpsertWithoutForRentInput = {
    update: XOR<ExerciseUpdateWithoutForRentInput, ExerciseUncheckedUpdateWithoutForRentInput>
    create: XOR<ExerciseCreateWithoutForRentInput, ExerciseUncheckedCreateWithoutForRentInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutForRentInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutForRentInput, ExerciseUncheckedUpdateWithoutForRentInput>
  }

  export type ExerciseUpdateWithoutForRentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topic?: TopicUpdateOneWithoutExercisesNestedInput
    examExercises?: ExamExerciseUpdateManyWithoutExerciseNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExercisesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExercisesNestedInput
    teams?: TeamUpdateManyWithoutExercisesNestedInput
    client?: ClientUpdateOneWithoutExercisesNestedInput
    comments?: CommentUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutForRentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    teams?: TeamUncheckedUpdateManyWithoutExercisesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExerciseNestedInput
  }

  export type ExamUpsertWithoutForRentInput = {
    update: XOR<ExamUpdateWithoutForRentInput, ExamUncheckedUpdateWithoutForRentInput>
    create: XOR<ExamCreateWithoutForRentInput, ExamUncheckedCreateWithoutForRentInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutForRentInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutForRentInput, ExamUncheckedUpdateWithoutForRentInput>
  }

  export type ExamUpdateWithoutForRentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    module?: ModuleUpdateOneRequiredWithoutExamsNestedInput
    exercises?: ExamExerciseUpdateManyWithoutExamNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExamsNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExamsNestedInput
    comments?: CommentUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutForRentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    moduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedUpdateManyWithoutExamNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExamNestedInput
  }

  export type MaterialUpsertWithoutForRentInput = {
    update: XOR<MaterialUpdateWithoutForRentInput, MaterialUncheckedUpdateWithoutForRentInput>
    create: XOR<MaterialCreateWithoutForRentInput, MaterialUncheckedCreateWithoutForRentInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutForRentInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutForRentInput, MaterialUncheckedUpdateWithoutForRentInput>
  }

  export type MaterialUpdateWithoutForRentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    course?: CourseUpdateOneWithoutMaterialsNestedInput
    module?: ModuleUpdateOneWithoutMaterialsNestedInput
    topic?: TopicUpdateOneWithoutMaterialsNestedInput
    comments?: CommentUpdateManyWithoutMaterialNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedMaterialNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedMaterialNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutForRentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    comments?: CommentUncheckedUpdateManyWithoutMaterialNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutMaterialNestedInput
  }

  export type RentalPeriodUpsertWithWhereUniqueWithoutShopItemInput = {
    where: RentalPeriodWhereUniqueInput
    update: XOR<RentalPeriodUpdateWithoutShopItemInput, RentalPeriodUncheckedUpdateWithoutShopItemInput>
    create: XOR<RentalPeriodCreateWithoutShopItemInput, RentalPeriodUncheckedCreateWithoutShopItemInput>
  }

  export type RentalPeriodUpdateWithWhereUniqueWithoutShopItemInput = {
    where: RentalPeriodWhereUniqueInput
    data: XOR<RentalPeriodUpdateWithoutShopItemInput, RentalPeriodUncheckedUpdateWithoutShopItemInput>
  }

  export type RentalPeriodUpdateManyWithWhereWithoutShopItemInput = {
    where: RentalPeriodScalarWhereInput
    data: XOR<RentalPeriodUpdateManyMutationInput, RentalPeriodUncheckedUpdateManyWithoutShopItemInput>
  }

  export type TeacherCreateWithoutPurchasesInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutPurchasesInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    rentalPeriods?: RentalPeriodUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutPurchasesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutPurchasesInput, TeacherUncheckedCreateWithoutPurchasesInput>
  }

  export type ShopItemForSaleCreateWithoutPurchasesInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutForSaleInput
    module?: ModuleCreateNestedOneWithoutForSaleInput
    exercise?: ExerciseCreateNestedOneWithoutForSaleInput
    exam?: ExamCreateNestedOneWithoutForSaleInput
    material?: MaterialCreateNestedOneWithoutForSaleInput
  }

  export type ShopItemForSaleUncheckedCreateWithoutPurchasesInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    itemId: string
    sellPrice: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopItemForSaleCreateOrConnectWithoutPurchasesInput = {
    where: ShopItemForSaleWhereUniqueInput
    create: XOR<ShopItemForSaleCreateWithoutPurchasesInput, ShopItemForSaleUncheckedCreateWithoutPurchasesInput>
  }

  export type TeacherUpsertWithoutPurchasesInput = {
    update: XOR<TeacherUpdateWithoutPurchasesInput, TeacherUncheckedUpdateWithoutPurchasesInput>
    create: XOR<TeacherCreateWithoutPurchasesInput, TeacherUncheckedCreateWithoutPurchasesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutPurchasesInput, TeacherUncheckedUpdateWithoutPurchasesInput>
  }

  export type TeacherUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    rentalPeriods?: RentalPeriodUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ShopItemForSaleUpsertWithoutPurchasesInput = {
    update: XOR<ShopItemForSaleUpdateWithoutPurchasesInput, ShopItemForSaleUncheckedUpdateWithoutPurchasesInput>
    create: XOR<ShopItemForSaleCreateWithoutPurchasesInput, ShopItemForSaleUncheckedCreateWithoutPurchasesInput>
    where?: ShopItemForSaleWhereInput
  }

  export type ShopItemForSaleUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: ShopItemForSaleWhereInput
    data: XOR<ShopItemForSaleUpdateWithoutPurchasesInput, ShopItemForSaleUncheckedUpdateWithoutPurchasesInput>
  }

  export type ShopItemForSaleUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutForSaleNestedInput
    module?: ModuleUpdateOneWithoutForSaleNestedInput
    exercise?: ExerciseUpdateOneWithoutForSaleNestedInput
    exam?: ExamUpdateOneWithoutForSaleNestedInput
    material?: MaterialUpdateOneWithoutForSaleNestedInput
  }

  export type ShopItemForSaleUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    itemId?: StringFieldUpdateOperationsInput | string
    sellPrice?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateWithoutRentalPeriodsInput = {
    id?: string
    specialization?: string | null
    user: UserCreateNestedOneWithoutTeacherInput
    moduleAssignments?: ModuleAssignmentCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseCreateNestedManyWithoutOwnerInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamCreateNestedManyWithoutOwnerInput
    createdClients?: ClientCreateNestedManyWithoutCreatorInput
    events?: EventCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentCreateNestedManyWithoutAddedByInput
    classes?: ClassCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentCreateNestedManyWithoutTeacherInput
    teams?: TeamCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutRentalPeriodsInput = {
    id?: string
    userId: string
    specialization?: string | null
    moduleAssignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutTeacherInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    ownedCourses?: CourseUncheckedCreateNestedManyWithoutOwnerInput
    createdModules?: ModuleUncheckedCreateNestedManyWithoutCreatorInput
    ownedModules?: ModuleUncheckedCreateNestedManyWithoutOwnerInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    ownedExercises?: ExerciseUncheckedCreateNestedManyWithoutOwnerInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    ownedExams?: ExamUncheckedCreateNestedManyWithoutOwnerInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatorInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTeacherInput
    purchases?: PurchasedItemUncheckedCreateNestedManyWithoutTeacherInput
    createdMaterial?: MaterialUncheckedCreateNestedManyWithoutCreatorInput
    ownedMaterial?: MaterialUncheckedCreateNestedManyWithoutOwnerInput
    addedStudents?: StudentUncheckedCreateNestedManyWithoutAddedByInput
    classes?: ClassUncheckedCreateNestedManyWithoutTeacherInput
    lessonsSchedule?: LessonScheduleUncheckedCreateNestedManyWithoutTeacherInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutTeacherInput
    teams?: TeamUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutRentalPeriodsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutRentalPeriodsInput, TeacherUncheckedCreateWithoutRentalPeriodsInput>
  }

  export type ShopItemForRentCreateWithoutRentalPeriodsInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
    course?: CourseCreateNestedOneWithoutForRentInput
    module?: ModuleCreateNestedOneWithoutForRentInput
    exercise?: ExerciseCreateNestedOneWithoutForRentInput
    exam?: ExamCreateNestedOneWithoutForRentInput
    material?: MaterialCreateNestedOneWithoutForRentInput
  }

  export type ShopItemForRentUncheckedCreateWithoutRentalPeriodsInput = {
    id?: string
    itemType: $Enums.ShopItemTypeEnum
    itemId: string
    rentPrice: number
    rentPeriod: number
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    isVisible?: boolean
  }

  export type ShopItemForRentCreateOrConnectWithoutRentalPeriodsInput = {
    where: ShopItemForRentWhereUniqueInput
    create: XOR<ShopItemForRentCreateWithoutRentalPeriodsInput, ShopItemForRentUncheckedCreateWithoutRentalPeriodsInput>
  }

  export type TeacherUpsertWithoutRentalPeriodsInput = {
    update: XOR<TeacherUpdateWithoutRentalPeriodsInput, TeacherUncheckedUpdateWithoutRentalPeriodsInput>
    create: XOR<TeacherCreateWithoutRentalPeriodsInput, TeacherUncheckedCreateWithoutRentalPeriodsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutRentalPeriodsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutRentalPeriodsInput, TeacherUncheckedUpdateWithoutRentalPeriodsInput>
  }

  export type TeacherUpdateWithoutRentalPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    moduleAssignments?: ModuleAssignmentUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUpdateManyWithoutCreatorNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUpdateManyWithoutAddedByNestedInput
    classes?: ClassUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUpdateManyWithoutTeacherNestedInput
    teams?: TeamUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutRentalPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    moduleAssignments?: ModuleAssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedCourses?: CourseUncheckedUpdateManyWithoutOwnerNestedInput
    createdModules?: ModuleUncheckedUpdateManyWithoutCreatorNestedInput
    ownedModules?: ModuleUncheckedUpdateManyWithoutOwnerNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExercises?: ExerciseUncheckedUpdateManyWithoutOwnerNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    ownedExams?: ExamUncheckedUpdateManyWithoutOwnerNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatorNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTeacherNestedInput
    purchases?: PurchasedItemUncheckedUpdateManyWithoutTeacherNestedInput
    createdMaterial?: MaterialUncheckedUpdateManyWithoutCreatorNestedInput
    ownedMaterial?: MaterialUncheckedUpdateManyWithoutOwnerNestedInput
    addedStudents?: StudentUncheckedUpdateManyWithoutAddedByNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTeacherNestedInput
    lessonsSchedule?: LessonScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutTeacherNestedInput
    teams?: TeamUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ShopItemForRentUpsertWithoutRentalPeriodsInput = {
    update: XOR<ShopItemForRentUpdateWithoutRentalPeriodsInput, ShopItemForRentUncheckedUpdateWithoutRentalPeriodsInput>
    create: XOR<ShopItemForRentCreateWithoutRentalPeriodsInput, ShopItemForRentUncheckedCreateWithoutRentalPeriodsInput>
    where?: ShopItemForRentWhereInput
  }

  export type ShopItemForRentUpdateToOneWithWhereWithoutRentalPeriodsInput = {
    where?: ShopItemForRentWhereInput
    data: XOR<ShopItemForRentUpdateWithoutRentalPeriodsInput, ShopItemForRentUncheckedUpdateWithoutRentalPeriodsInput>
  }

  export type ShopItemForRentUpdateWithoutRentalPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneWithoutForRentNestedInput
    module?: ModuleUpdateOneWithoutForRentNestedInput
    exercise?: ExerciseUpdateOneWithoutForRentNestedInput
    exam?: ExamUpdateOneWithoutForRentNestedInput
    material?: MaterialUpdateOneWithoutForRentNestedInput
  }

  export type ShopItemForRentUncheckedUpdateWithoutRentalPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumShopItemTypeEnumFieldUpdateOperationsInput | $Enums.ShopItemTypeEnum
    itemId?: StringFieldUpdateOperationsInput | string
    rentPrice?: IntFieldUpdateOperationsInput | number
    rentPeriod?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    roleId: string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    content: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    userId: string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleAssignmentCreateManyTeacherInput = {
    id?: string
    moduleId: string
    courseId: string
    hourlyRate: number
    currency?: $Enums.CurrencyTypeEnum
    startDate: Date | string
    endDate: Date | string
  }

  export type CourseCreateManyCreatorInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type CourseCreateManyOwnerInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    status?: $Enums.CourseStatusEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ModuleCreateManyCreatorInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ModuleCreateManyOwnerInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    courseId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ExerciseCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ExerciseCreateManyOwnerInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ExamCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date | string
    duration: number
    maxScore: number
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ExamCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    moduleId: string
    date: Date | string
    duration: number
    maxScore: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ClientCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    courseId?: string | null
    moduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyTeacherInput = {
    id?: string
    title?: string | null
    message?: string | null
    type: $Enums.NotificationTypeEnum
    studentId?: string | null
    seen?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasedItemCreateManyTeacherInput = {
    id?: string
    shopItemId: string
    purchaseDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalPeriodCreateManyTeacherInput = {
    id?: string
    shopItemId: string
    rentStartDate: Date | string
    rentEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type MaterialCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type MaterialCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type StudentCreateManyAddedByInput = {
    id?: string
    userId: string
    studentId: string
    enrollYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManyTeacherInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    courseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonScheduleCreateManyTeacherInput = {
    id?: string
    lessonId: string
    dateTime: Date | string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateManyTeacherInput = {
    id?: string
    courseId: string
    classId: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateManyTeacherInput = {
    id?: string
    name: string
    description?: string | null
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleAssignmentUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type ModuleAssignmentUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    owner?: TeacherUpdateOneRequiredWithoutOwnedCoursesNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    materials?: MaterialUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    events?: EventUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutCourseNestedInput
    comments?: CommentUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    events?: EventUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCourseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type CourseUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedCoursesNestedInput
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    materials?: MaterialUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    events?: EventUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutCourseNestedInput
    comments?: CommentUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    events?: EventUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCourseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCourseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutCourseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCourseStatusEnumFieldUpdateOperationsInput | $Enums.CourseStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ModuleUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ModuleUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ExerciseUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topic?: TopicUpdateOneWithoutExercisesNestedInput
    examExercises?: ExamExerciseUpdateManyWithoutExerciseNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExercisesNestedInput
    teams?: TeamUpdateManyWithoutExercisesNestedInput
    client?: ClientUpdateOneWithoutExercisesNestedInput
    comments?: CommentUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    teams?: TeamUncheckedUpdateManyWithoutExercisesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ExerciseUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topic?: TopicUpdateOneWithoutExercisesNestedInput
    examExercises?: ExamExerciseUpdateManyWithoutExerciseNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExercisesNestedInput
    teams?: TeamUpdateManyWithoutExercisesNestedInput
    client?: ClientUpdateOneWithoutExercisesNestedInput
    comments?: CommentUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    teams?: TeamUncheckedUpdateManyWithoutExercisesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ExamUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    module?: ModuleUpdateOneRequiredWithoutExamsNestedInput
    exercises?: ExamExerciseUpdateManyWithoutExamNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExamsNestedInput
    comments?: CommentUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    moduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedUpdateManyWithoutExamNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    moduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ExamUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    module?: ModuleUpdateOneRequiredWithoutExamsNestedInput
    exercises?: ExamExerciseUpdateManyWithoutExamNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExamsNestedInput
    comments?: CommentUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    moduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedUpdateManyWithoutExamNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    moduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ClientUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutEventsNestedInput
    module?: ModuleUpdateOneWithoutEventsNestedInput
    comments?: CommentUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeEnumFieldUpdateOperationsInput | $Enums.NotificationTypeEnum
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeEnumFieldUpdateOperationsInput | $Enums.NotificationTypeEnum
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeEnumFieldUpdateOperationsInput | $Enums.NotificationTypeEnum
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasedItemUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopItem?: ShopItemForSaleUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchasedItemUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopItemId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasedItemUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopItemId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalPeriodUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    rentStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shopItem?: ShopItemForRentUpdateOneRequiredWithoutRentalPeriodsNestedInput
  }

  export type RentalPeriodUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopItemId?: StringFieldUpdateOperationsInput | string
    rentStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RentalPeriodUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopItemId?: StringFieldUpdateOperationsInput | string
    rentStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MaterialUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    course?: CourseUpdateOneWithoutMaterialsNestedInput
    module?: ModuleUpdateOneWithoutMaterialsNestedInput
    topic?: TopicUpdateOneWithoutMaterialsNestedInput
    comments?: CommentUpdateManyWithoutMaterialNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedMaterialNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    comments?: CommentUncheckedUpdateManyWithoutMaterialNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type MaterialUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    course?: CourseUpdateOneWithoutMaterialsNestedInput
    module?: ModuleUpdateOneWithoutMaterialsNestedInput
    topic?: TopicUpdateOneWithoutMaterialsNestedInput
    comments?: CommentUpdateManyWithoutMaterialNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedMaterialNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    comments?: CommentUncheckedUpdateManyWithoutMaterialNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type StudentUpdateWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: ClassUpdateManyWithoutStudentsNestedInput
    teams?: TeamUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
    comments?: CommentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutStudentsNestedInput
    teams?: TeamUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassesNestedInput
    teams?: TeamUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    comments?: CommentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassesNestedInput
    teams?: TeamUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    comments?: CommentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonScheduleUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type LessonScheduleUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonScheduleUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    class?: ClassUpdateOneRequiredWithoutEnrollmentsNestedInput
    holidays?: HolidayUpdateManyWithoutEnrollmentNestedInput
    comments?: CommentUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holidays?: HolidayUncheckedUpdateManyWithoutEnrollmentNestedInput
    comments?: CommentUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTeamsNestedInput
    students?: StudentUpdateManyWithoutTeamsNestedInput
    exercises?: ExerciseUpdateManyWithoutTeamsNestedInput
    comments?: CommentUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutTeamsNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutTeamsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyStudentInput = {
    id?: string
    title?: string | null
    message?: string | null
    type: $Enums.NotificationTypeEnum
    teacherId?: string | null
    seen?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyStudentInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    teams?: TeamUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    comments?: CommentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    comments?: CommentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTeamsNestedInput
    exercises?: ExerciseUpdateManyWithoutTeamsNestedInput
    comments?: CommentUpdateManyWithoutTeamNestedInput
    teacher?: TeacherUpdateOneWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    exercises?: ExerciseUncheckedUpdateManyWithoutTeamsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeEnumFieldUpdateOperationsInput | $Enums.NotificationTypeEnum
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeEnumFieldUpdateOperationsInput | $Enums.NotificationTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeEnumFieldUpdateOperationsInput | $Enums.NotificationTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateManyCourseInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    category: string
    totalHours: number
    averageHoursPerLesson?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type MaterialCreateManyCourseInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    moduleId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type EnrollmentCreateManyCourseInput = {
    id?: string
    classId: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyCourseInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    moduleId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManyCourseInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyCourseInput = {
    id?: string
    content: string
    userId: string
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    creator?: TeacherUpdateOneRequiredWithoutCreatedModulesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedModulesNestedInput
    topics?: TopicUpdateManyWithoutModuleNestedInput
    materials?: MaterialUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    exams?: ExamUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    events?: EventUpdateManyWithoutModuleNestedInput
    comments?: CommentUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topics?: TopicUncheckedUpdateManyWithoutModuleNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    exams?: ExamUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    events?: EventUncheckedUpdateManyWithoutModuleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutModuleNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutModuleNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    averageHoursPerLesson?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type MaterialUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    module?: ModuleUpdateOneWithoutMaterialsNestedInput
    topic?: TopicUpdateOneWithoutMaterialsNestedInput
    comments?: CommentUpdateManyWithoutMaterialNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedMaterialNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedMaterialNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    comments?: CommentUncheckedUpdateManyWithoutMaterialNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type EnrollmentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutEnrollmentsNestedInput
    teacher?: TeacherUpdateOneWithoutEnrollmentsNestedInput
    holidays?: HolidayUpdateManyWithoutEnrollmentNestedInput
    comments?: CommentUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holidays?: HolidayUncheckedUpdateManyWithoutEnrollmentNestedInput
    comments?: CommentUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneWithoutEventsNestedInput
    comments?: CommentUpdateManyWithoutEventNestedInput
    creator?: TeacherUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassesNestedInput
    teams?: TeamUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    comments?: CommentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassesNestedInput
    teams?: TeamUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    comments?: CommentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicCreateManyModuleInput = {
    id?: string
    name: string
    description?: string | null
    order: number
  }

  export type MaterialCreateManyModuleInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    topicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ModuleAssignmentCreateManyModuleInput = {
    id?: string
    teacherId: string
    courseId: string
    hourlyRate: number
    currency?: $Enums.CurrencyTypeEnum
    startDate: Date | string
    endDate: Date | string
  }

  export type ExamCreateManyModuleInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.ExamTypeEnum
    date: Date | string
    duration: number
    maxScore: number
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type LessonCreateManyModuleInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyModuleInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    type: $Enums.EventTypeEnum
    courseId?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyModuleInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    materials?: MaterialUpdateManyWithoutTopicNestedInput
    exercises?: ExerciseUpdateManyWithoutTopicNestedInput
    objectives?: ObjectiveUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    materials?: MaterialUncheckedUpdateManyWithoutTopicNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutTopicNestedInput
    objectives?: ObjectiveUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    course?: CourseUpdateOneWithoutMaterialsNestedInput
    topic?: TopicUpdateOneWithoutMaterialsNestedInput
    comments?: CommentUpdateManyWithoutMaterialNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedMaterialNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedMaterialNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    comments?: CommentUncheckedUpdateManyWithoutMaterialNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ModuleAssignmentUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutModuleAssignmentsNestedInput
  }

  export type ModuleAssignmentUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    exercises?: ExamExerciseUpdateManyWithoutExamNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExamsNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExamsNestedInput
    comments?: CommentUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    exercises?: ExamExerciseUncheckedUpdateManyWithoutExamNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExamNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExamNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExamTypeEnumFieldUpdateOperationsInput | $Enums.ExamTypeEnum
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type LessonUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: LessonScheduleUpdateManyWithoutLessonNestedInput
    comments?: CommentUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: LessonScheduleUncheckedUpdateManyWithoutLessonNestedInput
    comments?: CommentUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutEventsNestedInput
    comments?: CommentUpdateManyWithoutEventNestedInput
    creator?: TeacherUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventTypeEnumFieldUpdateOperationsInput | $Enums.EventTypeEnum
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonScheduleCreateManyLessonInput = {
    id?: string
    dateTime: Date | string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
  }

  export type CommentCreateManyLessonInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonScheduleUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutLessonsScheduleNestedInput
  }

  export type LessonScheduleUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LessonScheduleUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateManyTopicInput = {
    id?: string
    name: string
    description?: string | null
    url?: string | null
    type: $Enums.MaterialType
    courseId?: string | null
    moduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    ownerId: string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ExerciseCreateManyTopicInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ObjectiveCreateManyTopicInput = {
    id?: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyTopicInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    course?: CourseUpdateOneWithoutMaterialsNestedInput
    module?: ModuleUpdateOneWithoutMaterialsNestedInput
    comments?: CommentUpdateManyWithoutMaterialNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedMaterialNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedMaterialNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    comments?: CommentUncheckedUpdateManyWithoutMaterialNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutMaterialNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaterialTypeFieldUpdateOperationsInput | $Enums.MaterialType
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ExerciseUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUpdateManyWithoutExerciseNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExercisesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExercisesNestedInput
    teams?: TeamUpdateManyWithoutExercisesNestedInput
    client?: ClientUpdateOneWithoutExercisesNestedInput
    comments?: CommentUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    teams?: TeamUncheckedUpdateManyWithoutExercisesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type ObjectiveUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObjectiveUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObjectiveUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamExerciseCreateManyExerciseInput = {
    examId: string
    order: number
  }

  export type CommentCreateManyExerciseInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamExerciseUpdateWithoutExerciseInput = {
    order?: IntFieldUpdateOperationsInput | number
    exam?: ExamUpdateOneRequiredWithoutExercisesNestedInput
  }

  export type ExamExerciseUncheckedUpdateWithoutExerciseInput = {
    examId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ExamExerciseUncheckedUpdateManyWithoutExerciseInput = {
    examId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TeamUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTeamsNestedInput
    students?: StudentUpdateManyWithoutTeamsNestedInput
    comments?: CommentUpdateManyWithoutTeamNestedInput
    teacher?: TeacherUpdateOneWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateManyWithoutTeamsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamExerciseCreateManyExamInput = {
    exerciseId: string
    order: number
  }

  export type CommentCreateManyExamInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamExerciseUpdateWithoutExamInput = {
    order?: IntFieldUpdateOperationsInput | number
    exercise?: ExerciseUpdateOneRequiredWithoutExamExercisesNestedInput
  }

  export type ExamExerciseUncheckedUpdateWithoutExamInput = {
    exerciseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ExamExerciseUncheckedUpdateManyWithoutExamInput = {
    exerciseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyMaterialInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutMaterialInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateManyEnrollmentInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyEnrollmentInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    classId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateManyWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyClassInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherId?: string | null
  }

  export type EnrollmentCreateManyClassInput = {
    id?: string
    courseId: string
    status?: $Enums.EnrollmentStatusEnum
    startDate: Date | string
    endDate: Date | string
    totalPrice?: number | null
    currency?: $Enums.CurrencyTypeEnum
    teacherId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyClassInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    teamId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    teams?: TeamUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
    comments?: CommentUpdateManyWithoutStudentNestedInput
    addedBy?: TeacherUpdateOneRequiredWithoutAddedStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: StringFieldUpdateOperationsInput | string
    teams?: TeamUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutTeamsNestedInput
    exercises?: ExerciseUpdateManyWithoutTeamsNestedInput
    comments?: CommentUpdateManyWithoutTeamNestedInput
    teacher?: TeacherUpdateOneWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateManyWithoutTeamsNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutTeamsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnrollmentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    teacher?: TeacherUpdateOneWithoutEnrollmentsNestedInput
    holidays?: HolidayUpdateManyWithoutEnrollmentNestedInput
    comments?: CommentUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holidays?: HolidayUncheckedUpdateManyWithoutEnrollmentNestedInput
    comments?: CommentUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type EnrollmentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollmentStatusEnumFieldUpdateOperationsInput | $Enums.EnrollmentStatusEnum
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyTypeEnumFieldUpdateOperationsInput | $Enums.CurrencyTypeEnum
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyEventInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    teamId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    team?: TeamUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyTeamInput = {
    id?: string
    content: string
    userId: string
    courseId?: string | null
    moduleId?: string | null
    topicId?: string | null
    materialId?: string | null
    enrollmentId?: string | null
    classId?: string | null
    eventId?: string | null
    lessonId?: string | null
    examId?: string | null
    exerciseId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    classes?: ClassUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
    comments?: CommentUpdateManyWithoutStudentNestedInput
    addedBy?: TeacherUpdateOneRequiredWithoutAddedStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: StringFieldUpdateOperationsInput | string
    classes?: ClassUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrollYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topic?: TopicUpdateOneWithoutExercisesNestedInput
    examExercises?: ExamExerciseUpdateManyWithoutExerciseNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExercisesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExercisesNestedInput
    client?: ClientUpdateOneWithoutExercisesNestedInput
    comments?: CommentUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type CommentUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    course?: CourseUpdateOneWithoutCommentsNestedInput
    module?: ModuleUpdateOneWithoutCommentsNestedInput
    topic?: TopicUpdateOneWithoutCommentsNestedInput
    material?: MaterialUpdateOneWithoutCommentsNestedInput
    enrollment?: EnrollmentUpdateOneWithoutCommentsNestedInput
    class?: ClassUpdateOneWithoutCommentsNestedInput
    event?: EventUpdateOneWithoutCommentsNestedInput
    lesson?: LessonUpdateOneWithoutCommentsNestedInput
    exam?: ExamUpdateOneWithoutCommentsNestedInput
    exercise?: ExerciseUpdateOneWithoutCommentsNestedInput
    student?: StudentUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    exerciseId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateManyClientInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: $Enums.ExerciseTypeEnum
    difficulty: $Enums.DifficultyLevelEnum
    points: number
    timeLimit?: number | null
    topicId?: string | null
    isTeamExercise?: boolean
    creatorId: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishStatus?: $Enums.PublishStatusEnum
  }

  export type ExerciseUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    topic?: TopicUpdateOneWithoutExercisesNestedInput
    examExercises?: ExamExerciseUpdateManyWithoutExerciseNestedInput
    creator?: TeacherUpdateOneRequiredWithoutCreatedExercisesNestedInput
    owner?: TeacherUpdateOneRequiredWithoutOwnedExercisesNestedInput
    teams?: TeamUpdateManyWithoutExercisesNestedInput
    comments?: CommentUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
    examExercises?: ExamExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    teams?: TeamUncheckedUpdateManyWithoutExercisesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutExerciseNestedInput
    forSale?: ShopItemForSaleUncheckedUpdateOneWithoutExerciseNestedInput
    forRent?: ShopItemForRentUncheckedUpdateOneWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumExerciseTypeEnumFieldUpdateOperationsInput | $Enums.ExerciseTypeEnum
    difficulty?: EnumDifficultyLevelEnumFieldUpdateOperationsInput | $Enums.DifficultyLevelEnum
    points?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    isTeamExercise?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishStatus?: EnumPublishStatusEnumFieldUpdateOperationsInput | $Enums.PublishStatusEnum
  }

  export type PurchasedItemCreateManyShopItemInput = {
    id?: string
    teacherId: string
    purchaseDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasedItemUpdateWithoutShopItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchasedItemUncheckedUpdateWithoutShopItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasedItemUncheckedUpdateManyWithoutShopItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalPeriodCreateManyShopItemInput = {
    id?: string
    teacherId: string
    rentStartDate: Date | string
    rentEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type RentalPeriodUpdateWithoutShopItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rentStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teacher?: TeacherUpdateOneRequiredWithoutRentalPeriodsNestedInput
  }

  export type RentalPeriodUncheckedUpdateWithoutShopItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    rentStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RentalPeriodUncheckedUpdateManyWithoutShopItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    rentStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}